{"version":3,"file":"index.js","mappings":"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IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IA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","sources":["webpack://cornerstoneTools3D/webpack/universalModuleDefinition","webpack://cornerstoneTools3D/../../node_modules/lodash.clonedeep/index.js","webpack://cornerstoneTools3D/../../node_modules/lodash.get/index.js","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/CellArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/DataArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/Math\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/MatrixBuilder\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/Points\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/AppendPolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/ClipClosedSurface\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/Actor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/AxesActor\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Rendering/Core/Mapper\"","webpack://cornerstoneTools3D/external umd {\"root\":\"cornerstone3D\",\"commonjs\":\"@cornerstonejs/core\",\"commonjs2\":\"@cornerstonejs/core\",\"amd\":\"@cornerstonejs/core\"}","webpack://cornerstoneTools3D/external umd {\"root\":\"window\",\"commonjs\":\"gl-matrix\",\"commonjs2\":\"gl-matrix\",\"amd\":\"gl-matrix\"}","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/typeof.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/regenerator/index.js","webpack://cornerstoneTools3D/webpack/bootstrap","webpack://cornerstoneTools3D/webpack/runtime/compat get default export","webpack://cornerstoneTools3D/webpack/runtime/define property getters","webpack://cornerstoneTools3D/webpack/runtime/global","webpack://cornerstoneTools3D/webpack/runtime/hasOwnProperty shorthand","webpack://cornerstoneTools3D/webpack/runtime/make namespace object","webpack://cornerstoneTools3D/webpack/runtime/node module decorator","webpack://cornerstoneTools3D/./src/enums/Events.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/createClass.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationLocking.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationSelection.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationVisibility.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.ts","webpack://cornerstoneTools3D/./src/store/svgNodeCache.ts","webpack://cornerstoneTools3D/./src/store/state.ts","webpack://cornerstoneTools3D/./src/enums/ToolModes.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroupsWithToolName.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/annotationState.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/helpers/state.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://cornerstoneTools3D/./src/constants/COLOR_LUT.ts","webpack://cornerstoneTools3D/./src/enums/SegmentationRepresentations.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourConfig.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/labelmapConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/SegmentationStateManager.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/triggerSegmentationEvents.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/normalizeSegmentationInput.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentationState.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/getMouseEventPoints.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseDoubleClickListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseMoveListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/mouseDownListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/mouse/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/wheelListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/normalizeWheel.ts","webpack://cornerstoneTools3D/./src/eventListeners/wheel/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/preventGhostClick.js","webpack://cornerstoneTools3D/./src/enums/Touch.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/getTouchEventPoints.ts","webpack://cornerstoneTools3D/./src/utilities/touch/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/touchStartListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/touch/index.ts","webpack://cornerstoneTools3D/./src/eventListeners/keyboard/keyDownListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/keyboard/index.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://cornerstoneTools3D/./src/drawingSvg/getSvgDrawingHelper.ts","webpack://cornerstoneTools3D/./src/drawingSvg/draw.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroupForViewport.ts","webpack://cornerstoneTools3D/./src/utilities/getToolsWithModesForElement.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRender.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/imageRenderedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithModesForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/cameraModifiedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/imageSpacingCalibratedEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/customCallbackHandler.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseClick.ts","webpack://cornerstoneTools3D/./src/store/filterToolsWithMoveableHandles.ts","webpack://cornerstoneTools3D/./src/store/filterToolsWithAnnotationsForElement.ts","webpack://cornerstoneTools3D/./src/store/filterMoveableAnnotationTools.ts","webpack://cornerstoneTools3D/./src/enums/ToolBindings.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getMouseModifier.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDownAnnotationAction.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDown.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithActionsForMouseEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDownActivate.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDoubleClick.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseDrag.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseMove.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseUp.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseEventHandlers/mouseWheel.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/mouseToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForKeyboardEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardEventHandlers/keyDown.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardEventHandlers/keyUp.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/keyboardToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getActiveToolForTouchEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/shared/getToolsWithModesForTouchEvent.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchStart.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchStartActivate.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchDrag.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchEnd.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchTap.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchEventHandlers/touchPress.ts","webpack://cornerstoneTools3D/./src/eventDispatchers/touchToolEventDispatcher.ts","webpack://cornerstoneTools3D/./src/store/addEnabledElement.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getSynchronizersForViewport.ts","webpack://cornerstoneTools3D/./src/store/removeEnabledElement.ts","webpack://cornerstoneTools3D/./src/utilities/triggerAnnotationRenderForViewportIds.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationModifiedListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/annotations/annotationSelectionListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getToolGroup.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/inherits.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationConfig.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationVisibility.ts","webpack://cornerstoneTools3D/./src/tools/base/BaseTool.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/removeSurfaceFromElement.ts","webpack://cornerstoneTools3D/./src/utilities/pointToString.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/addSurfaceToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Surface/surfaceDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/utils.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourConfigCache.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/addContourSetsToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/updateContourSets.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/addOrUpdateContourSets.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/removeContourFromElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Contour/contourDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/addLabelmapToElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/removeLabelmapFromElement.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/labelmapDisplay.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/SegmentationDisplayTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/triggerSegmentationRender.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationDataModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationRepresentationModifiedEventListener.ts","webpack://cornerstoneTools3D/./src/eventListeners/segmentation/segmentationRepresentationRemovedEventListener.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/removeSegmentationsFromToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/destroyToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/destroy.ts","webpack://cornerstoneTools3D/./src/init.ts","webpack://cornerstoneTools3D/./src/store/addTool.ts","webpack://cornerstoneTools3D/./src/store/cancelActiveManipulations.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/Synchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/createSynchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/destroy.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getSynchronizer.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/getAllSynchronizers.ts","webpack://cornerstoneTools3D/./src/store/SynchronizerManager/destroySynchronizer.ts","webpack://cornerstoneTools3D/./src/cursors/MouseCursor.ts","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/get.js","webpack://cornerstoneTools3D/../../node_modules/@babel/runtime/helpers/esm/superPropBase.js","webpack://cornerstoneTools3D/./src/enums/AnnotationStyleStates.ts","webpack://cornerstoneTools3D/./src/cursors/ImageMouseCursor.ts","webpack://cornerstoneTools3D/./src/cursors/SVGCursorDescriptor.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/ToolStyle.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/helpers.ts","webpack://cornerstoneTools3D/./src/cursors/SVGMouseCursor.ts","webpack://cornerstoneTools3D/./src/cursors/elementCursor.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/ToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/createToolGroup.ts","webpack://cornerstoneTools3D/./src/store/ToolGroupManager/getAllToolGroups.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/cameraSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createCameraPositionSynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/voiSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createVOISynchronizer.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/zoomPanSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createZoomPanSynchronizer.ts","webpack://cornerstoneTools3D/./src/utilities/clip.js","webpack://cornerstoneTools3D/./src/utilities/scroll.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/jumpToSlice.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/stackImageSyncCallback.ts","webpack://cornerstoneTools3D/./src/synchronizers/callbacks/areViewportsCoplanar .ts","webpack://cornerstoneTools3D/./src/synchronizers/synchronizers/createStackImageSynchronizer.ts","webpack://cornerstoneTools3D/./src/drawingSvg/_getHash.ts","webpack://cornerstoneTools3D/./src/drawingSvg/setAttributesIfNecessary.ts","webpack://cornerstoneTools3D/./src/drawingSvg/setNewAttributesIfValid.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawCircle.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawEllipse.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawHandles.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLine.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawPolyline.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawTextBox.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec2/findClosestPoint.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLink.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawLinkedTextBox.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawRect.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawArrow.ts","webpack://cornerstoneTools3D/./src/drawingSvg/drawRedactionRect.ts","webpack://cornerstoneTools3D/./src/utilities/getAnnotationNearPoint.ts","webpack://cornerstoneTools3D/./src/utilities/isObject.js","webpack://cornerstoneTools3D/./src/utilities/debounce.js","webpack://cornerstoneTools3D/./src/utilities/throttle.js","webpack://cornerstoneTools3D/./src/utilities/calibrateImageSpacing.ts","webpack://cornerstoneTools3D/./src/utilities/pointInShapeCallback.ts","webpack://cornerstoneTools3D/./src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack://cornerstoneTools3D/./src/utilities/pointInSurroundingSphereCallback.ts","webpack://cornerstoneTools3D/./src/utilities/math/sphere/pointInSphere.ts","webpack://cornerstoneTools3D/./src/utilities/roundNumber.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/utils/isWithinThreshold.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillSphere.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseSphere.ts","webpack://cornerstoneTools3D/./src/utilities/math/ellipse/getCanvasEllipseCorners.ts","webpack://cornerstoneTools3D/./src/utilities/math/ellipse/pointInEllipse.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillCircle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseCircle.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/activeSegmentation.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentLocking.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/segmentIndex.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/config/segmentationColor.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/BrushTool.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/utilities.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/thresholdVolumeByRange.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithToolEnabled.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/filterViewportsWithParallelNormals.ts","webpack://cornerstoneTools3D/./src/utilities/viewportFilters/getViewportIdsWithToolToRender.ts","webpack://cornerstoneTools3D/./src/utilities/planar/filterAnnotationsWithinSlice.ts","webpack://cornerstoneTools3D/./src/utilities/planar/filterAnnotationsForDisplay.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/getState.ts","webpack://cornerstoneTools3D/./src/tools/base/AnnotationDisplayTool.ts","webpack://cornerstoneTools3D/./src/tools/base/AnnotationTool.ts","webpack://cornerstoneTools3D/./src/utilities/getCalibratedUnits.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/rectangle/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/drawing/getTextBoxCoordsCanvas.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getWorldWidthAndHeightFromCorners.ts","webpack://cornerstoneTools3D/./src/utilities/getModalityUnit.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/isViewportPreScaled.ts","webpack://cornerstoneTools3D/./src/utilities/math/basic/Calculator.ts","webpack://cornerstoneTools3D/./src/utilities/math/basic/BasicStatsCalculator.ts","webpack://cornerstoneTools3D/./src/tools/annotation/RectangleROITool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleROIThresholdTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleROIStartEndThresholdTool.ts","webpack://cornerstoneTools3D/./src/utilities/boundingBox/extend2DBoundingBoxInViewAxis.ts","webpack://cornerstoneTools3D/./src/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/rectangleROIThresholdVolumeByRange.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createMergedLabelmapForIndex.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/isValidRepresentationConfig.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/getDefaultRepresentationConfig.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/createLabelmapVolumeForViewport.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/floodFill.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/brushSizeForToolGroup.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/brushThresholdForToolGroup.ts","webpack://cornerstoneTools3D/./src/utilities/segmentation/thresholdSegmentationByRange.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec2/liangBarksyClip.ts","webpack://cornerstoneTools3D/./src/utilities/math/line/intersectLine.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getIntersectionWithPolyline.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getSubPixelSpacingAndXYDirections.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/pointsAreWithinCloseContourProximity.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/addCanvasPointsToArray.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/pointCanProjectOnLine.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/calculateAreaOfPoints.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/distanceToPoint.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getPointInLineOfSightWithCriteria.ts","webpack://cornerstoneTools3D/./src/utilities/planar/index.ts","webpack://cornerstoneTools3D/./src/utilities/orientation/getOrientationStringLPS.ts","webpack://cornerstoneTools3D/./src/utilities/orientation/invertOrientationStringLPS.ts","webpack://cornerstoneTools3D/./src/utilities/cine/events.ts","webpack://cornerstoneTools3D/./src/utilities/cine/state.ts","webpack://cornerstoneTools3D/./src/utilities/cine/playClip.ts","webpack://cornerstoneTools3D/../../node_modules/d3-interpolate/src/basis.js","webpack://cornerstoneTools3D/../../node_modules/d3-interpolate/src/quantize.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/transpose.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/zip.js","webpack://cornerstoneTools3D/../../node_modules/d3-array/src/min.js","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolation/algorithms/bspline.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolatePoints.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/drawLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/editLoopCommon.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/closedContourEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/openContourEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/openContourEndEditLoop.ts","webpack://cornerstoneTools3D/./src/tools/annotation/planarFreehandROITool/renderMethods.ts","webpack://cornerstoneTools3D/./src/tools/annotation/PlanarFreehandROITool.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/interpolateAnnotation.ts","webpack://cornerstoneTools3D/./src/utilities/planarFreehandROITool/index.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/state.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackPrefetchUtils.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackPrefetch.ts","webpack://cornerstoneTools3D/./src/utilities/stackPrefetch/stackContextPrefetch.ts","webpack://cornerstoneTools3D/./src/utilities/viewport/jumpToWorld.ts","webpack://cornerstoneTools3D/./src/utilities/dynamicVolume/getDataInTime.ts","webpack://cornerstoneTools3D/./src/utilities/dynamicVolume/generateImageFromTimeData.ts","webpack://cornerstoneTools3D/./src/utilities/polyData/utils.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isRangeValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/areColorbarRangesEqual.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isColorbarSizeValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/areColorbarSizesEqual.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ColorbarCanvas.ts","webpack://cornerstoneTools3D/./src/utilities/math/vec3/interpolateVec3.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ColorbarTicks.ts","webpack://cornerstoneTools3D/./src/widgets/Widget.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/Colorbar.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/common/isRangeTextPositionValid.ts","webpack://cornerstoneTools3D/./src/utilities/voi/colorbar/ViewportColorbar.ts","webpack://cornerstoneTools3D/./src/utilities/getVOIMultipliers.ts","webpack://cornerstoneTools3D/./src/cursors/setCursorForElement.ts","webpack://cornerstoneTools3D/./src/cursors/index.ts","webpack://cornerstoneTools3D/./src/stateManagement/annotation/config/getFont.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/helpers/validateSegmentationInput.ts","webpack://cornerstoneTools3D/./src/tools/displayTools/Labelmap/validateRepresentationData.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentations.ts","webpack://cornerstoneTools3D/./src/stateManagement/segmentation/addSegmentationRepresentations.ts","webpack://cornerstoneTools3D/./src/tools/PanTool.ts","webpack://cornerstoneTools3D/./src/tools/TrackballRotateTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/ProbeTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/DragProbeTool.ts","webpack://cornerstoneTools3D/./src/tools/WindowLevelTool.ts","webpack://cornerstoneTools3D/./src/tools/ZoomTool.ts","webpack://cornerstoneTools3D/./src/tools/StackScrollTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/angle/angleBetweenLines.ts","webpack://cornerstoneTools3D/./src/tools/PlanarRotateTool.ts","webpack://cornerstoneTools3D/./src/tools/StackScrollToolMouseWheelTool.ts","webpack://cornerstoneTools3D/./src/tools/VolumeRotateMouseWheelTool.ts","webpack://cornerstoneTools3D/./src/tools/MIPJumpToClickTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/LengthTool.ts","webpack://cornerstoneTools3D/./src/tools/CrosshairsTool.ts","webpack://cornerstoneTools3D/./src/tools/ReferenceLinesTool.ts","webpack://cornerstoneTools3D/./src/tools/OverlayGridTool.ts","webpack://cornerstoneTools3D/./src/tools/SegmentationIntersectionTool.ts","webpack://cornerstoneTools3D/./src/utilities/planar/getWorldWidthAndHeightFromTwoPoints.ts","webpack://cornerstoneTools3D/./src/tools/annotation/EllipticalROITool.ts","webpack://cornerstoneTools3D/./src/utilities/math/circle/getCanvasCircleRadius.ts","webpack://cornerstoneTools3D/./src/utilities/math/circle/getCanvasCircleCorners.ts","webpack://cornerstoneTools3D/./src/tools/annotation/CircleROITool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/BidirectionalTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/ArrowAnnotateTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/AngleTool.ts","webpack://cornerstoneTools3D/./src/utilities/math/midPoint.ts","webpack://cornerstoneTools3D/./src/tools/annotation/CobbAngleTool.ts","webpack://cornerstoneTools3D/./src/tools/MagnifyTool.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyViewport.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyViewportManager.ts","webpack://cornerstoneTools3D/./src/tools/AdvancedMagnifyTool.ts","webpack://cornerstoneTools3D/./src/tools/ReferenceCursors.ts","webpack://cornerstoneTools3D/./src/tools/ScaleOverlayTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/fillRectangle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/strategies/eraseRectangle.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/RectangleScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/CircleScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/SphereScissorsTool.ts","webpack://cornerstoneTools3D/./src/tools/OrientationMarkerTool.ts","webpack://cornerstoneTools3D/./src/tools/segmentation/PaintFillTool.ts","webpack://cornerstoneTools3D/./src/tools/annotation/VideoRedactionTool.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"gl-matrix\"), require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"), require(\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"), require(\"@kitware/vtk.js/Common/Core/CellArray\"), require(\"@kitware/vtk.js/Common/Core/Points\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@kitware/vtk.js/Filters/General/AppendPolyData\"), require(\"@kitware/vtk.js/Rendering/Core/Actor\"), require(\"@kitware/vtk.js/Rendering/Core/Mapper\"), require(\"@kitware/vtk.js/Filters/General/ClipClosedSurface\"), require(\"@kitware/vtk.js/Common/Core/Math\"), require(\"@kitware/vtk.js/Common/Core/MatrixBuilder\"), require(\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"), require(\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"), require(\"@kitware/vtk.js/Rendering/Core/AxesActor\"), require(\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"gl-matrix\", \"@cornerstonejs/core\", \"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\", \"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\", \"@kitware/vtk.js/Common/Core/CellArray\", \"@kitware/vtk.js/Common/Core/Points\", \"@kitware/vtk.js/Common/DataModel/PolyData\", \"@kitware/vtk.js/Common/Core/DataArray\", \"@kitware/vtk.js/Filters/General/AppendPolyData\", \"@kitware/vtk.js/Rendering/Core/Actor\", \"@kitware/vtk.js/Rendering/Core/Mapper\", \"@kitware/vtk.js/Filters/General/ClipClosedSurface\", \"@kitware/vtk.js/Common/Core/Math\", \"@kitware/vtk.js/Common/Core/MatrixBuilder\", \"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\", \"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\", \"@kitware/vtk.js/Rendering/Core/AxesActor\", \"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneTools3D\"] = factory(require(\"gl-matrix\"), require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"), require(\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"), require(\"@kitware/vtk.js/Common/Core/CellArray\"), require(\"@kitware/vtk.js/Common/Core/Points\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@kitware/vtk.js/Filters/General/AppendPolyData\"), require(\"@kitware/vtk.js/Rendering/Core/Actor\"), require(\"@kitware/vtk.js/Rendering/Core/Mapper\"), require(\"@kitware/vtk.js/Filters/General/ClipClosedSurface\"), require(\"@kitware/vtk.js/Common/Core/Math\"), require(\"@kitware/vtk.js/Common/Core/MatrixBuilder\"), require(\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"), require(\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"), require(\"@kitware/vtk.js/Rendering/Core/AxesActor\"), require(\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"));\n\telse\n\t\troot[\"cornerstoneTools3D\"] = factory(root[\"window\"], root[\"cornerstone3D\"], root[\"@kitware/vtk.js/Common/DataModel/PiecewiseFunction\"], root[\"@kitware/vtk.js/Rendering/Core/ColorTransferFunction\"], root[\"@kitware/vtk.js/Common/Core/CellArray\"], root[\"@kitware/vtk.js/Common/Core/Points\"], root[\"@kitware/vtk.js/Common/DataModel/PolyData\"], root[\"@kitware/vtk.js/Common/Core/DataArray\"], root[\"@kitware/vtk.js/Filters/General/AppendPolyData\"], root[\"@kitware/vtk.js/Rendering/Core/Actor\"], root[\"@kitware/vtk.js/Rendering/Core/Mapper\"], root[\"@kitware/vtk.js/Filters/General/ClipClosedSurface\"], root[\"@kitware/vtk.js/Common/Core/Math\"], root[\"@kitware/vtk.js/Common/Core/MatrixBuilder\"], root[\"@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget\"], root[\"@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor\"], root[\"@kitware/vtk.js/Rendering/Core/AxesActor\"], root[\"@kitware/vtk.js/IO/XML/XMLPolyDataReader\"]);\n})(self, function(__WEBPACK_EXTERNAL_MODULE__976__, __WEBPACK_EXTERNAL_MODULE__953__, __WEBPACK_EXTERNAL_MODULE__441__, __WEBPACK_EXTERNAL_MODULE__795__, __WEBPACK_EXTERNAL_MODULE__396__, __WEBPACK_EXTERNAL_MODULE__348__, __WEBPACK_EXTERNAL_MODULE__70__, __WEBPACK_EXTERNAL_MODULE__785__, __WEBPACK_EXTERNAL_MODULE__127__, __WEBPACK_EXTERNAL_MODULE__474__, __WEBPACK_EXTERNAL_MODULE__610__, __WEBPACK_EXTERNAL_MODULE__448__, __WEBPACK_EXTERNAL_MODULE__807__, __WEBPACK_EXTERNAL_MODULE__847__, __WEBPACK_EXTERNAL_MODULE__518__, __WEBPACK_EXTERNAL_MODULE__744__, __WEBPACK_EXTERNAL_MODULE__424__, __WEBPACK_EXTERNAL_MODULE__614__) {\nreturn ","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/**\n * Adds the key-value `pair` to `map`.\n *\n * @private\n * @param {Object} map The map to modify.\n * @param {Array} pair The key-value pair to add.\n * @returns {Object} Returns `map`.\n */\nfunction addMapEntry(map, pair) {\n  // Don't return `map.set` because it's not chainable in IE 11.\n  map.set(pair[0], pair[1]);\n  return map;\n}\n\n/**\n * Adds `value` to `set`.\n *\n * @private\n * @param {Object} set The set to modify.\n * @param {*} value The value to add.\n * @returns {Object} Returns `set`.\n */\nfunction addSetEntry(set, value) {\n  // Don't return `set.add` because it's not chainable in IE 11.\n  set.add(value);\n  return set;\n}\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @param {boolean} [isFull] Specify a clone including symbols.\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, isDeep, isFull, customizer, key, object, stack) {\n  var result;\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      if (isHostObject(value)) {\n        return object ? value : {};\n      }\n      result = initCloneObject(isFunc ? {} : value);\n      if (!isDeep) {\n        return copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, baseClone, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (!isArr) {\n    var props = isFull ? getAllKeys(value) : keys(value);\n  }\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} prototype The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nfunction baseCreate(proto) {\n  return isObject(proto) ? objectCreate(proto) : {};\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var result = new buffer.constructor(buffer.length);\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `map`.\n *\n * @private\n * @param {Object} map The map to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned map.\n */\nfunction cloneMap(map, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);\n  return arrayReduce(array, addMapEntry, new map.constructor);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of `set`.\n *\n * @private\n * @param {Object} set The set to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned set.\n */\nfunction cloneSet(set, isDeep, cloneFunc) {\n  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);\n  return arrayReduce(array, addSetEntry, new set.constructor);\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Copies own symbol properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Creates an array of the own enumerable symbol properties of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {Function} cloneFunc The function to clone values.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, cloneFunc, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return cloneMap(object, isDeep, cloneFunc);\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return cloneSet(object, isDeep, cloneFunc);\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, true, true);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__396__;","module.exports = __WEBPACK_EXTERNAL_MODULE__785__;","module.exports = __WEBPACK_EXTERNAL_MODULE__807__;","module.exports = __WEBPACK_EXTERNAL_MODULE__847__;","module.exports = __WEBPACK_EXTERNAL_MODULE__348__;","module.exports = __WEBPACK_EXTERNAL_MODULE__441__;","module.exports = __WEBPACK_EXTERNAL_MODULE__70__;","module.exports = __WEBPACK_EXTERNAL_MODULE__127__;","module.exports = __WEBPACK_EXTERNAL_MODULE__448__;","module.exports = __WEBPACK_EXTERNAL_MODULE__614__;","module.exports = __WEBPACK_EXTERNAL_MODULE__518__;","module.exports = __WEBPACK_EXTERNAL_MODULE__474__;","module.exports = __WEBPACK_EXTERNAL_MODULE__744__;","module.exports = __WEBPACK_EXTERNAL_MODULE__424__;","module.exports = __WEBPACK_EXTERNAL_MODULE__795__;","module.exports = __WEBPACK_EXTERNAL_MODULE__610__;","module.exports = __WEBPACK_EXTERNAL_MODULE__953__;","module.exports = __WEBPACK_EXTERNAL_MODULE__976__;","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    defineProperty = Object.defineProperty || function (obj, key, desc) {\n      obj[key] = desc.value;\n    },\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    }), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    defineProperty(this, \"_invoke\", {\n      value: function value(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = \"suspendedStart\";\n    return function (method, arg) {\n      if (\"executing\" === state) throw new Error(\"Generator is already running\");\n      if (\"completed\" === state) {\n        if (\"throw\" === method) throw arg;\n        return doneResult();\n      }\n      for (context.method = method, context.arg = arg;;) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n          if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n          context.dispatchException(context.arg);\n        } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n        state = \"executing\";\n        var record = tryCatch(innerFn, self, context);\n        if (\"normal\" === record.type) {\n          if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        }\n        \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method,\n      method = delegate.iterator[methodName];\n    if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel;\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (val) {\n    var object = Object(val),\n      keys = [];\n    for (var key in object) keys.push(key);\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","// TODO(Babel 8): Remove this file.\n\nvar runtime = require(\"../helpers/regeneratorRuntime\")();\nmodule.exports = runtime;\n\n// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/**\n *  The events for cornerstoneTools3D Tools. Native Mouse and Keyboard events are\n *  captured, normalized, and re-triggered with a `CORNERSTONE_TOOLS` prefix. This\n *  allows us to handle events consistently across different browsers.\n *\n */\nenum Events {\n  ///////////////////////////////////////\n  //            Tools\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new tools is activated.\n   *\n   * Make use of {@link EventTypes.ToolActivatedEventType | Tool Activated Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolActivatedEventDetail | Tool Activated Event Detail}.\n   */\n  TOOL_ACTIVATED = 'CORNERSTONE_TOOLS_TOOL_ACTIVATED',\n\n  /**\n   * Triggers on the eventTarget when a mode of a tool is changed (active, passive, enabled and disabled).\n   *\n   * Make use of {@link EventTypes.ToolModeChangedEventType | Tool Mode Changed Event Type  }\n   * for typing your event listeners for this tool activated event, and see what event\n   * detail is included in {@link EventTypes.ToolModeChangedEventDetail | Tool Mode Changed Event Detail}.\n   */\n  TOOL_MODE_CHANGED = 'CORNERSTONE_TOOLS_TOOL_MODE_CHANGED',\n\n  ///////////////////////////////////////\n  //            Annotations\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a new annotation is added to the state.\n   *\n   * Make use of {@link EventTypes.AnnotationAddedEventType | Annotation Added Event Type  }\n   * for typing your event listeners for this annotation added event, and see what event\n   * detail is included in {@link EventTypes.AnnotationAddedEventDetail | Annotation Added Event Detail}.\n   */\n  ANNOTATION_ADDED = 'CORNERSTONE_TOOLS_ANNOTATION_ADDED',\n\n  /**\n   * Triggers on the eventTarget when a new annotation is completed its drawing\n   * Make use of {@link EventTypes.AnnotationCompletedEventType | Annotation Completed Event Type }\n   * for typing your event listeners for this annotation completed event, and see what event\n   * detail is included in {@link EventTypes.AnnotationCompletedEventDetail | Annotation Completed Event Detail}.\n   */\n  ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is modified (e.g. a handle is modified).\n   * Make use of {@link EventTypes.AnnotationModifiedEventType | Annotation Modified Event Type}\n   * for typing your event listeners for this annotation modified event, and see what\n   * event detail is included in {@link EventTypes.AnnotationModifiedEventDetail | Annotation Modified Event Detail}.\n   */\n  ANNOTATION_MODIFIED = 'CORNERSTONE_TOOLS_ANNOTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when an annotation is removed from the annotations manager.\n   * Make use of {@link EventTypes.AnnotationRemovedEventType | Annotation Removed Event Type}\n   * for typing your event listeners for this annotation removed event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRemovedEventDetail | Annotation Removed Event Detail}.\n   */\n  ANNOTATION_REMOVED = 'CORNERSTONE_TOOLS_ANNOTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when an annotation selection status is changed.\n   * Make use of {@link EventTypes.AnnotationSelectionChangeEventType | Annotation Selection Change Event Type}\n   * for typing your event listeners for this annotation selection change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationSelectionChangeEventDetail | Annotation Selection Change Event Detail}.\n   */\n  ANNOTATION_SELECTION_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation locked status is changed.\n   * Make use of {@link EventTypes.AnnotationLockChangeEventType | Annotation Lock Change Event Type}\n   * for typing your event listeners for this annotation lock change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationLockChangeEventDetail | Annotation Lock Change Event Detail}.\n   */\n  ANNOTATION_LOCK_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation visible status is changed.\n   * Make use of {@link EventTypes.AnnotationVisibilityChangeEventType | Annotation Visible Change Event Type}\n   * for typing your event listeners for this annotation Hide change event, and see what\n   * event detail is included in {@link EventTypes.AnnotationVisibilityChangeEventDetail | Annotation Visible Change Event Detail}.\n   */\n  ANNOTATION_VISIBILITY_CHANGE = 'CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE',\n\n  /**\n   * Triggers on the eventTarget when an annotation is rendered.\n   * Make use of {@link EventTypes.AnnotationRenderedEventType | Annotation Rendered Event Type}\n   * for typing your event listeners for this annotation rendered event, and see what\n   * event detail is included in {@link EventTypes.AnnotationRenderedEventDetail | Annotation Rendered Event Detail}.\n   */\n  ANNOTATION_RENDERED = 'CORNERSTONE_TOOLS_ANNOTATION_RENDERED',\n\n  ///////////////////////////////////////\n  //        Segmentations Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is updated in the state manager.\n   * Make use of {@link EventTypes.SegmentationModifiedEventType | Segmentation Modified Event Type}\n   * for typing your event listeners for this segmentation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationModifiedEventDetail | Segmentation Modified Event Detail}.\n   */\n  SEGMENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is rendered by the Segmentation Rendering Engine.\n   * Make use of {@link EventTypes.SegmentationRenderedEventType | Segmentation Rendered Event Type}\n   * for typing your event listeners for this segmentation rendered event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRenderedEventDetail | Segmentation Rendered Event Detail}.\n   */\n  SEGMENTATION_RENDERED = 'CORNERSTONE_TOOLS_SEGMENTATION_RENDERED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is modified in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationModifiedEventType | Segmentation Representation Modified Event Type}\n   * for typing your event listeners for this segmentation representation modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationModifiedEventDetail | Segmentation Representation Modified Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation is removed from the state manager.\n   * Make use of {@link EventTypes.SegmentationRemovedEventType | Segmentation Removed Event Type}\n   * for typing your event listeners for this segmentation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRemovedEventDetail | Segmentation Removed Event Detail}.\n   */\n  SEGMENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation representation of a toolGroup is removed in the state manager.\n   * Make use of {@link EventTypes.SegmentationRepresentationRemovedEventType | Segmentation Representation Removed Event Type}\n   * for typing your event listeners for this segmentation representation removed event, and see what\n   * event detail is included in {@link EventTypes.SegmentationRepresentationRemovedEventDetail | Segmentation Representation Removed Event Detail}.\n   */\n  SEGMENTATION_REPRESENTATION_REMOVED = 'CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED',\n\n  /**\n   * Triggers on the eventTarget when a Segmentation data is modified (e.g., by brush tool).\n   * Make use of {@link EventTypes.SegmentationDataModifiedEventType | Segmentation Data Modified Event Type}\n   * for typing your event listeners for this segmentation data modified event, and see what\n   * event detail is included in {@link EventTypes.SegmentationDataModifiedEventDetail | Segmentation Data Modified Event Detail}.\n   */\n  SEGMENTATION_DATA_MODIFIED = 'CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED',\n\n  ///////////////////////////////////////\n  //         Keyboard Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is pressed.\n   * Make use of {@link EventTypes.KeyDownEventType | Key Down Event Type}\n   * for typing your event listeners for this key down event, and see what\n   * event detail is included in {@link EventTypes.KeyDownEventDetail | Key Down Event Detail}.\n   */\n  KEY_DOWN = 'CORNERSTONE_TOOLS_KEY_DOWN',\n\n  /**\n   * Triggers on the eventTarget when a key on the keyboard is released.\n   * Make use of {@link EventTypes.KeyUpEventType | Key Up Event Type}\n   * for typing your event listeners for this key up event, and see what\n   * event detail is included in {@link EventTypes.KeyUpEventDetail | Key Up Event Detail}.\n   */\n  KEY_UP = 'CORNERSTONE_TOOLS_KEY_UP',\n\n  ///////////////////////////////////////\n  //      Mouse Events\n  ///////////////////////////////////////\n\n  /**\n   * Triggers on the eventTarget when the mouse is pressed down, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDownEventType | Mouse Down Event Type}\n   * for typing your event listeners for this mouse down event, and see what\n   * event detail is included in {@link EventTypes.MouseDownEventDetail | Mouse Down Event Detail}.\n   */\n  MOUSE_DOWN = 'CORNERSTONE_TOOLS_MOUSE_DOWN',\n\n  /**\n   * Triggers on the eventTarget when the mouse is released, it is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseUpEventType | Mouse Up Event Type}\n   * for typing your event listeners for this mouse up event, and see what\n   * event detail is included in {@link EventTypes.MouseUpEventDetail | Mouse Up Event Detail}.\n   */\n  MOUSE_UP = 'CORNERSTONE_TOOLS_MOUSE_UP',\n\n  /**\n   * Triggers on the eventTarget when a handled `MOUSE_DOWN` event does not `stopPropagation`. The hook\n   * we use to create new annotation for mouse events.\n   * Make use of {@link EventTypes.MouseDownActivateEventType | Mouse Down Activate Event Type}\n   * for typing your event listeners for this mouse down activate event, and see what\n   * event detail is included in {@link EventTypes.MouseDownActivateEventDetail | Mouse Down Activate Event Detail}.\n   */\n  MOUSE_DOWN_ACTIVATE = 'CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE',\n\n  /**\n   * Triggers on the event target when mouse is dragging an annotation or textBox.\n   * Make use of {@link EventTypes.MouseDragEventType | Mouse Drag Event Type}\n   * for typing your event listeners for this mouse drag event, and see what\n   * event detail is included in {@link EventTypes.MouseDragEventDetail | Mouse Drag Event Detail}.\n   */\n  MOUSE_DRAG = 'CORNERSTONE_TOOLS_MOUSE_DRAG',\n\n  /**\n   * Triggers on the eventTarget, when the mouse is moved, it is CornerstoneTools normalized event.\n   * It can be just a mouse move or when double click is performed and annotation\n   * drawing can be performed with just mouse move.\n   * Make use of {@link EventTypes.MouseMoveEventType | Mouse Move Event Type}\n   * for typing your event listeners for this mouse move event, and see what\n   * event detail is included in {@link EventTypes.MouseMoveEventDetail | Mouse Move Event Detail}.\n   */\n  MOUSE_MOVE = 'CORNERSTONE_TOOLS_MOUSE_MOVE',\n\n  /**\n   * Triggers on the eventTarget when a mouse click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseClickEventType | Mouse Click Event Type}\n   * for typing your event listeners for this mouse click event, and see what\n   * event detail is included in {@link EventTypes.MouseClickEventDetail | Mouse Click Event Detail}.\n   */\n  MOUSE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse double click is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseDoubleClickEventType | Mouse Double Click Event Type}\n   * for typing your event listeners for this mouse double click event, and see what\n   * event detail is included in {@link EventTypes.MouseDoubleClickEventDetail | Mouse Double Click Event Detail}.\n   */\n  MOUSE_DOUBLE_CLICK = 'CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK',\n\n  /**\n   * Triggers on the eventTarget when a mouse wheel event is detected. It is CornerstoneTools normalized event.\n   * Make use of {@link EventTypes.MouseWheelEventType | Mouse Wheel Event Type}\n   * for typing your event listeners for this mouse wheel event, and see what\n   * event detail is included in {@link EventTypes.MouseWheelEventDetail | Mouse Wheel Event Detail}.\n   */\n  MOUSE_WHEEL = 'CORNERSTONE_TOOLS_MOUSE_WHEEL',\n\n  // Todo: not being fired as of now\n  // ANNOTATION_COMPLETED = 'CORNERSTONE_TOOLS_ANNOTATION_COMPLETED',\n  // Todo: not implemented yet\n  // KEY_PRESS = 'CORNERSTONE_TOOLS_KEY_PRESS',\n\n  //////////////////////\n  //   Touch Events   //\n  //////////////////////\n  // The event flow looks like the following\n  // Touch Start -> (optional) Touch Press -> Touch Drag -> (optional) Touch Swipe -> Touch End\n  // Touch Tap\n  // mousedown\n  // mousedown, Touch Start, and Tap are mutually exclusive events\n  TOUCH_START = 'CORNERSTONE_TOOLS_TOUCH_START',\n  TOUCH_START_ACTIVATE = 'CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE',\n  TOUCH_PRESS = 'CORNERSTONE_TOOLS_TOUCH_PRESS',\n  TOUCH_DRAG = 'CORNERSTONE_TOOLS_TOUCH_DRAG',\n  TOUCH_END = 'CORNERSTONE_TOOLS_TOUCH_END',\n  TOUCH_TAP = 'CORNERSTONE_TOOLS_TAP',\n  TOUCH_SWIPE = 'CORNERSTONE_TOOLS_SWIPE',\n}\n\nexport default Events;\n","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationLockChangeEventDetail } from '../../types/EventTypes';\n\n/*\n * Constants\n */\nconst globalLockedAnnotationsSet: Set<Annotation> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"Locked\" state of a given annotation instance.\n *\n * @triggers ANNOTATION_LOCK_CHANGE\n *\n * @param annotation - The annotation instance which will have\n * its locked state changed. An event will only be triggered if the locked state\n * of the given annotation instance changed.\n * @param locked - A boolean value indicating if the instance should\n * be locked (true) or not (false)\n */\nfunction setAnnotationLocked(annotation: Annotation, locked = true): void {\n  const detail = makeEventDetail();\n  if (annotation) {\n    if (locked) {\n      lock(annotation, globalLockedAnnotationsSet, detail);\n    } else {\n      unlock(annotation, globalLockedAnnotationsSet, detail);\n    }\n  }\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Clears all the locked annotation\n *\n */\nfunction unlockAllAnnotations(): void {\n  const detail = makeEventDetail();\n  clearLockedAnnotationsSet(globalLockedAnnotationsSet, detail);\n  publish(detail, globalLockedAnnotationsSet);\n}\n\n/**\n * Returns an array of all the annotation that is currently locked\n * @returns An array of tool specific annotation objects.\n *\n */\nfunction getAnnotationsLocked(): Array<Annotation> {\n  return Array.from(globalLockedAnnotationsSet);\n}\n\n/**\n * Given a Annotation object, return true if it is locked.\n * @param annotation - Annotation\n * @returns A boolean value.\n */\nfunction isAnnotationLocked(annotation: Annotation): boolean {\n  return globalLockedAnnotationsSet.has(annotation);\n}\n\n/**\n * Get the number of locked annotation objects in the global set of locked annotation\n * objects.\n * @returns The number of locked annotation objects.\n *\n */\nfunction getAnnotationsLockedCount(): number {\n  return globalLockedAnnotationsSet.size;\n}\n\n/**\n * Properly initialize the isLocked on annotation, and set it as locked if\n * isLocked is true.\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsLockedProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isLocked = !!annotation.isLocked;\n    if (shouldDefineIsLockedProperty(annotation)) {\n      Object.defineProperty(annotation, 'isLocked', {\n        configurable: false,\n        enumerable: true,\n        set: setIsLocked,\n        get: getIsLocked,\n      });\n    }\n    setAnnotationLocked(annotation, isLocked);\n  }\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationLockChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    locked: [],\n  });\n}\n\nfunction lock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (!lockedAnnotationsSet.has(annotation)) {\n    lockedAnnotationsSet.add(annotation);\n    detail.added.push(annotation);\n  }\n}\n\nfunction unlock(\n  annotation: Annotation,\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  if (lockedAnnotationsSet.delete(annotation)) {\n    detail.removed.push(annotation);\n  }\n}\n\nfunction clearLockedAnnotationsSet(\n  lockedAnnotationsSet: Set<Annotation>,\n  detail: AnnotationLockChangeEventDetail\n): void {\n  lockedAnnotationsSet.forEach((annotation) => {\n    unlock(annotation, lockedAnnotationsSet, detail);\n  });\n}\n\nfunction publish(\n  detail: AnnotationLockChangeEventDetail,\n  lockedAnnotationsSet: Set<Annotation>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    lockedAnnotationsSet.forEach((item) => void detail.locked.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsLockedProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isLocked');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsLocked || descriptor.get !== getIsLocked)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsLocked(locked: boolean) {\n  setAnnotationLocked(this as Annotation, locked);\n}\n\nfunction getIsLocked() {\n  return isAnnotationLocked(this as Annotation);\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationLocked,\n  getAnnotationsLocked,\n  getAnnotationsLockedCount,\n  unlockAllAnnotations,\n  isAnnotationLocked,\n  checkAndDefineIsLockedProperty,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { AnnotationSelectionChangeEventDetail } from '../../types/EventTypes';\nimport { getAnnotation } from './annotationState';\n\n/*\n * Constants\n */\n\nconst selectedAnnotationUIDs: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set a given annotationUID as selected or deselected based on the provided\n * selected value.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param selected - When true, the annotation is selected. When false, the annotation is deselected.\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction setAnnotationSelected(\n  annotationUID: string,\n  selected = true,\n  preserveSelected = false\n): void {\n  if (selected) {\n    selectAnnotation(annotationUID, preserveSelected);\n  } else {\n    deselectAnnotation(annotationUID);\n  }\n}\n\n/**\n * Set a given annotation as selected.\n *\n * @param annotationUID - The annotation UID to be selected\n * @param preserveSelected - When true, preserves existing\n *  selections (i.e., the given annotation is appended to the selection set).\n *  When false (the default behavior) the currently selected items are discarded\n *  (i.e., the given annotation instance replaces the currently selected ones).\n */\nfunction selectAnnotation(\n  annotationUID: string,\n  preserveSelected = false\n): void {\n  const detail = makeEventDetail();\n  if (!preserveSelected) {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n    selectedAnnotationUIDs.add(annotationUID);\n    detail.added.push(annotationUID);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Deselect one or all annotations.\n *\n * @param annotationUID - If an annotation is provided that instance will be removed from\n * the internal selection set. If none is given, ALL selections will be cleared.\n */\nfunction deselectAnnotation(annotationUID?: string): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (selectedAnnotationUIDs.delete(annotationUID)) {\n      detail.removed.push(annotationUID);\n    }\n  } else {\n    clearSelectionSet(selectedAnnotationUIDs, detail);\n  }\n  publish(detail, selectedAnnotationUIDs);\n}\n\n/**\n * Return an array of ALL the selected annotationUIDs\n * @returns An array of Annotation UIDs\n */\nfunction getAnnotationsSelected(): Array<string> {\n  return Array.from(selectedAnnotationUIDs);\n}\n\n/**\n * Given a tool name, return ALL the annotationUIDs for that tool that are selected\n * @param toolName - The name of the tool you want to get the selected annotation for\n * @returns An array of annotationUIDs\n */\nfunction getAnnotationsSelectedByToolName(toolName: string): Array<string> {\n  return getAnnotationsSelected().filter((annotationUID) => {\n    const annotation = getAnnotation(annotationUID);\n    return annotation.metadata.toolName === toolName;\n  });\n}\n\n/**\n * Given an annotationUID, return true if it is selected, false\n * otherwise.\n * @param annotationUID - Annotation UID\n * @returns A boolean value.\n */\nfunction isAnnotationSelected(annotationUID: string): boolean {\n  return selectedAnnotationUIDs.has(annotationUID);\n}\n\n/**\n * Return the number of the selected annotation\n * @returns The size of the selected annotation set\n */\nfunction getAnnotationsSelectedCount(): number {\n  return selectedAnnotationUIDs.size;\n}\n\n/*\n * Private Helpers\n */\n\nfunction makeEventDetail(): AnnotationSelectionChangeEventDetail {\n  return Object.freeze({\n    added: [],\n    removed: [],\n    selection: [],\n  });\n}\n\nfunction clearSelectionSet(\n  selectionSet: Set<string>,\n  detail: AnnotationSelectionChangeEventDetail\n): void {\n  selectionSet.forEach((value) => {\n    if (selectionSet.delete(value)) {\n      detail.removed.push(value);\n    }\n  });\n}\n\nfunction publish(\n  detail: AnnotationSelectionChangeEventDetail,\n  selectionSet: Set<string>\n) {\n  if (detail.added.length > 0 || detail.removed.length > 0) {\n    selectionSet.forEach((item) => void detail.selection.push(item));\n    triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n  }\n}\n\n/*\n * Exports\n */\n\nexport {\n  setAnnotationSelected,\n  getAnnotationsSelected,\n  getAnnotationsSelectedByToolName,\n  getAnnotationsSelectedCount,\n  deselectAnnotation,\n  isAnnotationSelected,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotation } from './annotationState';\nimport { Events } from '../../enums';\nimport { Annotation } from '../../types';\nimport { AnnotationVisibilityChangeEventDetail } from '../../types/EventTypes';\nimport {\n  isAnnotationSelected,\n  deselectAnnotation,\n} from './annotationSelection';\n\n/*\n * It stores all hidden annotation uids.\n */\nconst globalHiddenAnnotationUIDsSet: Set<string> = new Set();\n\n/*\n * Interface (Public API)\n */\n\n/**\n * Set the \"visible\" state of a given annotation instance.\n *\n * @event ANNOTATION_VISIBILITY_CHANGE\n *\n * @param annotationUID - The annotation uid which will have\n * its visible state changed. An event will only be triggered if the visible state\n * of the given annotation instance changed.\n * @param visible - A boolean value indicating if the instance should\n * be visible (true) or not (false)\n */\nfunction setAnnotationVisibility(annotationUID: string, visible = true): void {\n  const detail = makeEventDetail();\n  if (annotationUID) {\n    if (visible) {\n      show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    } else {\n      hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    }\n  }\n  publish(detail);\n}\n\n/**\n * Clears all the hidden annotations.\n *\n */\nfunction showAllAnnotations(): void {\n  const detail = makeEventDetail();\n  globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n    show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n  });\n  publish(detail);\n}\n\n/**\n * Given an annotation UID, return true if it is visible, false if hidden and undefined if does not exist.\n * @param annotationUID - The annotation uid to tell if is visible or not.\n * @returns A boolean value or value if does not exist.\n */\nfunction isAnnotationVisible(annotationUID: string): boolean | undefined {\n  const annotation = getAnnotation(annotationUID);\n\n  if (annotation) {\n    return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n  }\n}\n/**\n * It decorates given annotation with isVisible property.\n * It properly initializes the isVisible on annotation(the property will be create if does not exist yet)\n *\n * @param annotation - The annotation object to be checked.\n */\nfunction checkAndDefineIsVisibleProperty(annotation: Annotation): void {\n  if (annotation) {\n    const isVisible = annotation.isVisible ?? true;\n    if (shouldDefineIsVisibleProperty(annotation)) {\n      Object.defineProperty(annotation, 'isVisible', {\n        configurable: false,\n        enumerable: true,\n        set: setIsVisible,\n        get: getIsVisible,\n      });\n    }\n    setAnnotationVisibility(annotation.annotationUID, isVisible);\n  }\n}\n\n/*\n * Private Helpers\n */\nfunction makeEventDetail(): AnnotationVisibilityChangeEventDetail {\n  return Object.freeze({\n    lastVisible: [],\n    lastHidden: [],\n    hidden: [],\n  });\n}\n\nfunction show(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (annotationUIDsSet.delete(annotationUID)) {\n    detail.lastVisible.push(annotationUID);\n  }\n}\n\nfunction hide(\n  annotationUID: string,\n  annotationUIDsSet: Set<string>,\n  detail: AnnotationVisibilityChangeEventDetail\n): void {\n  if (!annotationUIDsSet.has(annotationUID)) {\n    annotationUIDsSet.add(annotationUID);\n    if (isAnnotationSelected(annotationUID)) {\n      deselectAnnotation(annotationUID);\n    }\n    detail.lastHidden.push(annotationUID);\n  }\n}\n\nfunction publish(detail: AnnotationVisibilityChangeEventDetail) {\n  if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n    globalHiddenAnnotationUIDsSet.forEach(\n      (item) => void detail.hidden.push(item)\n    );\n    triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n  }\n}\n\nfunction shouldDefineIsVisibleProperty(annotation: Annotation): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(annotation, 'isVisible');\n  if (descriptor) {\n    return (\n      descriptor.configurable &&\n      (descriptor.set !== setIsVisible || descriptor.get !== getIsVisible)\n    );\n  }\n  return Object.isExtensible(annotation);\n}\n\nfunction setIsVisible(hidden: boolean) {\n  setAnnotationVisibility((this as Annotation).annotationUID, hidden);\n}\n\nfunction getIsVisible() {\n  return isAnnotationVisible((this as Annotation).annotationUID);\n}\n\nexport {\n  setAnnotationVisibility,\n  showAllAnnotations,\n  isAnnotationVisible,\n  checkAndDefineIsVisibleProperty,\n};\n","import cloneDeep from 'lodash.clonedeep';\nimport {\n  Annotation,\n  Annotations,\n  AnnotationState,\n  GroupSpecificAnnotations,\n} from '../../types/AnnotationTypes';\n\nimport { AnnotationGroupSelector, IAnnotationManager } from '../../types';\n\nimport {\n  Enums,\n  eventTarget,\n  getEnabledElement,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport { checkAndDefineIsLockedProperty } from './annotationLocking';\nimport { checkAndDefineIsVisibleProperty } from './annotationVisibility';\n\n/**\n * This is the default annotation manager. It stores annotations by default\n * based on the FrameOfReferenceUID. However, it is possible to override the\n * getAnnotationStateKey function to store annotations based on any other\n * property of the element. When you write your custom annotation manager, you\n * can use the setAnnotationManager function to set your custom annotation.\n *\n * Note that this class is a singleton and should not be instantiated directly.\n * To get the stored annotations information you can use ToolState helpers.\n */\nclass FrameOfReferenceSpecificAnnotationManager implements IAnnotationManager {\n  private annotations: AnnotationState;\n  public readonly uid: string;\n\n  /**\n   * @param uid - The uid of the state manager. If omitted it is autogenerated.\n   */\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = utilities.uuidv4();\n    }\n    this.annotations = {};\n    this.uid = uid;\n\n    // Listen to the IMAGE_VOLUME_MODIFIED event to invalidate data.\n    eventTarget.addEventListener(\n      Enums.Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedHandler\n    );\n  }\n\n  /**\n   * Default annotation manager works with FrameOfReferenceUID as the key. The\n   * manager adds them under the FrameOfReferenceUID for the element being\n   * annotated.\n   *\n   * @param annotationGroupSelector - element or a string that is provided\n   * to the annotation manager to get the key.\n   * @returns - The annotation state key for the element.\n   */\n  getGroupKey = (annotationGroupSelector: AnnotationGroupSelector): string => {\n    if (typeof annotationGroupSelector === 'string') {\n      return annotationGroupSelector;\n    }\n\n    const element = annotationGroupSelector;\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      throw new Error(\n        'Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID'\n      );\n    }\n\n    return enabledElement.FrameOfReferenceUID;\n  };\n\n  /**\n   * When a volume is modified we invalidate all of the `annotations` on the\n   * volume's `FrameOfReferenceUID`. This is mainly to update statistics calculations\n   * when an annotation is drawn whilst data is still loading.\n   *\n   * @param evt - The IMAGE_VOLUME_MODIFIED rendering event.\n   */\n  _imageVolumeModifiedHandler = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const eventDetail = evt.detail;\n    const { FrameOfReferenceUID } = eventDetail;\n\n    const annotations = this.annotations;\n    const frameOfReferenceSpecificAnnotations =\n      annotations[FrameOfReferenceUID];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      return;\n    }\n\n    Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      toolSpecificAnnotations.forEach((annotation) => {\n        const invalidated = annotation.invalidated;\n\n        if (invalidated !== undefined) {\n          annotation.invalidated = true;\n        }\n      });\n    });\n  };\n\n  /**\n   * Returns all the available frameOfReferences inside the state manager\n   * @returns - All the added frames of references inside the manager\n   */\n  getFramesOfReference = (): Array<string> => {\n    return Object.keys(this.annotations);\n  };\n\n  /**\n   * Returns the annotations associated with the specified frameOfReference and tool, or\n   * all annotations for the group if the tool name is not provided.\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns The annotations associated with the specified group (default FrameOfReferenceUID) and tool,\n   * or all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   */\n  getAnnotations = (\n    groupKey: string,\n    toolName?: string\n  ): GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (!annotations[groupKey]) {\n      return [];\n    }\n\n    if (toolName) {\n      return annotations[groupKey][toolName];\n    }\n\n    return annotations[groupKey];\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, returns the `annotation`\n   * from the `annotations`. Each `annotation` has a unique identifier.\n   *\n   * @param annotationUID - The unique identifier of the `annotation`.\n   * @returns The retrieved `annotation`.\n   */\n  getAnnotation = (annotationUID: string): Annotation | undefined => {\n    const annotations = this.annotations;\n\n    for (const frameOfReferenceUID in annotations) {\n      const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n\n      for (const toolName in frameOfReferenceAnnotations) {\n        const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n\n        for (const annotation of toolSpecificAnnotations) {\n          if (annotationUID === annotation.annotationUID) {\n            return annotation;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * A function that returns the number of annotations for a given tool in the\n   * specific group (default FrameOfReferenceUID) IF no groupKey (FrameOfReferenceUID) is provided,\n   * it will return the number of annotations for the tool in all groups (FrameOfReferenceUIDs)\n   *\n   * @param groupKey - The annotation group key to retrieve annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - The name of the tool to retrieve data for.\n   *\n   * @returns The number of annotations for a given tool in the state\n   */\n  getNumberOfAnnotations = (groupKey: string, toolName?: string): number => {\n    const annotations = this.getAnnotations(groupKey, toolName);\n\n    if (!annotations.length) {\n      return 0;\n    }\n\n    if (toolName) {\n      return (annotations as Annotations).length;\n    }\n\n    let total = 0;\n\n    for (const toolName in annotations) {\n      total += annotations[toolName].length;\n    }\n\n    return total;\n  };\n\n  /**\n   * Adds an instance of `Annotation` to the `annotations`.\n   *\n   * @param annotation - The annotation to add.\n   * @param groupKey - The annotation group key to add the annotation to (in default manager it is FrameOfReferenceUID).\n   */\n  addAnnotation = (annotation: Annotation, groupKey?: string): void => {\n    const { metadata } = annotation;\n    const { FrameOfReferenceUID, toolName } = metadata;\n\n    groupKey = groupKey || FrameOfReferenceUID;\n\n    const annotations = this.annotations;\n\n    let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n    if (!frameOfReferenceSpecificAnnotations) {\n      annotations[groupKey] = {};\n\n      frameOfReferenceSpecificAnnotations = annotations[groupKey];\n    }\n\n    let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n\n    if (!toolSpecificAnnotations) {\n      frameOfReferenceSpecificAnnotations[toolName] = [];\n\n      toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n    }\n\n    toolSpecificAnnotations.push(annotation);\n    checkAndDefineIsLockedProperty(annotation);\n    checkAndDefineIsVisibleProperty(annotation);\n  };\n\n  /**\n   * Given the unique identified for the some `annotation`, removes the `annotation`\n   * from the `annotations`.\n   *\n   * @param annotationUID - The unique identifier of the `annotation` to remove.\n   */\n  removeAnnotation = (annotationUID: string): void => {\n    const { annotations } = this;\n\n    for (const groupKey in annotations) {\n      const groupAnnotations = annotations[groupKey];\n\n      for (const toolName in groupAnnotations) {\n        const toolAnnotations = groupAnnotations[toolName];\n\n        const index = toolAnnotations.findIndex(\n          (annotation) => annotation.annotationUID === annotationUID\n        );\n\n        if (index !== -1) {\n          toolAnnotations.splice(index, 1);\n\n          if (toolAnnotations.length === 0) {\n            delete groupAnnotations[toolName];\n          }\n        }\n      }\n\n      if (Object.keys(groupAnnotations).length === 0) {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Removes all annotations associated with the specified group (FrameOfReferenceUID) and tool, or\n   * all annotations for the group (FrameOfReferenceUID) if the tool name is not provided.\n   *\n   * @param groupKey - The group key to remove annotations for (in default manager it is FrameOfReferenceUID).\n   * @param toolName - Optional. The name of the tool to remove annotations for.\n   */\n  removeAnnotations = (groupKey: string, toolName?: string): void => {\n    const annotations = this.annotations;\n    if (annotations[groupKey]) {\n      if (toolName) {\n        delete annotations[groupKey][toolName];\n      } else {\n        delete annotations[groupKey];\n      }\n    }\n  };\n\n  /**\n   * Returns a section of the annotations. Useful for serialization.\n   * If both groupKey (default manager is FrameOfReferenceUID) and toolName are provided, returns the corresponding Annotations instance\n   * for that groupKey (FrameOfReferenceUID) and toolName.\n   * If only groupKey is provided, returns the corresponding FrameOfReferenceSpecificAnnotations instance\n   * for that groupKey.\n   * If neither groupKey nor toolName is provided, returns the entire AnnotationState object.\n   * @param groupKey - Optional. The group key (e.g. FrameOfReferenceUID) to retrieve annotations for.\n   * @param toolName - Optional. The name of the tool to retrieve annotations for.\n   * @returns A section of the annotations.\n   */\n  saveAnnotations = (\n    groupKey?: string,\n    toolName?: string\n  ): AnnotationState | GroupSpecificAnnotations | Annotations => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        return;\n      }\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[toolName];\n\n      return cloneDeep(toolSpecificAnnotations);\n    } else if (groupKey) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      return cloneDeep(frameOfReferenceSpecificAnnotations);\n    }\n\n    return cloneDeep(annotations);\n  };\n\n  /**\n   * Restores a section of the `annotations`. Useful for loading in serialized data.\n   *\n   * - If no arguments are given, the entire `AnnotationState` instance is restored.\n   * - If the `FrameOfReferenceUID` is given, the corresponding\n   * `FrameOfReferenceSpecificAnnotations` instance is restored.\n   * - If both the `FrameOfReferenceUID` and the `toolName` are are given, the\n   * corresponding `Annotations` instance is restored.\n   *\n   * @param groupKey - A filter string for restoring only the `annotations` of a specific frame of reference.\n   * @param toolName - A filter string for restoring `annotation` for a specific tool on a specific frame of reference.\n   */\n  restoreAnnotations = (\n    state: AnnotationState | GroupSpecificAnnotations | Annotations,\n    groupKey?: string,\n    toolName?: string\n  ): void => {\n    const annotations = this.annotations;\n\n    if (groupKey && toolName) {\n      // Set Annotations for FrameOfReferenceUID and toolName.\n\n      let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n\n      if (!frameOfReferenceSpecificAnnotations) {\n        annotations[groupKey] = {};\n\n        frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      }\n\n      frameOfReferenceSpecificAnnotations[toolName] = <Annotations>state;\n    } else if (groupKey) {\n      // Set FrameOfReferenceSpecificAnnotations for FrameOfReferenceUID.\n\n      annotations[groupKey] = <GroupSpecificAnnotations>state;\n    } else {\n      // Set entire annotations\n      this.annotations = <AnnotationState>cloneDeep(state);\n    }\n  };\n\n  /**\n   * A function that returns the number of all annotations in the annotation state\n   *\n   * @returns The number of all annotations in the state\n   */\n  getNumberOfAllAnnotations = (): number => {\n    let count = 0;\n    const annotations = this.annotations;\n    for (const groupKey in annotations) {\n      const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n      for (const toolName in frameOfReferenceSpecificAnnotations) {\n        const toolSpecificAnnotations =\n          frameOfReferenceSpecificAnnotations[toolName];\n        count += toolSpecificAnnotations.length;\n      }\n    }\n    return count;\n  };\n\n  /**\n   * Removes all annotations in the annotation state.\n   */\n  removeAllAnnotations = (): void => {\n    this.annotations = {};\n  };\n}\n\nconst defaultFrameOfReferenceSpecificAnnotationManager =\n  new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\n\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","let svgNodeCache = {};\n\nexport function resetSvgNodeCache(): void {\n  svgNodeCache = {};\n}\n\nexport default svgNodeCache;\n","import _cloneDeep from 'lodash.clonedeep';\n\nimport { IToolGroup, IToolClassReference } from '../types';\nimport Synchronizer from './SynchronizerManager/Synchronizer';\nimport svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\n\ninterface ICornerstoneTools3dState {\n  isInteractingWithTool: boolean;\n  isMultiPartToolActive: boolean;\n  tools: Record<\n    string,\n    {\n      toolClass: IToolClassReference;\n    }\n  >;\n  toolGroups: Array<IToolGroup>;\n  synchronizers: Array<Synchronizer>;\n  svgNodeCache: Record<string, unknown>;\n  enabledElements: Array<unknown>;\n  handleRadius: number;\n}\n\nconst defaultState: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nlet state: ICornerstoneTools3dState = {\n  isInteractingWithTool: false,\n  isMultiPartToolActive: false,\n  tools: {},\n  toolGroups: [],\n  synchronizers: [],\n  svgNodeCache: svgNodeCache,\n  // Should this be named... canvases?\n  enabledElements: [], // switch to Uids?\n  handleRadius: 6,\n};\n\nfunction resetCornerstoneToolsState(): void {\n  resetSvgNodeCache();\n  state = _cloneDeep(defaultState);\n}\n\nexport {\n  ICornerstoneTools3dState,\n  resetCornerstoneToolsState,\n  state,\n  state as default,\n};\n","/**\n * ToolModes - This enum defines the 4 tool states which are available.\n */\nenum ToolModes {\n  /**\n   * Active:\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Active = 'Active',\n  /**\n   * Passive:\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Passive = 'Passive',\n  /**\n   * Enabled:\n   * - Renders data if the tool has a `renderAnnotation` method.\n   */\n  Enabled = 'Enabled',\n  /**\n   * Disabled:\n   * - Annotation does not render.\n   */\n  Disabled = 'Disabled',\n}\n\nexport default ToolModes;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\nimport { ToolModes } from '../../enums';\n\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\n\n/**\n * Returns the toolGroups that has the given toolName as active, passive\n * or enabled.\n * @param toolName - The name of the tool\n * @returns An array of tool groups.\n */\nfunction getToolGroupsWithToolName(toolName: string): IToolGroup[] | [] {\n  return state.toolGroups.filter(({ toolOptions }) => {\n    const toolGroupToolNames = Object.keys(toolOptions);\n\n    for (let i = 0; i < toolGroupToolNames.length; i++) {\n      if (toolName !== toolGroupToolNames[i]) {\n        continue;\n      }\n\n      /* filter out tools that don't have options */\n      if (!toolOptions[toolName]) {\n        continue;\n      }\n\n      if (MODES.includes(toolOptions[toolName].mode)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport default getToolGroupsWithToolName;\n","import {\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { Annotations, Annotation } from '../../types/AnnotationTypes';\nimport { AnnotationRemovedEventDetail } from '../../types/EventTypes';\nimport { AnnotationGroupSelector } from '../../types';\nimport {\n  triggerAnnotationAddedForElement,\n  triggerAnnotationAddedForFOR,\n} from './helpers/state';\n\n// our default annotation manager\nlet defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n\n/**\n * It returns the default annotations manager.\n * @returns the singleton default annotations manager.\n */\nfunction getAnnotationManager() {\n  return defaultManager;\n}\n\n/**\n * Set the annotation manager to be used for rendering, adding, removing, etc.\n * @param annotationManager - The annotation manager to be used\n */\nfunction setAnnotationManager(annotationManager) {\n  defaultManager = annotationManager;\n}\n\n// set back to default frameOfReferenceSpecificAnnotationManager\nfunction resetAnnotationManager() {\n  defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\n}\n\n/**\n * Returns the annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getAnnotations function will return the annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n * @returns The annotations corresponding to the Frame of Reference and the toolName.\n */\nfunction getAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): Annotations {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n  return manager.getAnnotations(groupKey, toolName) as Annotations;\n}\n\n/**\n * Add the annotation to the annotation manager along with the options that is\n * used to filter the annotation manager and the annotation group that\n * the annotation belongs to.\n *\n * As a result, our default implementation will add the annotation to the\n * default manager using the FrameOfReferenceUID as the group key.\n *\n * @param annotation - The annotation that is being added to the annotations manager.\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n */\nfunction addAnnotation(\n  annotation: Annotation,\n  annotationGroupSelector: AnnotationGroupSelector\n): string {\n  if (annotation.annotationUID === undefined) {\n    annotation.annotationUID = csUtils.uuidv4() as string;\n  }\n\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  manager.addAnnotation(annotation, groupKey);\n\n  // if the annotation manager selector is an element, trigger the\n  // annotation added event for that element.\n  if (annotationGroupSelector instanceof HTMLDivElement) {\n    triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n  } else {\n    // if no element is provided, render all viewports that have the\n    // same frame of reference.\n    // Todo: we should do something else here for other types of annotation managers.\n    triggerAnnotationAddedForFOR(annotation);\n  }\n\n  return annotation.annotationUID;\n}\n\n/**\n * Get the number of annotations for a given tool with the provided options that is\n * used to filter annotations based on the annotation manager.\n *\n * In our default implementation, the options are the element and/or the FrameOfReferenceUID.\n * Hence, the getNumberOfAnnotations function will return the number of annotations for the given tool\n * that are associated with the FrameOfReferenceUID.\n *\n * @param toolName - The name of the tool\n * @param annotationGroupSelector - element or FrameOfReferenceUID that is used\n * to group annotations in the annotation manager.\n *\n */\nfunction getNumberOfAnnotations(\n  toolName: string,\n  annotationGroupSelector: AnnotationGroupSelector\n): number {\n  const manager = getAnnotationManager();\n  const groupKey = manager.getGroupKey(annotationGroupSelector);\n\n  return manager.getNumberOfAnnotations(groupKey, toolName);\n}\n\n/**\n * Remove the annotation by UID of the annotation.\n * @param annotationUID - The unique identifier for the annotation.\n */\nfunction removeAnnotation(annotationUID: string): void {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  // no need to continue in case there is no annotation.\n  if (!annotation) {\n    return;\n  }\n\n  manager.removeAnnotation(annotationUID);\n\n  // trigger annotation removed\n  const eventType = Events.ANNOTATION_REMOVED;\n\n  const eventDetail: AnnotationRemovedEventDetail = {\n    annotation,\n    annotationManagerUID: manager.uid,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * Get the Annotation object by its UID\n * @param annotationUID - The unique identifier of the annotation.\n */\nfunction getAnnotation(annotationUID: string): Annotation {\n  const manager = getAnnotationManager();\n  const annotation = manager.getAnnotation(annotationUID);\n\n  return annotation;\n}\n\n/**\n * It removes all annotations from the default annotation manager\n */\nfunction removeAllAnnotations(): void {\n  const manager = getAnnotationManager();\n  manager.removeAllAnnotations();\n}\n\nexport {\n  getAnnotations,\n  getNumberOfAnnotations,\n  addAnnotation,\n  getAnnotation,\n  removeAnnotation,\n  removeAllAnnotations,\n  // annotation manager\n  setAnnotationManager,\n  getAnnotationManager,\n  resetAnnotationManager,\n};\n","import {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { Annotation } from '../../../types/AnnotationTypes';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nimport { AnnotationAddedEventDetail } from '../../../types/EventTypes';\n\n/**\n * It triggers an event for the element when an annotation is added\n * @param annotation - Annotation - The annotation that was added.\n * @param element - The element that the annotation was added to.\n */\nfunction triggerAnnotationAddedForElement(\n  annotation: Annotation,\n  element: HTMLDivElement\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewportId } = enabledElement;\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  const eventDetail: AnnotationAddedEventDetail = {\n    annotation,\n    viewportId,\n    renderingEngineId: renderingEngine.id,\n  };\n\n  triggerEvent(eventTarget, eventType, eventDetail);\n}\n\n/**\n * If the annotation has a FrameOfReferenceUID, it triggers the ANNOTATION_ADDED\n * event for all the viewports that has the same FrameOfReferenceUID.\n * @param annotation -  Annotation - The annotation that was added\n */\nfunction triggerAnnotationAddedForFOR(annotation: Annotation) {\n  const { toolName } = annotation.metadata;\n\n  const toolGroups = getToolGroupsWithToolName(toolName);\n\n  if (!toolGroups.length) {\n    return;\n  }\n\n  // Find the viewports in the toolGroups who has the same FrameOfReferenceUID\n  const viewportsToRender = [];\n\n  toolGroups.forEach((toolGroup) => {\n    toolGroup.viewportsInfo.forEach((viewportInfo) => {\n      const { renderingEngineId, viewportId } = viewportInfo;\n      const { FrameOfReferenceUID } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n        viewportsToRender.push(viewportInfo);\n      }\n    });\n  });\n\n  if (!viewportsToRender.length) {\n    return;\n  }\n\n  const eventType = Events.ANNOTATION_ADDED;\n\n  viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n    const eventDetail: AnnotationAddedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  });\n}\n\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR };\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/**\n * Cornerstone Color LUT used for Segmentations\n */\nconst CORNERSTONE_COLOR_LUT = [\n  [0, 0, 0, 0],\n  [221, 84, 84, 255],\n  [77, 228, 121, 255],\n  [166, 70, 235, 255],\n  [189, 180, 116, 255],\n  [109, 182, 196, 255],\n  [204, 101, 157, 255],\n  [123, 211, 94, 255],\n  [93, 87, 218, 255],\n  [225, 128, 80, 255],\n  [73, 232, 172, 255],\n  [181, 119, 186, 255],\n  [176, 193, 112, 255],\n  [105, 153, 200, 255],\n  [208, 97, 120, 255],\n  [90, 215, 101, 255],\n  [135, 83, 222, 255],\n  [229, 178, 76, 255],\n  [122, 183, 181, 255],\n  [190, 115, 171, 255],\n  [149, 197, 108, 255],\n  [100, 118, 205, 255],\n  [212, 108, 93, 255],\n  [86, 219, 141, 255],\n  [183, 79, 226, 255],\n  [233, 233, 72, 255],\n  [118, 167, 187, 255],\n  [194, 111, 146, 255],\n  [116, 201, 104, 255],\n  [115, 96, 209, 255],\n  [216, 147, 89, 255],\n  [82, 223, 188, 255],\n  [230, 75, 224, 255],\n  [163, 184, 121, 255],\n  [114, 143, 191, 255],\n  [198, 107, 114, 255],\n  [99, 206, 122, 255],\n  [153, 92, 213, 255],\n  [220, 192, 85, 255],\n  [78, 215, 227, 255],\n  [234, 71, 173, 255],\n  [141, 188, 117, 255],\n  [110, 113, 195, 255],\n  [202, 128, 103, 255],\n  [95, 210, 157, 255],\n  [195, 88, 217, 255],\n  [206, 224, 81, 255],\n  [74, 166, 231, 255],\n  [185, 120, 139, 255],\n  [113, 192, 113, 255],\n  [133, 106, 199, 255],\n  [207, 162, 98, 255],\n  [91, 214, 198, 255],\n  [221, 84, 198, 255],\n  [159, 228, 77, 255],\n  [70, 111, 235, 255],\n  [189, 119, 116, 255],\n  [109, 196, 138, 255],\n  [165, 101, 204, 255],\n  [211, 201, 94, 255],\n  [87, 191, 218, 255],\n  [225, 80, 153, 255],\n  [106, 232, 73, 255],\n  [124, 119, 186, 255],\n  [193, 142, 112, 255],\n  [105, 200, 168, 255],\n  [203, 97, 208, 255],\n  [184, 215, 90, 255],\n  [83, 147, 222, 255],\n  [229, 76, 101, 255],\n  [122, 183, 130, 255],\n  [146, 115, 190, 255],\n  [197, 171, 108, 255],\n  [100, 205, 205, 255],\n  [212, 93, 177, 255],\n  [141, 219, 86, 255],\n  [79, 97, 226, 255],\n  [233, 99, 72, 255],\n  [118, 187, 150, 255],\n  [173, 111, 194, 255],\n  [197, 201, 104, 255],\n  [96, 171, 209, 255],\n  [216, 89, 137, 255],\n  [94, 223, 82, 255],\n  [107, 75, 230, 255],\n  [184, 153, 121, 255],\n  [114, 191, 175, 255],\n  [198, 107, 191, 255],\n  [166, 206, 99, 255],\n  [92, 132, 213, 255],\n  [220, 85, 91, 255],\n  [78, 227, 115, 255],\n  [159, 71, 234, 255],\n  [188, 176, 117, 255],\n  [110, 185, 195, 255],\n  [202, 103, 161, 255],\n  [129, 210, 95, 255],\n  [88, 88, 217, 255],\n  [224, 123, 81, 255],\n  [74, 231, 166, 255],\n  [177, 120, 185, 255],\n  [179, 192, 113, 255],\n  [106, 156, 199, 255],\n  [207, 98, 125, 255],\n  [91, 214, 96, 255],\n  [130, 84, 221, 255],\n  [228, 171, 77, 255],\n  [70, 235, 221, 255],\n  [189, 116, 174, 255],\n  [153, 196, 109, 255],\n  [101, 123, 204, 255],\n  [211, 104, 94, 255],\n  [87, 218, 136, 255],\n  [177, 80, 225, 255],\n  [232, 225, 73, 255],\n  [119, 169, 186, 255],\n  [193, 112, 149, 255],\n  [121, 200, 105, 255],\n  [111, 97, 208, 255],\n  [215, 142, 90, 255],\n  [83, 222, 181, 255],\n  [229, 76, 229, 255],\n  [165, 183, 122, 255],\n  [115, 146, 190, 255],\n  [197, 108, 119, 255],\n  [100, 205, 118, 255],\n  [148, 93, 212, 255],\n  [219, 186, 86, 255],\n  [79, 220, 226, 255],\n  [233, 72, 179, 255],\n  [144, 187, 118, 255],\n  [111, 118, 194, 255],\n  [201, 124, 104, 255],\n  [96, 209, 153, 255],\n  [189, 89, 216, 255],\n  [211, 223, 82, 255],\n  [75, 172, 230, 255],\n  [184, 121, 142, 255],\n  [117, 191, 114, 255],\n  [130, 107, 198, 255],\n  [206, 157, 99, 255],\n  [92, 213, 193, 255],\n  [220, 85, 203, 255],\n  [165, 227, 78, 255],\n  [71, 118, 234, 255],\n  [188, 117, 117, 255],\n  [110, 195, 135, 255],\n  [161, 103, 202, 255],\n  [210, 195, 95, 255],\n  [88, 195, 217, 255],\n  [224, 81, 158, 255],\n  [113, 231, 74, 255],\n  [123, 120, 185, 255],\n  [192, 139, 113, 255],\n  [106, 199, 164, 255],\n  [198, 98, 207, 255],\n  [188, 214, 91, 255],\n  [84, 153, 221, 255],\n  [228, 77, 108, 255],\n  [70, 235, 84, 255],\n  [143, 116, 189, 255],\n  [196, 167, 109, 255],\n  [101, 204, 199, 255],\n  [211, 94, 182, 255],\n  [147, 218, 87, 255],\n  [80, 104, 225, 255],\n  [232, 93, 73, 255],\n  [119, 186, 147, 255],\n  [170, 112, 193, 255],\n  [200, 200, 105, 255],\n  [97, 175, 208, 255],\n  [215, 90, 142, 255],\n  [100, 222, 83, 255],\n  [101, 76, 229, 255],\n  [183, 150, 122, 255],\n  [115, 190, 171, 255],\n  [197, 108, 194, 255],\n  [170, 205, 100, 255],\n  [93, 138, 212, 255],\n  [219, 86, 97, 255],\n  [79, 226, 110, 255],\n  [153, 72, 233, 255],\n  [187, 173, 118, 255],\n  [111, 187, 194, 255],\n  [201, 104, 165, 255],\n  [134, 209, 96, 255],\n  [89, 95, 216, 255],\n  [223, 117, 82, 255],\n  [75, 230, 159, 255],\n  [174, 121, 184, 255],\n  [182, 191, 114, 255],\n  [107, 160, 198, 255],\n  [206, 99, 130, 255],\n  [92, 213, 92, 255],\n  [124, 85, 220, 255],\n  [227, 165, 78, 255],\n  [71, 234, 214, 255],\n  [188, 117, 176, 255],\n  [156, 195, 110, 255],\n  [103, 128, 202, 255],\n  [210, 100, 95, 255],\n  [88, 217, 131, 255],\n  [170, 81, 224, 255],\n  [231, 218, 74, 255],\n  [120, 172, 185, 255],\n  [192, 113, 153, 255],\n  [125, 199, 106, 255],\n  [107, 98, 207, 255],\n  [214, 137, 91, 255],\n  [84, 221, 175, 255],\n  [222, 77, 228, 255],\n  [194, 235, 70, 255],\n  [116, 149, 189, 255],\n  [196, 109, 123, 255],\n  [101, 204, 114, 255],\n  [143, 94, 211, 255],\n  [218, 180, 87, 255],\n  [80, 225, 225, 255],\n  [232, 73, 186, 255],\n  [147, 186, 119, 255],\n  [112, 122, 193, 255],\n  [200, 121, 105, 255],\n  [97, 208, 148, 255],\n  [184, 90, 215, 255],\n  [216, 222, 83, 255],\n  [76, 178, 229, 255],\n  [183, 122, 145, 255],\n  [121, 190, 115, 255],\n  [126, 108, 197, 255],\n  [205, 153, 100, 255],\n  [93, 212, 187, 255],\n  [219, 86, 208, 255],\n  [171, 226, 79, 255],\n  [72, 126, 233, 255],\n  [187, 118, 121, 255],\n  [111, 194, 132, 255],\n  [157, 104, 201, 255],\n  [209, 190, 96, 255],\n  [89, 200, 216, 255],\n  [223, 82, 164, 255],\n  [120, 230, 75, 255],\n  [121, 121, 184, 255],\n  [191, 136, 114, 255],\n  [107, 198, 160, 255],\n  [192, 99, 206, 255],\n  [193, 213, 92, 255],\n  [85, 158, 220, 255],\n  [227, 78, 115, 255],\n  [71, 234, 78, 255],\n  [141, 117, 188, 255],\n  [195, 163, 110, 255],\n  [103, 202, 194, 255],\n  [210, 95, 186, 255],\n  [153, 217, 88, 255],\n  [81, 111, 224, 255],\n];\n\nexport default CORNERSTONE_COLOR_LUT;\n","/**\n * Segmentations on viewports can be visualized in different ways. This enum\n * defines the different ways of visualizing segmentations. Currently, only\n * labelmap is supported.\n */\nenum SegmentationRepresentations {\n  Labelmap = 'LABELMAP',\n  Contour = 'CONTOUR',\n  Surface = 'SURFACE',\n}\n\nexport default SegmentationRepresentations;\n","import { ContourConfig } from '../../../types/ContourTypes';\n\nconst defaultContourConfig: ContourConfig = {\n  renderOutline: true,\n  outlineWidthActive: 2,\n  outlineWidthInactive: 2,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n  renderFill: true,\n  fillAlpha: 1,\n  fillAlphaInactive: 0,\n};\n\nfunction getDefaultContourConfig(): ContourConfig {\n  return defaultContourConfig;\n}\n\nexport default getDefaultContourConfig;\n","import { LabelmapConfig } from '../../../types/LabelmapTypes';\n\nconst defaultLabelmapConfig: LabelmapConfig = {\n  renderOutline: true,\n  outlineWidthActive: 3,\n  outlineWidthInactive: 2,\n  renderFill: true,\n  renderFillInactive: true,\n  fillAlpha: 0.7,\n  fillAlphaInactive: 0.65,\n  outlineOpacity: 1,\n  outlineOpacityInactive: 0.85,\n};\n\nfunction getDefaultLabelmapConfig(): LabelmapConfig {\n  return defaultLabelmapConfig;\n}\n\n// Checks if the labelmap config is valid, which means\n// if all the required fields are present and have the correct type\nfunction isValidLabelmapConfig(config): boolean {\n  return (\n    config &&\n    typeof config.renderOutline === 'boolean' &&\n    typeof config.outlineWidthActive === 'number' &&\n    typeof config.outlineWidthInactive === 'number' &&\n    typeof config.renderFill === 'boolean' &&\n    typeof config.renderFillInactive === 'boolean' &&\n    typeof config.fillAlpha === 'number' &&\n    typeof config.fillAlphaInactive === 'number' &&\n    typeof config.outlineOpacity === 'number' &&\n    typeof config.outlineOpacityInactive === 'number'\n  );\n}\n\nexport default getDefaultLabelmapConfig;\nexport { isValidLabelmapConfig };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport cloneDeep from 'lodash.clonedeep';\n\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\n\nimport { SegmentationRepresentations } from '../../enums';\nimport getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport type {\n  ColorLUT,\n  RepresentationConfig,\n  Segmentation,\n  SegmentationRepresentationConfig,\n  SegmentationState,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\n\n// Initialize the default configuration\n// Note: when we get other representations, we should set their default representations too.\nconst defaultLabelmapConfig = getDefaultLabelmapConfig();\nconst defaultContourConfig = getDefaultContourConfig();\n\nconst newGlobalConfig: SegmentationRepresentationConfig = {\n  renderInactiveSegmentations: true,\n  representations: {\n    [SegmentationRepresentations.Labelmap]: defaultLabelmapConfig,\n    [SegmentationRepresentations.Contour]: defaultContourConfig,\n  },\n};\n\n/* A default initial state for the segmentation manager. */\nconst initialDefaultState: SegmentationState = {\n  colorLUT: [],\n  segmentations: [],\n  globalConfig: newGlobalConfig,\n  toolGroups: {},\n};\n\n/**\n * The SegmentationStateManager Class is responsible for managing the state of the\n * segmentations. It stores the segmentations and toolGroup specific representations\n * of the segmentation. It also stores a global config and a toolGroup specific\n * config. Note that this is a singleton state manager.\n */\nexport default class SegmentationStateManager {\n  private state: SegmentationState;\n  public readonly uid: string;\n\n  constructor(uid?: string) {\n    if (!uid) {\n      uid = csUtils.uuidv4();\n    }\n    this.state = cloneDeep(initialDefaultState);\n    this.uid = uid;\n  }\n\n  /**\n   * It returns a copy of the current state of the segmentation\n   * @returns A deep copy of the state.\n   */\n  getState(): SegmentationState {\n    return this.state;\n  }\n\n  /**\n   * It returns an array of toolGroupIds currently in the segmentation state.\n   * @returns An array of strings.\n   */\n  getToolGroups(): string[] {\n    return Object.keys(this.state.toolGroups);\n  }\n\n  /**\n   * It returns the colorLUT at the specified index.\n   * @param lutIndex - The index of the color LUT to retrieve.\n   * @returns A ColorLUT object.\n   */\n  getColorLUT(lutIndex: number): ColorLUT | undefined {\n    return this.state.colorLUT[lutIndex];\n  }\n\n  /**\n   * Reset the state to the default state\n   */\n  resetState(): void {\n    this.state = cloneDeep(initialDefaultState);\n  }\n\n  /**\n   * Given a segmentation Id, return the segmentation state\n   * @param segmentationId - The id of the segmentation to get the data for.\n   * @returns - The segmentation data\n   */\n  getSegmentation(segmentationId: string): Segmentation | undefined {\n    return this.state.segmentations.find(\n      (segmentation) => segmentation.segmentationId === segmentationId\n    );\n  }\n\n  /**\n   * It adds a segmentation to the segmentations array.\n   * @param segmentation - Segmentation\n   */\n  addSegmentation(segmentation: Segmentation): void {\n    this._initDefaultColorLUTIfNecessary();\n\n    // Check if the segmentation already exists with the segmentationId\n    if (this.getSegmentation(segmentation.segmentationId)) {\n      throw new Error(\n        `Segmentation with id ${segmentation.segmentationId} already exists`\n      );\n    }\n\n    this.state.segmentations.push(segmentation);\n  }\n\n  /**\n   * Get the segmentation representations for a tool group\n   * @param toolGroupId - string\n   * @returns A list of segmentation representations.\n   */\n  getSegmentationRepresentations(\n    toolGroupId: string\n  ): ToolGroupSpecificRepresentations | undefined {\n    const toolGroupSegRepresentationsWithConfig =\n      this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupSegRepresentationsWithConfig) {\n      return;\n    }\n\n    return toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n  }\n\n  /**\n   * Returns an array of all segmentation representations for all tool groups.\n   * @returns An array of ToolGroupSpecificRepresentations.\n   */\n  getAllSegmentationRepresentations(): Record<\n    string,\n    ToolGroupSpecificRepresentation[]\n  > {\n    const toolGroupSegReps: Record<string, ToolGroupSpecificRepresentation[]> =\n      {};\n    Object.entries(this.state.toolGroups).forEach(\n      ([toolGroupId, toolGroupSegRepresentationsWithConfig]) => {\n        toolGroupSegReps[toolGroupId] =\n          toolGroupSegRepresentationsWithConfig.segmentationRepresentations;\n      }\n    );\n    return toolGroupSegReps;\n  }\n\n  /**\n   * Add a new segmentation representation to the toolGroup's segmentation representations.\n   * @param toolGroupId - The Id of the tool group .\n   * @param segmentationRepresentation - The segmentation representation to add.\n   */\n  addSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    // Initialize the default toolGroup state if not created yet\n    if (!this.state.toolGroups[toolGroupId]) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {} as SegmentationRepresentationConfig,\n      };\n    }\n\n    // local toolGroupSpecificSegmentationState\n    this.state.toolGroups[toolGroupId].segmentationRepresentations.push(\n      segmentationRepresentation\n    );\n\n    this._handleActiveSegmentation(toolGroupId, segmentationRepresentation);\n  }\n\n  /**\n   * Get the global config containing both representation config\n   * and render inactive segmentations config\n   * @returns The global config object.\n   */\n  getGlobalConfig(): SegmentationRepresentationConfig {\n    return this.state.globalConfig;\n  }\n\n  /**\n   * It sets the global segmentation config including both representation config\n   * and render inactive segmentations config\n   * @param config - The global configuration for the segmentations.\n   */\n  setGlobalConfig(config: SegmentationRepresentationConfig): void {\n    this.state.globalConfig = config;\n  }\n\n  /**\n   * Given a toolGroupId and a segmentationRepresentationUID, return the segmentation\n   * representation for that tool group.\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - string\n   * @returns The segmentation representation.\n   */\n  getSegmentationRepresentationByUID(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): ToolGroupSpecificRepresentation | undefined {\n    const toolGroupSegRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    const segmentationData = toolGroupSegRepresentations.find(\n      (representation) =>\n        representation.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    return segmentationData;\n  }\n\n  /**\n   * It removes the segmentation from the segmentation state.\n   * @param segmentationId - The id of the segmentation to remove.\n   */\n  removeSegmentation(segmentationId: string): void {\n    this.state.segmentations = this.state.segmentations.filter(\n      (segmentation) => segmentation.segmentationId !== segmentationId\n    );\n  }\n\n  /**\n   * Remove a segmentation representation from the toolGroup\n   * @param toolGroupId - The Id of the tool group\n   * @param segmentationRepresentationUID - the uid of the segmentation representation to remove\n   * @param immediate - If true, the viewport will be updated immediately.\n   */\n  removeSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      !toolGroupSegmentationRepresentations.length\n    ) {\n      throw new Error(\n        `No viewport specific segmentation state found for viewport ${toolGroupId}`\n      );\n    }\n\n    const state =\n      toolGroupSegmentationRepresentations as ToolGroupSpecificRepresentations;\n    const index = state.findIndex(\n      (segData) =>\n        segData.segmentationRepresentationUID === segmentationRepresentationUID\n    );\n\n    if (index === -1) {\n      console.warn(\n        `No viewport specific segmentation state data found for viewport ${toolGroupId} and segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    const removedSegmentationRepresentation =\n      toolGroupSegmentationRepresentations[index];\n\n    toolGroupSegmentationRepresentations.splice(index, 1);\n\n    this._handleActiveSegmentation(\n      toolGroupId,\n      removedSegmentationRepresentation\n    );\n  }\n\n  /**\n   * Set the active segmentation data for a tool group\n   * @param toolGroupId - The Id of the tool group that owns the\n   * segmentation data.\n   * @param segmentationRepresentationUID - string\n   */\n  setActiveSegmentationRepresentation(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): void {\n    const toolGroupSegmentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    if (!toolGroupSegmentations || !toolGroupSegmentations.length) {\n      throw new Error(\n        `No segmentation data found for toolGroupId: ${toolGroupId}`\n      );\n    }\n\n    const segmentationData = toolGroupSegmentations.find(\n      (segmentationData) =>\n        segmentationData.segmentationRepresentationUID ===\n        segmentationRepresentationUID\n    );\n\n    if (!segmentationData) {\n      throw new Error(\n        `No segmentation data found for segmentation data UID ${segmentationRepresentationUID}`\n      );\n    }\n\n    segmentationData.active = true;\n    this._handleActiveSegmentation(toolGroupId, segmentationData);\n  }\n\n  /**\n   * Given a tool group Id it returns the tool group specific representation config\n   *\n   * @param toolGroupId - The Id of the tool group\n   * @returns A SegmentationConfig object.\n   */\n  getToolGroupSpecificConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig | undefined {\n    const toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      return;\n    }\n\n    return toolGroupStateWithConfig.config;\n  }\n\n  getSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentationRepresentationSpecificConfig;\n  }\n\n  setSegmentationRepresentationSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: RepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentationRepresentationSpecificConfig =\n      config;\n  }\n\n  getSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    segmentIndex: number\n  ): RepresentationConfig {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    return segmentationRepresentation.segmentSpecificConfig[segmentIndex];\n  }\n\n  setSegmentSpecificConfig(\n    toolGroupId: string,\n    segmentationRepresentationUID: string,\n    config: SegmentSpecificRepresentationConfig\n  ): void {\n    const segmentationRepresentation = this.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n    if (!segmentationRepresentation) {\n      return;\n    }\n\n    segmentationRepresentation.segmentSpecificConfig = config;\n  }\n\n  /**\n   * Set the segmentation representations config for a given tool group. It will create a new\n   * tool group specific config if one does not exist.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation\n   * belongs to.\n   * @param config - SegmentationConfig\n   */\n  setSegmentationRepresentationConfig(\n    toolGroupId: string,\n    config: SegmentationRepresentationConfig\n  ): void {\n    let toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n\n    if (!toolGroupStateWithConfig) {\n      this.state.toolGroups[toolGroupId] = {\n        segmentationRepresentations: [],\n        config: {\n          renderInactiveSegmentations: true,\n          representations: {},\n        },\n      };\n\n      toolGroupStateWithConfig = this.state.toolGroups[toolGroupId];\n    }\n\n    toolGroupStateWithConfig.config = {\n      ...toolGroupStateWithConfig.config,\n      ...config,\n    };\n  }\n\n  /**\n   * It adds a color LUT to the state.\n   * @param colorLUT - ColorLUT\n   * @param lutIndex - The index of the color LUT table to add.\n   */\n  addColorLUT(colorLUT: ColorLUT, lutIndex: number): void {\n    if (this.state.colorLUT[lutIndex]) {\n      console.log('Color LUT table already exists, overwriting');\n    }\n\n    this.state.colorLUT[lutIndex] = colorLUT;\n  }\n\n  /**\n   * Removes a color LUT to the state.\n   * @param colorLUTIndex - The index of the color LUT table to remove.\n   */\n  removeColorLUT(colorLUTIndex: number): void {\n    delete this.state.colorLUT[colorLUTIndex];\n  }\n\n  /**\n   * It handles the active segmentation representation based on the active status of the\n   * segmentation representation that was added or removed.\n   *\n   * @param toolGroupId - The Id of the tool group that the segmentation representation belongs to.\n   * @param recentlyAddedOrRemovedSegmentationRepresentation - ToolGroupSpecificSegmentationData\n   */\n  _handleActiveSegmentation(\n    toolGroupId: string,\n    recentlyAddedOrRemovedSegmentationRepresentation: ToolGroupSpecificRepresentation\n  ): void {\n    const segmentationRepresentations =\n      this.getSegmentationRepresentations(toolGroupId);\n\n    // 1. If there is no segmentation representations, return early\n    if (segmentationRepresentations.length === 0) {\n      return;\n    }\n\n    // 2. If there is only one segmentation representation, make that one active\n    if (segmentationRepresentations.length === 1) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 3. If removed Segmentation representation was active, make the first one active\n    const activeSegmentationRepresentations =\n      segmentationRepresentations.filter(\n        (representation) => representation.active\n      );\n\n    if (activeSegmentationRepresentations.length === 0) {\n      segmentationRepresentations[0].active = true;\n      return;\n    }\n\n    // 4. If the added segmentation representation is active, make other segmentation\n    // representations inactive\n    if (recentlyAddedOrRemovedSegmentationRepresentation.active) {\n      segmentationRepresentations.forEach((representation) => {\n        if (\n          representation.segmentationRepresentationUID !==\n          recentlyAddedOrRemovedSegmentationRepresentation.segmentationRepresentationUID\n        ) {\n          representation.active = false;\n        }\n      });\n    }\n\n    // 5. if added/removed segmentation is is inactive, do nothing\n  }\n\n  _initDefaultColorLUTIfNecessary() {\n    // if colorLUTTable is not specified or the default one is not found\n    if (this.state.colorLUT.length === 0 || !this.state.colorLUT[0]) {\n      this.addColorLUT(CORNERSTONE_COLOR_LUT as ColorLUT, 0);\n    }\n  }\n}\n\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { defaultSegmentationStateManager };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\n\nimport { Events } from '../../enums';\nimport {\n  getSegmentationRepresentations,\n  getSegmentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport {\n  SegmentationRepresentationModifiedEventDetail,\n  SegmentationDataModifiedEventDetail,\n  SegmentationModifiedEventDetail,\n  SegmentationRepresentationRemovedEventDetail,\n  SegmentationRemovedEventDetail,\n} from '../../types/EventTypes';\n\n/**\n * Trigger an event that a segmentation is removed\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationRemoved(segmentationId: string): void {\n  const eventDetail: SegmentationRemovedEventDetail = {\n    segmentationId,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n\n/**\n * Trigger an event that a segmentation representation was removed\n * @param toolGroupId - The id of the tool group that the segmentation\n * representation was removed from.\n * @param segmentationRepresentationUID - The UID of the segmentation\n * representation that was removed.\n */\nfunction triggerSegmentationRepresentationRemoved(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const eventDetail: SegmentationRepresentationRemovedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  triggerEvent(\n    eventTarget,\n    Events.SEGMENTATION_REPRESENTATION_REMOVED,\n    eventDetail\n  );\n}\n\n/**\n * Trigger an event on the eventTarget that the segmentation representation for\n * toolGroupId has been updated\n * @param toolGroupId - The Id of the toolGroup\n */\nfunction triggerSegmentationRepresentationModified(\n  toolGroupId: string,\n  segmentationRepresentationUID?: string\n): void {\n  const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n    toolGroupId,\n    segmentationRepresentationUID,\n  };\n\n  if (segmentationRepresentationUID) {\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n    return;\n  }\n\n  // If no segmentationRepresentationUID is provided, then we need to trigger\n  // the event for all segmentation representations in the toolGroup\n\n  // Get all segmentation representations in the toolGroup\n  const segmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId) || [];\n\n  segmentationRepresentations.forEach((segmentationRepresentation) => {\n    const { segmentationRepresentationUID } = segmentationRepresentation;\n    const eventDetail: SegmentationRepresentationModifiedEventDetail = {\n      toolGroupId,\n      segmentationRepresentationUID,\n    };\n\n    triggerEvent(\n      eventTarget,\n      Events.SEGMENTATION_REPRESENTATION_MODIFIED,\n      eventDetail\n    );\n  });\n}\n\n/**\n * Triggers segmentation global state updated event, notifying all toolGroups\n * that the global state has been updated, If a segmentationId is provided\n * the event will only be triggered for that segmentation, otherwise it will\n * be triggered for all segmentations.\n *\n * @param segmentationId - The id of the segmentation that has been updated\n */\nfunction triggerSegmentationModified(segmentationId?: string): void {\n  let segmentationIds;\n\n  if (segmentationId) {\n    segmentationIds = [segmentationId];\n  } else {\n    // get all toolGroups\n    segmentationIds = getSegmentations().map(\n      ({ segmentationId }) => segmentationId\n    );\n  }\n\n  // 1. Trigger an event notifying all listeners about the segmentationId\n  // that has been updated.\n  segmentationIds.forEach((segmentationId) => {\n    const eventDetail: SegmentationModifiedEventDetail = {\n      segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n  });\n\n  // Todo: I don't think we need the following lines of code\n  // // 2. Notify all viewports that render the segmentationId in order to update the\n  // // rendering based on the new global state.\n  // toolGroupIds.forEach((toolGroupId) => {\n  //   triggerSegmentationRepresentationModified(toolGroupId)\n  // })\n}\n\n/**\n * Trigger an event that a segmentation data has been modified\n * @param segmentationId - The Id of segmentation\n */\nfunction triggerSegmentationDataModified(\n  segmentationId: string,\n  modifiedSlicesToUse?: number[]\n): void {\n  const eventDetail: SegmentationDataModifiedEventDetail = {\n    segmentationId,\n    modifiedSlicesToUse,\n  };\n\n  triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n\nexport {\n  // ToolGroup Specific\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n  // Global\n  triggerSegmentationDataModified,\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n};\n","import {\n  SegmentationPublicInput,\n  Segmentation,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It takes in a segmentation input and returns a segmentation with default values\n * @param segmentationInput - The input to the segmentation.\n * @returns A Segmentation object.\n * @internal\n */\nfunction normalizeSegmentationInput(\n  segmentationInput: SegmentationPublicInput\n): Segmentation {\n  const { segmentationId, representation } = segmentationInput;\n\n  // Todo: we should be able to let the user pass in non-default values for\n  // cachedStats, label, activeSegmentIndex, etc.\n  return {\n    segmentationId,\n    cachedStats: {},\n    segmentLabels: {},\n    label: null,\n    segmentsLocked: new Set(),\n    type: representation.type,\n    activeSegmentIndex: 1,\n    representationData: {\n      [representation.type]: {\n        ...representation.data,\n      },\n    },\n  };\n}\n\nexport default normalizeSegmentationInput;\n","import type {\n  ColorLUT,\n  RepresentationConfig,\n  Segmentation,\n  SegmentationPublicInput,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n  ToolGroupSpecificRepresentations,\n} from '../../types/SegmentationStateTypes';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport {\n  triggerSegmentationModified,\n  triggerSegmentationRemoved,\n  triggerSegmentationRepresentationModified,\n  triggerSegmentationRepresentationRemoved,\n} from './triggerSegmentationEvents';\n\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\n\n/**\n * It returns the defaultSegmentationStateManager.\n */\nfunction getDefaultSegmentationStateManager() {\n  return defaultSegmentationStateManager;\n}\n\n/*************************\n *\n * Segmentation State\n *\n **************************/\n\n/**\n * Get the segmentation for the given segmentationId\n * @param segmentationId - The Id of the segmentation\n * @returns A GlobalSegmentationData object\n */\nfunction getSegmentation(segmentationId: string): Segmentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentation(segmentationId);\n}\n\n/**\n * Get the segmentations inside the state\n * @returns Segmentation array\n */\nfunction getSegmentations(): Segmentation[] | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n\n  return state.segmentations;\n}\n\n/**\n * It takes a segmentation input and adds it to the segmentation state manager\n * @param segmentationInput - The segmentation to add.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction addSegmentation(\n  segmentationInput: SegmentationPublicInput,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const segmentation = normalizeSegmentationInput(segmentationInput);\n\n  segmentationStateManager.addSegmentation(segmentation);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified(segmentation.segmentationId);\n  }\n}\n\n/**\n * Get the segmentation state for a tool group. It will return an array of\n * segmentation representation objects.\n * @param toolGroupId - The unique identifier of the tool group.\n * @returns An array of segmentation representation objects.\n */\nfunction getSegmentationRepresentations(\n  toolGroupId: string\n): ToolGroupSpecificRepresentations | [] {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n}\n\n/**\n * Get all segmentation representations in the state\n * @returns An array of segmentation representation objects.\n */\nfunction getAllSegmentationRepresentations(): Record<\n  string,\n  ToolGroupSpecificRepresentation[]\n> {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getAllSegmentationRepresentations();\n}\n\n/**\n * Get the tool group IDs that have a segmentation representation with the given\n * segmentationId\n * @param segmentationId - The id of the segmentation\n * @returns An array of tool group IDs.\n */\nfunction getToolGroupIdsWithSegmentation(segmentationId: string): string[] {\n  if (!segmentationId) {\n    throw new Error('getToolGroupIdsWithSegmentation: segmentationId is empty');\n  }\n\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  const state = segmentationStateManager.getState();\n  const toolGroupIds = Object.keys(state.toolGroups);\n\n  const foundToolGroupIds = [];\n  toolGroupIds.forEach((toolGroupId) => {\n    const toolGroupSegmentationRepresentations =\n      segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n    toolGroupSegmentationRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        foundToolGroupIds.push(toolGroupId);\n      }\n    });\n  });\n\n  return foundToolGroupIds;\n}\n\n/**\n * Get the segmentation representations config for a given tool group\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config belongs to.\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Set the segmentation representation config for the provided toolGroup. ToolGroup specific\n * configuration overwrites the global configuration for each representation.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that the segmentation\n * config is being set for.\n * @param config - The new configuration for the tool group.\n * @param suppressEvents - If true, the event will not be triggered.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationConfig(\n    toolGroupId,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(toolGroupId);\n  }\n}\n\n/**\n * It sets the segmentation representation specific config for all the segments\n * inside the segmentation.\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @param config  - The new configuration for the segmentation representation it is an object with keys of\n * different representation types, and values of the configuration for each representation type.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the segmentation representation specific config which is the same for all the segments\n * @param segmentationRepresentationUID - The unique identifier of the segmentation representation.\n * @returns - The segmentation representation specific config.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction getSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\nfunction setSegmentSpecificRepresentationConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig,\n  suppressEvents = false\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setSegmentSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n\n  // Todo: this can be even more performant if we create a new event for\n  // triggering a specific segment config change.\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * Add the given segmentation representation data to the given tool group state. It fires\n * SEGMENTATION_REPRESENTATION_MODIFIED event if not suppressed.\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation representation is for.\n * @param segmentationData - The data to add to the segmentation state.\n * @param suppressEvents - boolean\n */\nfunction addSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentation\n  );\n\n  if (!suppressEvents) {\n    triggerSegmentationRepresentationModified(\n      toolGroupId,\n      segmentationRepresentation.segmentationRepresentationUID\n    );\n  }\n}\n\n/**\n * It returns the global segmentation config. Note that the toolGroup-specific\n * configuration has higher priority than the global configuration and overwrites\n * the global configuration for each representation.\n * @returns The global segmentation configuration for all segmentations.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation configuration. It fires SEGMENTATION_MODIFIED\n * event if not suppressed.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param config - The new global segmentation config.\n * @param suppressEvents - If true, the `segmentationGlobalStateModified` event will not be triggered.\n */\nfunction setGlobalConfig(\n  config: SegmentationRepresentationConfig,\n  suppressEvents?: boolean\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.setGlobalConfig(config);\n\n  if (!suppressEvents) {\n    triggerSegmentationModified();\n  }\n}\n\n/**\n * Get the segmentation data object for a given tool group and\n * segmentation data UID. It searches all the toolGroup specific segmentation\n * data objects and returns the first one that matches the UID.\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @returns Segmentation Data object.\n */\nfunction getSegmentationRepresentationByUID(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): ToolGroupSpecificRepresentation | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * It removes the segmentation from the segmentation state manager\n *\n * @triggers SEGMENTATION_REMOVED\n *\n * @param segmentationId - The id of the segmentation\n */\nfunction removeSegmentation(segmentationId: string): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentation(segmentationId);\n  triggerSegmentationRemoved(segmentationId);\n}\n\n/**\n * Remove a segmentation representation from the segmentation state manager for a toolGroup.\n * It fires SEGMENTATION_REPRESENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_REPRESENTATION_REMOVED\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation to remove.\n * remove.\n * @param - immediate - If true, the viewports will be updated immediately.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationRemoved(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction removeColorLUT(colorLUTIndex: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n\n/**\n * Get the color lut for a given index\n * @param index - The index of the color lut to retrieve.\n * @returns A ColorLUT array.\n */\nfunction getColorLUT(index: number): ColorLUT | undefined {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  return segmentationStateManager.getColorLUT(index);\n}\n\n/**\n * Add a color LUT to the segmentation state manager\n * @param colorLUT - The color LUT array to add.\n * @param index - The index of the color LUT to add.\n */\nfunction addColorLUT(colorLUT: ColorLUT, index: number): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n  segmentationStateManager.addColorLUT(colorLUT, index);\n  // Todo: trigger event color LUT added\n}\n\nexport {\n  getDefaultSegmentationStateManager,\n  // Segmentation\n  getSegmentation,\n  getSegmentations,\n  addSegmentation,\n  removeSegmentation,\n  // ToolGroup specific Segmentation Representation\n  getSegmentationRepresentations,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n  // config\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  getGlobalConfig,\n  setGlobalConfig,\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  getSegmentSpecificRepresentationConfig,\n  setSegmentSpecificRepresentationConfig,\n  // helpers s\n  getToolGroupIdsWithSegmentation,\n  getAllSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n  // color\n  addColorLUT,\n  getColorLUT,\n  removeColorLUT,\n};\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { IPoints } from '../../types';\n\n/**\n * Given a native mouse event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Mouse event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getMouseEventPoints(\n  evt: MouseEvent,\n  element?: HTMLDivElement\n): IPoints {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const { viewport } = getEnabledElement(elementToUse);\n  const clientPoint = _clientToPoint(evt);\n  const pagePoint = _pageToPoint(evt);\n  const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n  const worldPoint = viewport.canvasToWorld(canvasPoint);\n\n  return {\n    page: pagePoint,\n    client: clientPoint,\n    canvas: canvasPoint,\n    world: worldPoint,\n  };\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param evt - The Mouse `Event`\n */\nfunction _pageToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.pageX, evt.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Mouse `Event`\n */\nfunction _clientToPoint(evt: MouseEvent): Types.Point2 {\n  return [evt.clientX, evt.clientY];\n}\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { EventTypes, IPoints } from '../../types';\n\n/**\n * Captures and normalizes the double click event. Emits as a cornerstoneTools3D\n * double click event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseDoubleClickListener(evt: MouseEvent): void {\n  const element = <HTMLDivElement>evt.currentTarget;\n\n  const { viewportId, renderingEngineId } = getEnabledElement(element);\n\n  const startPoints = getMouseEventPoints(evt, element);\n  const deltaPoints: IPoints = {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  };\n\n  const eventDetail: EventTypes.MouseDoubleClickEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_DOUBLE_CLICK,\n    viewportId,\n    renderingEngineId,\n    camera: {},\n    element,\n    startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(\n    element,\n    Events.MOUSE_DOUBLE_CLICK,\n    eventDetail\n  );\n\n  if (consumed) {\n    // The Events.MOUSE_DOUBLE_CLICK was consumed, thus no other listener should handle this 'dblclick' event.\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseDoubleClickListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport getMouseEventPoints from './getMouseEventPoints';\nimport { MouseMoveEventDetail } from '../../types/EventTypes';\n\nconst eventName = Events.MOUSE_MOVE;\n\n/**\n * Captures and normalizes the mouse move event. Emits as a cornerstoneTools3D\n * mouse move event.\n *\n * @param evt - The mouse event.\n */\nfunction mouseMoveListener(evt: MouseEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const currentPoints = getMouseEventPoints(evt);\n  const eventDetail: MouseMoveEventDetail = {\n    renderingEngineId,\n    viewportId,\n    camera: {},\n    element,\n    currentPoints,\n    eventName,\n    event: evt,\n  };\n\n  const consumed = !triggerEvent(element, eventName, eventDetail);\n\n  // Events.MOUSE_MOVE was consumed, thus no other listener should handle this event.\n  if (consumed) {\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n}\n\nexport default mouseMoveListener;\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport Events from '../../enums/Events';\nimport mouseMoveListener from './mouseMoveListener';\nimport { EventTypes, IPoints } from '../../types';\nimport getMouseEventPoints from './getMouseEventPoints';\n\nconst { MOUSE_DOWN, MOUSE_DOWN_ACTIVATE, MOUSE_CLICK, MOUSE_UP, MOUSE_DRAG } =\n  Events;\n\n// The amount of time in milliseconds within which a browser 'dblclick' event has to occur.\n// Any mouse down, up, down and up sequence taking longer than this time is considered to\n// NOT be a double click and any browser 'dblclick' event that subsequently occurs as a result\n// of such a sequence will be ignored. It is best to set this to a value that is less\n// than the system value for detecting a double click. Setting something too large\n// might detect a double click that does not constitute a browser 'dblclick' and thus\n// no mouse events for the sequence will get fired at all.\n//\n// TODO This module should detect and fire 'dblclick' events at its discretion and\n// ignore all those generated by the browser.\n//\nconst DOUBLE_CLICK_TOLERANCE_MS = 400;\n\n// This tolerance is how long to accept a secondary button down\nconst MULTI_BUTTON_TOLERANCE_MS = 150;\n\n// A drag (projected distance) during the double click timeout that is greater than this\n// value will cancel the timeout and suppress any double click that might occur.\n// This tolerance is particularly important on touch devices where some movement\n// might occur between the two clicks.\n//\n// TODO revisit this value for touch devices\n//\nconst DOUBLE_CLICK_DRAG_TOLERANCE = 3;\n\ninterface IMouseDownListenerState {\n  mouseButton: number;\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  isClickEvent: boolean;\n  clickDelay: number;\n  preventClickTimeout: ReturnType<typeof setTimeout>;\n  startPoints: IPoints;\n  lastPoints: IPoints;\n}\n\ninterface IDoubleClickState {\n  doubleClickTimeout: ReturnType<typeof setTimeout>;\n  mouseDownEvent: MouseEvent;\n  mouseUpEvent: MouseEvent;\n  ignoreDoubleClick: boolean;\n}\n\n// STATE\nconst defaultState: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  element: null,\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nlet state: IMouseDownListenerState = {\n  mouseButton: undefined,\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  isClickEvent: true,\n  clickDelay: 200,\n  element: null,\n  preventClickTimeout: null,\n  startPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n  lastPoints: {\n    page: [0, 0],\n    client: [0, 0],\n    canvas: [0, 0],\n    world: [0, 0, 0],\n  },\n};\n\nconst doubleClickState: IDoubleClickState = {\n  doubleClickTimeout: null,\n  mouseDownEvent: null,\n  mouseUpEvent: null,\n  ignoreDoubleClick: false,\n};\n\n/**\n * Listens to mouse down events from the DOM and depending on interaction and further\n * interaction can emit the following mouse events:\n *\n * - MOUSE_DOWN\n * - MOUSE_DOWN_ACTIVATE\n * - MOUSE_DRAG (move while down)\n * - MOUSE_UP\n * - MOUSE_CLICK\n *\n * The mouse down is NOT handled immediately. Instead, a timeout is started to\n * determine if this mouse down is the first in a sequence that constitutes a\n * double click.\n *\n * @param evt - The Mouse event.\n * @private\n */\nfunction mouseDownListener(evt: MouseEvent) {\n  if (doubleClickState.doubleClickTimeout) {\n    // A second identical click will be a double click event, so ignore it\n    if (evt.buttons === doubleClickState.mouseDownEvent.buttons) {\n      return;\n    }\n\n    // Record the second button or the changed button event as the initial\n    // button down state so that the multi-button event can be detected\n    doubleClickState.mouseDownEvent = evt;\n\n    // If second button is added, then ensure double click timeout is terminated\n    // and do not handle three or more button gestures.\n    _doStateMouseDownAndUp();\n    return;\n  }\n\n  // Handle multi-button clicks by adding a delay before handling them.\n  // Double clicks (left button only) physically take the user longer, so\n  // use a longer timeout, and for multi-button at the same time, the clicks\n  // are done at the same time by the user, just the system perceives them\n  // separately, so have a short timeout to allow catching both buttons.\n  doubleClickState.doubleClickTimeout = setTimeout(\n    _doStateMouseDownAndUp,\n    evt.buttons === 1 ? DOUBLE_CLICK_TOLERANCE_MS : MULTI_BUTTON_TOLERANCE_MS\n  );\n\n  // First mouse down of a potential double click. So save it and start\n  // a timeout to determine a double click.\n  doubleClickState.mouseDownEvent = evt;\n  doubleClickState.ignoreDoubleClick = false;\n\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  state.mouseButton = evt.buttons;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n\n  state.preventClickTimeout = setTimeout(\n    _preventClickHandler,\n    state.clickDelay\n  );\n\n  // Prevent CornerstoneToolsMouseMove while mouse is down\n  state.element.removeEventListener('mousemove', mouseMoveListener);\n\n  const startPoints = getMouseEventPoints(evt, state.element);\n  state.startPoints = _copyPoints(startPoints);\n  state.lastPoints = _copyPoints(startPoints);\n\n  document.addEventListener('mouseup', _onMouseUp);\n  document.addEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Does the actual mouse down logic if the double click timer has expired or\n * a mouse drag has started.\n * @param evt the mouse down event\n * @private\n */\nfunction _doMouseDown(evt: MouseEvent) {\n  const deltaPoints = _getDeltaPoints(state.startPoints, state.startPoints);\n\n  const eventDetail: EventTypes.MouseDownEventDetail = {\n    event: evt,\n    eventName: MOUSE_DOWN,\n    element: state.element,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPoints: state.startPoints,\n    lastPoints: state.startPoints,\n    currentPoints: state.startPoints,\n    deltaPoints,\n  };\n\n  state.lastPoints = _copyPoints(eventDetail.lastPoints);\n\n  // by triggering MOUSE_DOWN it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const notConsumed = triggerEvent(\n    eventDetail.element,\n    MOUSE_DOWN,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default behavior,\n  // create a new tool\n  if (notConsumed) {\n    triggerEvent(eventDetail.element, MOUSE_DOWN_ACTIVATE, eventDetail);\n  }\n}\n\n/**\n *_onMouseDrag - Handle emission of drag events whilst the mouse is depressed.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseDrag(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (doubleClickState.doubleClickTimeout) {\n    if (_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n      // Dragging past the tolerance means no double click should occur.\n      _doStateMouseDownAndUp();\n    } else {\n      return;\n    }\n  }\n\n  const eventDetail: EventTypes.MouseDragEventDetail = {\n    event: evt,\n    eventName: MOUSE_DRAG,\n    mouseButton: state.mouseButton,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: _copyPoints(state.startPoints),\n    lastPoints: _copyPoints(lastPoints),\n    currentPoints,\n    deltaPoints,\n  };\n\n  const consumed = !triggerEvent(state.element, MOUSE_DRAG, eventDetail);\n\n  // Events.MOUSE_DRAG was consumed, thus no other listener should handle this event.\n  if (consumed) {\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  }\n\n  // Update the last points\n  state.lastPoints = _copyPoints(currentPoints);\n}\n\n/**\n *_onMouseUp - Handle emission of mouse up events, and re-enabling mouse move events.\n *\n * If the mouse up event occurs during a double click timeout, it is either the first or\n * second mouse up of a potential double click sequence. If the first, then it\n * is saved in case the double click timeout expires and a simple mouse down and\n * up have to get executed. If the second, then the latest mouse down, up, down and\n * up constitute a double click and the mouseDoubleClickListener needs to execute.\n *\n * If the mouse up event comes after the double click timeout, then it is simply\n * handled as the up of a mouse down and up sequence.\n *\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseUp(evt: MouseEvent): void {\n  // Cancel the timeout preventing the click event from triggering\n  clearTimeout(state.preventClickTimeout);\n\n  if (doubleClickState.doubleClickTimeout) {\n    // received a mouse up while waiting for a double click (via a timeout)\n\n    if (!doubleClickState.mouseUpEvent) {\n      // this is the first mouse up during the double click timeout; we'll need it later if the timeout expires\n      doubleClickState.mouseUpEvent = evt;\n\n      state.element.addEventListener('mousemove', _onMouseMove);\n    } else {\n      // this is the second mouse up of a double click!\n      _cleanUp();\n    }\n  } else {\n    // Handle the actual mouse up. Note that it may have occurred during the double click timeout or\n    // after it expired. In either case this block is being executed after the time out has expired\n    // or after a drag started.\n\n    const eventName = state.isClickEvent ? MOUSE_CLICK : MOUSE_UP;\n\n    const currentPoints = getMouseEventPoints(evt, state.element);\n    const deltaPoints = _getDeltaPoints(currentPoints, state.lastPoints);\n    const eventDetail:\n      | EventTypes.MouseUpEventDetail\n      | EventTypes.MouseClickEventType = {\n      event: evt,\n      eventName,\n      mouseButton: state.mouseButton,\n      element: state.element,\n      renderingEngineId: state.renderingEngineId,\n      viewportId: state.viewportId,\n      camera: {},\n      startPoints: _copyPoints(state.startPoints),\n      lastPoints: _copyPoints(state.lastPoints),\n      currentPoints,\n      deltaPoints,\n    };\n\n    triggerEvent(eventDetail.element, eventName, eventDetail);\n\n    _cleanUp();\n  }\n\n  // Remove the drag as soon as we get the mouse up because either we have executed\n  // the mouse up logic, or we have not even handled the mouse down logic yet\n  // - either way no drag should/can occur.\n  document.removeEventListener('mousemove', _onMouseDrag);\n}\n\n/**\n * Handles a mouse move on the state element after a mouse down AND up AND\n * while the double click timeout is still running.\n * @private\n * @param evt - The mouse event.\n */\nfunction _onMouseMove(evt: MouseEvent) {\n  const currentPoints = getMouseEventPoints(evt, state.element);\n  const lastPoints = _updateMouseEventsLastPoints(\n    state.element,\n    state.lastPoints\n  );\n\n  const deltaPoints = _getDeltaPoints(currentPoints, lastPoints);\n\n  if (!_isDragPastDoubleClickTolerance(deltaPoints.canvas)) {\n    return;\n  }\n\n  _doStateMouseDownAndUp();\n\n  // Do the move again because during the timeout the global mouse move listener was removed.\n  // Now it is back.\n  mouseMoveListener(evt);\n}\n\n/**\n * Determines if the given delta is past the double click, (projected) drag distance\n * tolerance.\n * @param delta the delta\n * @returns true iff the delta is past the tolerance\n */\nfunction _isDragPastDoubleClickTolerance(delta: Types.Point2): boolean {\n  return Math.abs(delta[0]) + Math.abs(delta[1]) > DOUBLE_CLICK_DRAG_TOLERANCE;\n}\n\nfunction _preventClickHandler() {\n  state.isClickEvent = false;\n}\n\n/**\n * Do a mouse down and potential mouse up using each of the events in the double click state.\n * The events were stored in the state during the timeout to determine a double click.\n *\n * This function should be invoked whenever it is determined that the latest\n * sequence of mouse down(s) and up(s) is NOT a double click. Examples of this include\n * - the expiration of the double click timeout\n * - a mouse drag/move beyond the DOUBLE_CLICK_DRAG_TOLERANCE\n *\n * This function sets the doubleClickState.ignoreDoubleClick flag in case our timeout value\n * or mouse move/drag tolerance is inaccurate and we do indeed get a double click event from\n * the browser later. The flag will be cleared in the mouseDoubleClickIgnoreListener should a\n * double click event get fired. If there is no eventual double click for the latest sequence,\n * the flag spills into the next sequence where it will get cleared at the beginning of that next\n * sequence in mouseDownListener. It is perfectly safe for the flag to be\n * left true when no double click actually occurs because any future double click must start with\n * a mouse down that is handled in this module.\n *\n * @private\n */\nfunction _doStateMouseDownAndUp() {\n  doubleClickState.ignoreDoubleClick = true;\n\n  const mouseDownEvent = doubleClickState.mouseDownEvent;\n  const mouseUpEvent = doubleClickState.mouseUpEvent;\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  _doMouseDown(mouseDownEvent);\n\n  if (mouseUpEvent) {\n    _onMouseUp(mouseUpEvent);\n  }\n}\n\n/**\n * Clears the mouse events and double click timeout id in the double click state object.\n * The timeout itself is also cleared so that no callback is invoked.\n */\nfunction _clearDoubleClickTimeoutAndEvents() {\n  if (doubleClickState.doubleClickTimeout) {\n    clearTimeout(doubleClickState.doubleClickTimeout);\n    doubleClickState.doubleClickTimeout = null;\n  }\n\n  doubleClickState.mouseDownEvent = null;\n  doubleClickState.mouseUpEvent = null;\n}\n\nfunction _cleanUp() {\n  document.removeEventListener('mouseup', _onMouseUp);\n  state.element?.removeEventListener('mousemove', _onMouseMove);\n\n  // Restore our global mousemove listener\n  state.element?.addEventListener('mousemove', mouseMoveListener);\n\n  _clearDoubleClickTimeoutAndEvents();\n\n  state = JSON.parse(JSON.stringify(defaultState));\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction _copyPoints(points: IPoints): IPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateMouseEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: IPoints\n): IPoints {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  const world = viewport.canvasToWorld(lastPoints.canvas);\n\n  return {\n    page: lastPoints.page,\n    client: lastPoints.client,\n    canvas: lastPoints.canvas,\n    world,\n  };\n}\n\n/**\n * Returns the difference between two `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction _getDeltaPoints(currentPoints: IPoints, lastPoints: IPoints): IPoints {\n  return {\n    page: _subtractPoints2D(currentPoints.page, lastPoints.page),\n    client: _subtractPoints2D(currentPoints.client, lastPoints.client),\n    canvas: _subtractPoints2D(currentPoints.canvas, lastPoints.canvas),\n    world: _subtractPoints3D(currentPoints.world, lastPoints.world),\n  };\n}\n\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nexport function getMouseButton(): number {\n  return state.mouseButton;\n}\n\n/**\n * Handles a dblclick event to determine if it should be ignored based on the\n * double click state's ignoreDoubleClick flag. stopImmediatePropagation and\n * preventDefault are used to ignore the event.\n * @param evt browser dblclick event\n */\nexport function mouseDoubleClickIgnoreListener(evt: MouseEvent) {\n  if (doubleClickState.ignoreDoubleClick) {\n    doubleClickState.ignoreDoubleClick = false;\n\n    // Use stopImmediatePropagation to lessen the possibility that a third party 'dblclick'\n    // listener receives this event. However, there still is no guarantee\n    // that any third party listener has not already handled the event.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  } else {\n    // If the embedding application blocked the first mouse down and up\n    // of a double click sequence from reaching this module, then this module\n    // has handled the second mouse down and up and thus needs to clean them up.\n    // Doing a clean up here for the typical double click case is harmless.\n    _cleanUp();\n  }\n}\n\nexport default mouseDownListener;\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, {\n  mouseDoubleClickIgnoreListener,\n} from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\n\n/**\n * Removes mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('dblclick', mouseDoubleClickListener);\n  element.removeEventListener('mousedown', mouseDownListener);\n  element.removeEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\n/**\n * Registers mouse event listeners for native mouse event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n\n  element.addEventListener('dblclick', mouseDoubleClickListener);\n  element.addEventListener('mousedown', mouseDownListener);\n  element.addEventListener('mousemove', mouseMoveListener);\n  // The mouseDoubleClickIgnoreListener prevents those browser 'dblclick'\n  // events that cornerstone has determined are single clicks from propagating\n  // to other (3rd party) listeners. A capture phase listener is used so that\n  // the 'dblclick' event can be ignored and not propagated ASAP.\n  element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n    capture: true,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport normalizeWheel from './normalizeWheel';\nimport Events from '../../enums/Events';\n// ~~ VIEWPORT LIBRARY\nimport getMouseEventPoints from '../mouse/getMouseEventPoints';\nimport { MouseWheelEventDetail } from '../../types/EventTypes';\n\n/**\n * wheelListener - Captures and normalizes mouse wheel events. Emits as a\n * cornerstoneTools3D mouse wheel event.\n * @param evt - The mouse wheel event.\n */\nfunction wheelListener(evt: WheelEvent) {\n  const element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  // Prevent triggering MouseWheel events that are not real scroll events:\n  // E.g. when clicking the MiddleMouseWheelButton, a deltaY of 0 is emitted.\n  // See https://github.com/cornerstonejs/cornerstoneTools/issues/935\n  if (evt.deltaY > -1 && evt.deltaY < 1) {\n    return;\n  }\n\n  evt.preventDefault();\n\n  const { spinX, spinY, pixelX, pixelY } = normalizeWheel(evt);\n  const direction = spinY < 0 ? -1 : 1;\n\n  const eventDetail: MouseWheelEventDetail = {\n    event: evt,\n    eventName: Events.MOUSE_WHEEL,\n    renderingEngineId,\n    viewportId,\n    element,\n    camera: {},\n    detail: evt,\n    wheel: {\n      spinX,\n      spinY,\n      pixelX,\n      pixelY,\n      direction,\n    },\n    points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(element, Events.MOUSE_WHEEL, eventDetail);\n}\n\nexport default wheelListener;\n","// Reasonable defaults\nconst PIXEL_STEP = 10;\nconst LINE_HEIGHT = 40;\nconst PAGE_HEIGHT = 800;\n\n/**\n * Normalizes wheel events and provides properties that are more\n * consistent and helpful across different browsers\n *\n * @param event - the original mouse event\n * @returns a normalized eventDetail\n */\nexport default function normalizeWheel(event) {\n  let spinX = 0,\n    spinY = 0,\n    pixelX = 0,\n    pixelY = 0;\n\n  // Legacy\n  if ('detail' in event) {\n    spinY = event.detail;\n  }\n  if ('wheelDelta' in event) {\n    spinY = -event.wheelDelta / 120;\n  }\n  if ('wheelDeltaY' in event) {\n    spinY = -event.wheelDeltaY / 120;\n  }\n  if ('wheelDeltaX' in event) {\n    spinX = -event.wheelDeltaX / 120;\n  }\n\n  pixelX = spinX * PIXEL_STEP;\n  pixelY = spinY * PIXEL_STEP;\n\n  if ('deltaY' in event) {\n    pixelY = event.deltaY;\n  }\n  if ('deltaX' in event) {\n    pixelX = event.deltaX;\n  }\n\n  if ((pixelX || pixelY) && event.deltaMode) {\n    if (event.deltaMode === 1) {\n      // Delta in LINE units\n      pixelX *= LINE_HEIGHT;\n      pixelY *= LINE_HEIGHT;\n    } else {\n      // Delta in PAGE units\n      pixelX *= PAGE_HEIGHT;\n      pixelY *= PAGE_HEIGHT;\n    }\n  }\n\n  // Fall-back if spin cannot be determined\n  if (pixelX && !spinX) {\n    spinX = pixelX < 1 ? -1 : 1;\n  }\n  if (pixelY && !spinY) {\n    spinY = pixelY < 1 ? -1 : 1;\n  }\n\n  return {\n    spinX,\n    spinY,\n    pixelX,\n    pixelY,\n  };\n}\n","import wheelListener from './wheelListener';\n\n/**\n * Listens for the wheel event, and handles it. Handled event\n * will be \"normalized\" and re-emitted as `Events.MOUSE_WHEEL`\n *\n * @param element - The HTML element\n */\nfunction enable(element: HTMLDivElement) {\n  disable(element);\n  element.addEventListener('wheel', wheelListener, { passive: false });\n}\n\n/**\n * Removes listener and handler for wheel event. `Events.MOUSE_WHEEL`\n * will no longer be emitted.\n *\n * @param element - THe HTML element\n */\nfunction disable(element: HTMLDivElement) {\n  element.removeEventListener('wheel', wheelListener);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","// Functions to prevent ghost clicks following a touch\n// Since the event lifecycle is touchstart, mousedown, touchend, mouseup\n// we want to prevent mousedown and mouseup events after touch events\n// All credit to @kosich\n// https://gist.github.com/kosich/23188dd86633b6c2efb7\n\nconst antiGhostDelay = 2000,\n  pointerType = {\n    mouse: 0,\n    touch: 1,\n  };\n\nlet lastInteractionType, lastInteractionTime;\n\nfunction handleTap(type, e) {\n  const now = Date.now();\n\n  if (type !== lastInteractionType) {\n    if (now - lastInteractionTime <= antiGhostDelay) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n\n      return false;\n    }\n\n    lastInteractionType = type;\n  }\n\n  lastInteractionTime = now;\n}\n\n// Cacheing the function references\n// Necessary because a new function reference is created after .bind() is called\n// http://stackoverflow.com/questions/11565471/removing-event-listener-which-was-added-with-bind\nconst handleTapMouse = handleTap.bind(null, pointerType.mouse);\nconst handleTapTouch = handleTap.bind(null, pointerType.touch);\n\nfunction attachEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.addEventListener(eventName, tapHandler, { passive: false });\n  });\n}\n\nfunction removeEvents(element, eventList, interactionType) {\n  const tapHandler = interactionType ? handleTapMouse : handleTapTouch;\n\n  eventList.forEach(function (eventName) {\n    element.removeEventListener(eventName, tapHandler);\n  });\n}\n\nconst mouseEvents = ['mousedown', 'mouseup', 'mousemove'];\nconst touchEvents = ['touchstart', 'touchend'];\n\nfunction disable(element) {\n  removeEvents(element, mouseEvents, pointerType.mouse);\n  removeEvents(element, touchEvents, pointerType.touch);\n}\n\nfunction enable(element) {\n  disable(element);\n  attachEvents(element, mouseEvents, pointerType.mouse);\n  attachEvents(element, touchEvents, pointerType.touch);\n}\n\nexport default {\n  enable,\n  disable,\n};\n","enum Swipe {\n  UP = 'UP',\n  DOWN = 'DOWN',\n  LEFT = 'LEFT',\n  RIGHT = 'RIGHT',\n}\n\nexport { Swipe };\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { ITouchPoints } from '../../types';\n\n/**\n * Given a native touch event, get the associated cornerstone3D enabled element\n * and derive a set of coordinates useful for tools.\n * @param evt - The Touch event.\n * @param element - The DOM HTMLDivElement that the event was triggered on.\n * @returns The points related to the event in the form of a `IPoints` object containing\n * the following properties: `page`, `client`, `canvas`, and `world` details of the event.\n */\nexport default function getTouchEventPoints(\n  evt: TouchEvent,\n  element?: HTMLDivElement\n): ITouchPoints[] {\n  const elementToUse = element || (evt.currentTarget as HTMLDivElement);\n  const touches = evt.type === 'touchend' ? evt.changedTouches : evt.touches;\n  return Object.keys(touches).map((i) => {\n    const clientPoint = _clientToPoint(touches[i]);\n    const pagePoint = _pageToPoint(touches[i]);\n    const canvasPoint = _pagePointsToCanvasPoints(elementToUse, pagePoint);\n    const { viewport } = getEnabledElement(elementToUse);\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return {\n      page: pagePoint,\n      client: clientPoint,\n      canvas: canvasPoint,\n      world: worldPoint,\n      touch: {\n        identifier: i,\n        radiusX: touches[i].radiusX,\n        radiusY: touches[i].radiusY,\n        force: touches[i].force,\n        rotationAngle: touches[i].rotationAngle,\n      },\n    };\n  });\n}\n\n/**\n * Converts point from page coordinates to canvas coordinates.\n * @param element - HTMLDivElement\n * @param pagePoint - Point in page coordinates pageX and pageY\n *\n * @returns The canvas coordinate points\n */\nfunction _pagePointsToCanvasPoints(\n  element: HTMLDivElement,\n  pagePoint: Types.Point2\n): Types.Point2 {\n  const rect = element.getBoundingClientRect();\n  return [\n    pagePoint[0] - rect.left - window.pageXOffset,\n    pagePoint[1] - rect.top - window.pageYOffset,\n  ];\n}\n\n/**\n * Converts the event's `pageX` and `pageY` properties to Types.Point2 format\n *\n * @param touch - The Touch\n */\nfunction _pageToPoint(touch: Touch): Types.Point2 {\n  return [touch.pageX, touch.pageY];\n}\n\n/**\n * Converts the event's `clientX` and `clientY` properties to Types.Point2 format\n * @param evt - The Touch `Event`\n */\nfunction _clientToPoint(touch: Touch): Types.Point2 {\n  return [touch.clientX, touch.clientY];\n}\n","import { IDistance, IPoints, ITouchPoints } from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IPoints {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _subtractPoints2D(curr.page, last.page),\n    client: _subtractPoints2D(curr.client, last.client),\n    canvas: _subtractPoints2D(curr.canvas, last.canvas),\n    world: _subtractPoints3D(curr.world, last.world),\n  };\n}\n\n/**\n * Returns the distance between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints - The last points, to be subtracted from the `currentPoints`.\n *\n * @returns The distance difference in IDistance format\n */\nfunction getDeltaDistance(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const curr = getMeanPoints(currentPoints);\n  const last = getMeanPoints(lastPoints);\n  return {\n    page: _getDistance2D(curr.page, last.page),\n    client: _getDistance2D(curr.client, last.client),\n    canvas: _getDistance2D(curr.canvas, last.canvas),\n    world: _getDistance3D(curr.world, last.world),\n  };\n}\n\nfunction getDeltaRotation(\n  currentPoints: ITouchPoints[],\n  lastPoints: ITouchPoints[]\n) {\n  // TODO\n}\n\n/**\n * Returns the distance difference between multiple `IPoints` instances.\n * @param currentPoints - The current points.\n * @param lastPoints -- The last points.\n *\n * @returns The difference in IPoints format\n */\nfunction getDeltaDistanceBetweenIPoints(\n  currentPoints: IPoints[],\n  lastPoints: IPoints[]\n): IDistance {\n  const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n  const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n  const deltaDistance = {\n    page: currentDistance.page - lastDistance.page,\n    client: currentDistance.client - lastDistance.client,\n    canvas: currentDistance.canvas - lastDistance.canvas,\n    world: currentDistance.world - lastDistance.world,\n  };\n  return deltaDistance;\n}\n\n/**\n * Copies a set of points.\n * @param points - The `IPoints` instance to copy.\n *\n * @returns A copy of the points.\n */\nfunction copyPointsList(points: ITouchPoints[]): ITouchPoints[] {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction copyPoints(points: ITouchPoints): ITouchPoints {\n  return JSON.parse(JSON.stringify(points));\n}\n\nfunction getMeanPoints(points: IPoints[]): IPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n    }\n  );\n}\n\nfunction getMeanTouchPoints(points: ITouchPoints[]): ITouchPoints {\n  return points.reduce(\n    (prev, curr) => {\n      return {\n        page: [\n          prev.page[0] + curr.page[0] / points.length,\n          prev.page[1] + curr.page[1] / points.length,\n        ],\n        client: [\n          prev.client[0] + curr.client[0] / points.length,\n          prev.client[1] + curr.client[1] / points.length,\n        ],\n        canvas: [\n          prev.canvas[0] + curr.canvas[0] / points.length,\n          prev.canvas[1] + curr.canvas[1] / points.length,\n        ],\n        world: [\n          prev.world[0] + curr.world[0] / points.length,\n          prev.world[1] + curr.world[1] / points.length,\n          prev.world[2] + curr.world[2] / points.length,\n        ],\n        touch: {\n          identifier: null,\n          radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n          radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n          force: prev.touch.force + curr.touch.force / points.length,\n          rotationAngle:\n            prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n        },\n      };\n    },\n    {\n      page: [0, 0],\n      client: [0, 0],\n      canvas: [0, 0],\n      world: [0, 0, 0],\n      touch: {\n        identifier: null,\n        radiusX: 0,\n        radiusY: 0,\n        force: 0,\n        rotationAngle: 0,\n      },\n    }\n  );\n}\n/**\n * _subtractPoints - Subtracts `point1` from `point0`.\n * @param point0 - The first point.\n * @param point1 - The second point to subtract from the first.\n *\n * @returns The difference.\n */\nfunction _subtractPoints2D(\n  point0: Types.Point2,\n  point1: Types.Point2\n): Types.Point2 {\n  return [point0[0] - point1[0], point0[1] - point1[1]];\n}\n\nfunction _subtractPoints3D(\n  point0: Types.Point3,\n  point1: Types.Point3\n): Types.Point3 {\n  return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\n\nfunction _getMeanDistanceBetweenAllIPoints(points: IPoints[]): IDistance {\n  // get mean distance between all unordered pairs of points\n  const pairedDistance: IDistance[] = [];\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < points.length; j++) {\n      if (i < j) {\n        pairedDistance.push({\n          page: _getDistance2D(points[i].page, points[j].page),\n          client: _getDistance2D(points[i].client, points[j].client),\n          canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n          world: _getDistance3D(points[i].world, points[j].world),\n        });\n      }\n    }\n  }\n\n  // take the average distance\n  return pairedDistance.reduce(\n    (prev, curr) => {\n      return {\n        page: prev.page + curr.page / pairedDistance.length,\n        client: prev.client + curr.client / pairedDistance.length,\n        canvas: prev.canvas + curr.canvas / pairedDistance.length,\n        world: prev.world + curr.world / pairedDistance.length,\n      };\n    },\n    {\n      page: 0,\n      client: 0,\n      canvas: 0,\n      world: 0,\n    }\n  );\n}\n\nfunction _getDistance2D(point0: Types.Point2, point1: Types.Point2): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2)\n  );\n}\n\nfunction _getDistance3D(point0: Types.Point3, point1: Types.Point3): number {\n  return Math.sqrt(\n    Math.pow(point0[0] - point1[0], 2) +\n      Math.pow(point0[1] - point1[1], 2) +\n      Math.pow(point0[2] - point1[2], 2)\n  );\n}\n\nexport {\n  getMeanPoints,\n  getMeanTouchPoints,\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaPoints,\n  getDeltaDistance,\n  getDeltaRotation,\n};\n","import { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { Swipe } from '../../enums/Touch';\n\nimport { EventTypes, ITouchPoints, IPoints, IDistance } from '../../types';\n\nimport getTouchEventPoints from './getTouchEventPoints';\nimport {\n  copyPoints,\n  copyPointsList,\n  getDeltaDistanceBetweenIPoints,\n  getDeltaDistance,\n  getDeltaPoints,\n  getMeanTouchPoints,\n  // getRotation\n} from '../../utilities/touch';\nimport { Settings } from '@cornerstonejs/core';\n\nconst runtimeSettings = Settings.getRuntimeSettings();\n\nconst {\n  TOUCH_START,\n  TOUCH_START_ACTIVATE,\n  TOUCH_PRESS,\n  TOUCH_DRAG,\n  TOUCH_END,\n  TOUCH_TAP,\n  TOUCH_SWIPE,\n} = Events;\n\ninterface ITouchTapListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  tapMaxDistance: number;\n  tapTimeout: ReturnType<typeof setTimeout>;\n  taps: number;\n  tapToleranceMs: number;\n}\n\ninterface ITouchStartListenerState {\n  element: HTMLDivElement;\n  renderingEngineId: string;\n  viewportId: string;\n  startPointsList: ITouchPoints[];\n  lastPointsList: ITouchPoints[];\n\n  // only trigger one touch event in the case the user puts down multiple fingers\n  isTouchStart: boolean;\n  startTime: Date;\n\n  // handle long press\n  pressTimeout: ReturnType<typeof setTimeout>;\n  pressDelay: number;\n  pressMaxDistance: number;\n  accumulatedDistance: IDistance;\n\n  // handle swipes\n  swipeDistanceThreshold: number;\n  swiped: boolean;\n  swipeToleranceMs: number;\n}\n\nconst zeroIPoint: IPoints = {\n  page: [0, 0],\n  client: [0, 0],\n  canvas: [0, 0],\n  world: [0, 0, 0],\n};\n\nconst zeroIDistance: IDistance = {\n  page: 0,\n  client: 0,\n  canvas: 0,\n  world: 0,\n};\n\n// STATE\nconst defaultState: ITouchStartListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  lastPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  isTouchStart: false,\n  startTime: null,\n\n  pressTimeout: null,\n  pressDelay: 700,\n  pressMaxDistance: 5,\n  accumulatedDistance: zeroIDistance,\n\n  swipeDistanceThreshold: 48,\n  swiped: false,\n  swipeToleranceMs: 300, // user has 300ms to swipe after touch start or no swipe will trigger\n};\n\n// TODO: these values should be configurable to handle different use cases such\n// as pen, left/right handed, index finger vs thumb, etc. These current values\n// assume thumb usage for single finger and index/middle finger for two finger\n// gestures in an attempt to cover the 90% use case.\nconst defaultTapState: ITouchTapListenerState = {\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  element: null,\n  startPointsList: [\n    {\n      ...zeroIPoint,\n      touch: null,\n    },\n  ],\n  taps: 0,\n  tapTimeout: null,\n  tapMaxDistance: 24,\n  tapToleranceMs: 300,\n};\n\nlet state: ITouchStartListenerState = JSON.parse(JSON.stringify(defaultState));\nlet tapState: ITouchTapListenerState = JSON.parse(\n  JSON.stringify(defaultTapState)\n);\n\nfunction triggerEventCallback(ele, name, eventDetail) {\n  return triggerEvent(ele, name, eventDetail);\n}\n\n/**\n * Listens to touch events from the DOM (touchstart, touchmove, touchend)\n * and depending on interaction and further interaction can emit the\n * following touch events:\n *\n * - TOUCH_START\n * - TOUCH_START_ACTIVATE\n * - TOUCH_PRESS\n * - TOUCH_DRAG (move while down)\n * - TOUCH_SWIPE\n * - TOUCH_END (also an end for multi touch)\n *\n * - TOUCH_TAP\n *\n * @param evt - The Touch event (touchstart).\n * @private\n */\nfunction touchStartListener(evt: TouchEvent) {\n  // if a user adds an extra finger when a touch/multi touch has already started\n  // don't trigger another touch.\n  state.element = <HTMLDivElement>evt.currentTarget;\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  // this prevents multiple start firing\n  if (state.isTouchStart) {\n    return;\n  }\n  // this will clear on touchstart and touchend\n  clearTimeout(state.pressTimeout);\n  state.pressTimeout = setTimeout(() => _onTouchPress(evt), state.pressDelay);\n\n  _onTouchStart(evt);\n  document.addEventListener('touchmove', _onTouchDrag); // also checks for swipe\n  document.addEventListener('touchend', _onTouchEnd); // also checks for tap\n}\n\n/**\n * _onTouchPress - Handle emission of touchstart events which are held down for a longer\n * period of time\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchPress(evt: TouchEvent) {\n  const totalDistance = state.accumulatedDistance.canvas;\n  if (totalDistance > state.pressMaxDistance) {\n    return;\n  }\n  const eventDetail: EventTypes.TouchPressEventDetail = {\n    event: evt, // touchstart native event\n    eventName: TOUCH_PRESS,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(state.lastPointsList),\n    startPoints: copyPoints(getMeanTouchPoints(state.startPointsList)),\n    lastPoints: copyPoints(getMeanTouchPoints(state.lastPointsList)),\n  };\n  triggerEventCallback(eventDetail.element, TOUCH_PRESS, eventDetail);\n}\n\n/**\n * _onTouchStart - Handle emission of touchstart events.\n *\n * @private\n * @param evt - The touch event (touchstart)\n */\nfunction _onTouchStart(evt: TouchEvent) {\n  state.isTouchStart = true;\n  state.startTime = new Date();\n  const startPointsList = getTouchEventPoints(evt, state.element);\n  const startPoints = getMeanTouchPoints(startPointsList);\n  const deltaPoints = zeroIPoint;\n  const deltaDistance = zeroIDistance;\n  // deltaRotation same as deltaDistance but values are theta\n  const eventDetail: EventTypes.TouchStartEventDetail = {\n    event: evt,\n    eventName: TOUCH_START,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: startPointsList,\n    lastPointsList: startPointsList,\n    currentPointsList: startPointsList,\n    startPoints: startPoints,\n    lastPoints: startPoints,\n    currentPoints: startPoints,\n    deltaPoints,\n    deltaDistance,\n    // deltaRotation\n  };\n\n  state.startPointsList = copyPointsList(eventDetail.startPointsList);\n  state.lastPointsList = copyPointsList(eventDetail.lastPointsList);\n  // by triggering TOUCH_START it checks if this is toolSelection, handle modification etc.\n  // of already existing tools\n  const eventDidPropagate = triggerEventCallback(\n    eventDetail.element,\n    TOUCH_START,\n    eventDetail\n  );\n\n  // if no tools responded to this event and prevented its default propagation behavior,\n  // create a new tool\n  if (eventDidPropagate) {\n    triggerEventCallback(\n      eventDetail.element,\n      TOUCH_START_ACTIVATE,\n      eventDetail\n    );\n  }\n}\n\n/**\n * _onTouchDrag - Handle emission of drag events whilst the touch is depressed.\n *\n * @private\n * @param evt - The touch event (touchmove)\n */\nfunction _onTouchDrag(evt: TouchEvent) {\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : zeroIPoint;\n\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : zeroIDistance;\n\n  const totalDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistance(currentPointsList, state.lastPointsList)\n      : zeroIDistance;\n\n  state.accumulatedDistance = {\n    page: state.accumulatedDistance.page + totalDistance.page,\n    client: state.accumulatedDistance.client + totalDistance.client,\n    canvas: state.accumulatedDistance.canvas + totalDistance.canvas,\n    world: state.accumulatedDistance.world + totalDistance.world,\n  };\n\n  /**\n   * this is can be uncommented to make dragging smoother. In the future, these values\n   * should be in a configuration file. There may also need to be different\n   * profiles for left handed and right handed thumb use. These values\n   * are currently optimized for left handed use.\n   *\n   * const clamp = (num) => Math.min(Math.max(num, -15), 10);\n   * const deltaDistanceClamped = \\{\n   *     page: clamp(deltaDistance.page),\n   *     client: clamp(deltaDistance.client),\n   *     canvas: clamp(deltaDistance.canvas),\n   *     world: clamp(deltaDistance.world),\n   * \\};\n   */\n\n  const eventDetail: EventTypes.TouchDragEventDetail = {\n    event: evt,\n    eventName: TOUCH_DRAG,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    deltaPoints: deltaPoints,\n    deltaDistance: deltaDistance,\n  };\n\n  triggerEventCallback(state.element, TOUCH_DRAG, eventDetail);\n\n  // check for swipe events\n  _checkTouchSwipe(evt, deltaPoints);\n\n  // Update the last points\n  state.lastPointsList = copyPointsList(currentPointsList);\n}\n\n/**\n * _onTouchEnd - Handle emission of touch end events\n *\n * @private\n * @param evt - The touch event.\n */\nfunction _onTouchEnd(evt: TouchEvent): void {\n  // in case it was a tap event we don't want to fire the cornerstone normalized\n  // touch end event if the touch start never happend\n  clearTimeout(state.pressTimeout);\n  const currentPointsList = getTouchEventPoints(evt, state.element);\n  const lastPointsList = _updateTouchEventsLastPoints(\n    state.element,\n    state.lastPointsList\n  );\n  const deltaPoints =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaPoints(currentPointsList, lastPointsList)\n      : getDeltaPoints(currentPointsList, currentPointsList);\n  const deltaDistance =\n    currentPointsList.length === lastPointsList.length\n      ? getDeltaDistanceBetweenIPoints(currentPointsList, lastPointsList)\n      : getDeltaDistanceBetweenIPoints(currentPointsList, currentPointsList);\n  const eventDetail: EventTypes.TouchEndEventDetail = {\n    event: evt,\n    eventName: TOUCH_END,\n    element: state.element,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    startPointsList: copyPointsList(state.startPointsList),\n    lastPointsList: copyPointsList(lastPointsList),\n    currentPointsList,\n    startPoints: getMeanTouchPoints(state.startPointsList),\n    lastPoints: getMeanTouchPoints(lastPointsList),\n    currentPoints: getMeanTouchPoints(currentPointsList),\n    deltaPoints,\n    deltaDistance,\n  };\n\n  triggerEventCallback(eventDetail.element, TOUCH_END, eventDetail);\n  _checkTouchTap(evt);\n\n  // reset to default state\n  state = JSON.parse(JSON.stringify(defaultState));\n  document.removeEventListener('touchmove', _onTouchDrag);\n  document.removeEventListener('touchend', _onTouchEnd);\n}\n\nfunction _checkTouchTap(evt: TouchEvent): void {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (currentTime - startTime > tapState.tapToleranceMs) {\n    return;\n  }\n\n  // first tap, initialize the state\n  if (tapState.taps === 0) {\n    tapState.element = state.element;\n    tapState.renderingEngineId = state.renderingEngineId;\n    tapState.viewportId = state.viewportId;\n    tapState.startPointsList = state.startPointsList;\n  }\n\n  // subsequent tap is on a different element\n  if (\n    tapState.taps > 0 &&\n    !(\n      tapState.element == state.element &&\n      tapState.renderingEngineId == state.renderingEngineId &&\n      tapState.viewportId == state.viewportId\n    )\n  ) {\n    return;\n  }\n\n  const currentPointsList = getTouchEventPoints(evt, tapState.element);\n  const distanceFromStart = getDeltaDistance(\n    currentPointsList,\n    tapState.startPointsList\n  ).canvas;\n\n  // if the tap is too far from starting tap, we can ignore it.\n  // TODO: in the case the user means to tap in two separate areas within the\n  // tapTolerance (300ms), the second tap will not trigger. This is because it\n  // is ignored below for simplicity to track multiple taps (double, triple etc)\n  // in order to support two separate single taps that occur < 300ms on the\n  // screen. One can create the concept of \"TapChains\". Our current implementation\n  // only supports a single tap chain on the screen. You can think of it as a\n  // region where the user has the option to perform unlimited multitaps as long\n  // as they are < the tapToleranceMs value. So a tap somewhere else on the screen\n  // that is > the tapMaxDistance will start a separate and new \"TapChain\".\n  if (distanceFromStart > tapState.tapMaxDistance) {\n    return;\n  }\n\n  clearTimeout(tapState.tapTimeout);\n  tapState.taps += 1;\n\n  tapState.tapTimeout = setTimeout(() => {\n    const eventDetail: EventTypes.TouchTapEventDetail = {\n      event: evt,\n      eventName: TOUCH_TAP,\n      element: tapState.element,\n      renderingEngineId: tapState.renderingEngineId,\n      viewportId: tapState.viewportId,\n      camera: {},\n      currentPointsList,\n      currentPoints: getMeanTouchPoints(currentPointsList),\n      taps: tapState.taps,\n    };\n    triggerEventCallback(eventDetail.element, TOUCH_TAP, eventDetail);\n    tapState = JSON.parse(JSON.stringify(defaultTapState));\n  }, tapState.tapToleranceMs);\n}\n\nfunction _checkTouchSwipe(evt: TouchEvent, deltaPoints: IPoints) {\n  const currentTime = new Date().getTime();\n  const startTime = state.startTime.getTime();\n  if (state.swiped || currentTime - startTime > state.swipeToleranceMs) {\n    return;\n  }\n  const [x, y] = deltaPoints.canvas;\n  const eventDetail: EventTypes.TouchSwipeEventDetail = {\n    event: evt,\n    eventName: TOUCH_SWIPE,\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    camera: {},\n    element: state.element,\n    swipe: null,\n  };\n  if (Math.abs(x) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = x > 0 ? Swipe.RIGHT : Swipe.LEFT;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n\n  if (Math.abs(y) > state.swipeDistanceThreshold) {\n    eventDetail.swipe = y > 0 ? Swipe.DOWN : Swipe.UP;\n    triggerEventCallback(eventDetail.element, TOUCH_SWIPE, eventDetail);\n    state.swiped = true;\n  }\n}\n\n/**\n * Recalculates the last world coordinate, as the linear transform from client\n * to world could be different if the camera was updated.\n * @param element - The HTML element\n * @param lastPoints - The last points\n */\nfunction _updateTouchEventsLastPoints(\n  element: HTMLDivElement,\n  lastPoints: ITouchPoints[]\n): ITouchPoints[] {\n  const { viewport } = getEnabledElement(element);\n  // Need to update the world point to be calculated from the current reference frame,\n  // Which might have changed since the last interaction.\n  return lastPoints.map((lp) => {\n    const world = viewport.canvasToWorld(lp.canvas);\n    return {\n      page: lp.page,\n      client: lp.client,\n      canvas: lp.canvas,\n      world,\n      touch: lp.touch,\n    };\n  });\n}\n\nexport default touchStartListener;\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\n\n/**\n * Removes touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to remove event listeners from.\n */\nfunction disable(element: HTMLDivElement): void {\n  preventGhostClick.disable(element);\n  element.removeEventListener('touchstart', touchStartListener);\n}\n\n/**\n * Registers touch event listeners for native touch event. Enables\n * vtk.js tools flavored events that build on top of existing events to\n * provide more helpful information.\n *\n * @private\n * @param element - The DOM element to register event listeners on.\n */\nfunction enable(element: HTMLDivElement): void {\n  // Prevent handlers from being attached multiple times\n  disable(element);\n  preventGhostClick.enable(element);\n  element.addEventListener('touchstart', touchStartListener, {\n    passive: false,\n  });\n}\n\nexport default {\n  enable,\n  disable,\n};\n","import _cloneDeep from 'lodash.clonedeep';\nimport { getEnabledElement, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { KeyDownEventDetail, KeyUpEventDetail } from '../../types/EventTypes';\n\ninterface IKeyDownListenerState {\n  renderingEngineId: string;\n  viewportId: string;\n  key: string | null;\n  keyCode: number | null;\n  element: HTMLDivElement;\n}\n\nconst defaultState: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\nlet state: IKeyDownListenerState = {\n  //\n  renderingEngineId: undefined,\n  viewportId: undefined,\n  //\n  key: undefined,\n  keyCode: undefined,\n  element: null,\n};\n\n/**\n * Normalizes the keyboard event and triggers KEY_DOWN event from CornerstoneTools3D events\n * @param evt - DOM Keyboard event\n */\nfunction keyListener(evt: KeyboardEvent): void {\n  state.element = <HTMLDivElement>evt.currentTarget;\n\n  const enabledElement = getEnabledElement(state.element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  state.renderingEngineId = renderingEngineId;\n  state.viewportId = viewportId;\n  state.key = evt.key;\n  state.keyCode = evt.keyCode;\n\n  evt.preventDefault();\n  const eventDetail: KeyDownEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n\n    // detail: evt,\n    // Todo: mouse event points can be used later for placing tools with a key\n    // e.g., putting an arrow/probe/etc. on the mouse position. Another use case\n    // hovering and deleting the tool\n    // points: getMouseEventPoints(evt),\n  };\n\n  triggerEvent(eventDetail.element, Events.KEY_DOWN, eventDetail);\n\n  document.addEventListener('keyup', _onKeyUp);\n  document.addEventListener('visibilitychange', _onVisibilityChange);\n\n  // Todo: handle combination of keys\n  state.element.removeEventListener('keydown', keyListener);\n}\n\n/**\n * Whenever the visibility (i.e. tab focus) changes such that the tab is NOT the\n * active tab, reset the modifier key.\n */\nfunction _onVisibilityChange(): void {\n  document.removeEventListener('visibilitychange', _onVisibilityChange);\n  if (document.visibilityState === 'hidden') {\n    resetModifierKey();\n  }\n}\n\nfunction _onKeyUp(evt: KeyboardEvent): void {\n  const eventDetail: KeyUpEventDetail = {\n    renderingEngineId: state.renderingEngineId,\n    viewportId: state.viewportId,\n    element: state.element,\n    key: state.key,\n    keyCode: state.keyCode,\n    // detail: evt,\n  };\n\n  // Remove our temporary handlers\n  document.removeEventListener('keyup', _onKeyUp);\n  document.removeEventListener('visibilitychange', _onVisibilityChange);\n  state.element.addEventListener('keydown', keyListener);\n\n  // Restore `state` to `defaultState`\n  state = _cloneDeep(defaultState);\n  triggerEvent(eventDetail.element, Events.KEY_UP, eventDetail);\n}\n\nexport function getModifierKey(): number | undefined {\n  return state.keyCode;\n}\n\nexport function resetModifierKey(): void {\n  state.keyCode = undefined;\n}\n\nexport default keyListener;\n","import keyDownListener, { getModifierKey } from './keyDownListener';\n\nfunction enable(element: HTMLDivElement): void {\n  disable(element);\n  element.addEventListener('keydown', keyDownListener);\n}\n\nfunction disable(element: HTMLDivElement): void {\n  element.removeEventListener('keydown', keyDownListener);\n}\n\nexport default {\n  enable,\n  disable,\n  getModifierKey,\n};\n","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { state } from '../store';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\n/**\n * Returns the SVG drawing helper for the given HTML element.\n * @param element - The HTML element to get the SVG drawing helper for.\n * @private\n */\nfunction getSvgDrawingHelper(element: HTMLDivElement): SVGDrawingHelper {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId, renderingEngineId } = enabledElement;\n  const canvasHash = `${viewportId}:${renderingEngineId}`;\n  const svgLayerElement = _getSvgLayer(element);\n\n  // Reset touched\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    state.svgNodeCache[canvasHash][cacheKey].touched = false;\n  });\n\n  return {\n    svgLayerElement: svgLayerElement,\n    svgNodeCacheForCanvas: state.svgNodeCache,\n    getSvgNode: getSvgNode.bind(this, canvasHash),\n    appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n    setNodeTouched: setNodeTouched.bind(this, canvasHash),\n    clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n  };\n}\n\n/**\n *\n * @param element\n * @private\n */\nfunction _getSvgLayer(element) {\n  const viewportElement = `.${VIEWPORT_ELEMENT}`;\n  const internalDivElement = element.querySelector(viewportElement);\n\n  // Using :scope to make sure the right svg layer is selected otherwise it\n  // may select one from a nested viewport (eg: AdvancedMagnifyTool).\n  const svgLayer = internalDivElement.querySelector(':scope > .svg-layer');\n\n  return svgLayer;\n}\n\nfunction getSvgNode(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    return state.svgNodeCache[canvasHash][cacheKey].domRef;\n  }\n}\n\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return null;\n  }\n\n  state.svgNodeCache[canvasHash][cacheKey] = {\n    touched: true,\n    domRef: svgNode,\n  };\n\n  svgLayerElement.appendChild(svgNode);\n}\n\nfunction setNodeTouched(canvasHash, cacheKey) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  if (state.svgNodeCache[canvasHash][cacheKey]) {\n    state.svgNodeCache[canvasHash][cacheKey].touched = true;\n  }\n}\n\nfunction clearUntouched(svgLayerElement, canvasHash) {\n  // If state has been reset\n  if (!state.svgNodeCache[canvasHash]) {\n    return;\n  }\n\n  Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n    const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n\n    if (!cacheEntry.touched && cacheEntry.domRef) {\n      svgLayerElement.removeChild(cacheEntry.domRef);\n      delete state.svgNodeCache[canvasHash][cacheKey];\n    }\n  });\n}\n\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\n\nfunction draw(\n  element: HTMLDivElement,\n  fn: (svgDrawingElement: any) => any\n): void {\n  const svgDrawingHelper = getSvgDrawingHelper(element);\n\n  // Save...\n  fn(svgDrawingHelper);\n  // Restore...\n\n  svgDrawingHelper.clearUntouched();\n}\n\nexport default draw;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a rendering engine Id and a viewport Id, return the tool group that\n * contains that rendering engine and viewport. Note: A viewport can only be\n * associated with a single tool group. You cannot have a viewport that belongs\n * to multiple tool groups. To achieve so, create a new viewport and a new toolGroup\n * for it. This will not impact memory usage much as the volume textures are\n * shared across all viewports rendering the same image.\n *\n * @param viewportId - The Id of the viewport that the tool is being\n * added to.\n * @param renderingEngineId - The Id of the rendering engine that the\n * tool group is associated with.\n * @returns A tool group.\n */\nfunction getToolGroupForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): IToolGroup | undefined {\n  const toolGroupFilteredByIds = state.toolGroups.filter((tg) =>\n    tg.viewportsInfo.some(\n      (vp) =>\n        vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)\n    )\n  );\n\n  if (!toolGroupFilteredByIds.length) {\n    return;\n  }\n\n  if (toolGroupFilteredByIds.length > 1) {\n    throw new Error(\n      `Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`\n    );\n  }\n\n  return toolGroupFilteredByIds[0];\n}\n\nexport default getToolGroupForViewport;\n","import { ToolGroupManager } from '../store';\nimport { ToolModes } from '../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Finds the enabled element, and iterates over the tools inside its\n * toolGroup. Returns the list of tool instances that are valid based\n * on the provided tool mode.\n *\n * @param element Canvas element\n * @param modesFilter tool modes: active, passive, enabled, disabled\n * @returns enabled tool instances\n */\nexport default function getToolsWithModesForElement(\n  element: HTMLDivElement,\n  modesFilter: ModesFilter\n) {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngineId, viewportId } = enabledElement;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    /* filter out tools that don't have options */\n    if (!toolOptions) {\n      continue;\n    }\n\n    if (modesFilter.includes(toolOptions.mode)) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import {\n  getEnabledElement,\n  triggerEvent,\n  getRenderingEngine,\n} from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../enums';\nimport { draw as drawSvg } from '../drawingSvg';\nimport getToolsWithModesForElement from './getToolsWithModesForElement';\nimport { AnnotationRenderedEventDetail } from '../types/EventTypes';\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * AnnotationRenderingEngine is a class that is responsible for rendering\n * annotations defined in the renderAnnotation method of annotation tools on the page.\n * It mimics the RenderingEngine in the Cornerstone Core. Here it uses requestAnimationFrame\n * is used to render annotations by calling renderAnnotations() on each enabled tool. Note: This\n * is a Singleton class and should not be instantiated directly. To trigger\n * an annotation render for an HTML element containing a viewport you can use\n *\n * ```\n * triggerAnnotationRender(element)\n * ```\n */\nclass AnnotationRenderingEngine {\n  public hasBeenDestroyed: boolean;\n  private _needsRender: Set<HTMLDivElement> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  private _viewportElements: Map<string, HTMLDivElement>;\n\n  constructor() {\n    this._viewportElements = new Map();\n  }\n\n  /**\n   * Add the viewport's HTMLDivElement to the viewports for rendering. This method\n   * just informs the annotationRenderingEngine about the viewport and\n   * does not initiate a render.\n   * @param viewportId - Viewport Unique identifier\n   * @param element - HTMLDivElement\n   */\n  public addViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.set(viewportId, element);\n  }\n\n  /**\n   * Remove the viewport's HTMLDivElement from subsequent annotation renders\n   * @param viewportId - Viewport Unique identifier\n   */\n  public removeViewportElement(viewportId: string, element: HTMLDivElement) {\n    this._viewportElements.delete(viewportId);\n\n    // delete element from needsRender if element exist\n    this._needsRender.delete(element);\n\n    // I don' think there is any disadvantage to canceling the animation frame\n    // and resetting the flags on viewport's element removal, since the removeVIewportElement\n    // might be as a result of reEnabling the element (in re-enable we disable first), hence the need to render the\n    // new one while removing the old one\n    this._reset();\n  }\n\n  /**\n   * It tells the AnnotationRenderingEngine to render the viewport element the next\n   * time it renders.\n   *\n   * @param element - The element to render.\n   */\n  public renderViewport(element: HTMLDivElement): void {\n    this._setViewportsToBeRenderedNextFrame([element]);\n  }\n\n  /**\n   * _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _renderFlaggedViewports = () => {\n    this._throwIfDestroyed();\n\n    const elements = Array.from(this._viewportElements.values());\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (this._needsRender.has(element)) {\n        this._triggerRender(element);\n\n        // This viewport has been rendered, we can remove it from the set\n        this._needsRender.delete(element);\n\n        // If there is nothing left that is flagged for rendering, stop here\n        // and allow RAF to be called again\n        if (this._needsRender.size === 0) {\n          this._animationFrameSet = false;\n          this._animationFrameHandle = null;\n          return;\n        }\n      }\n    }\n  };\n\n  private _setAllViewportsToBeRenderedNextFrame() {\n    const elements = [...this._viewportElements.values()];\n\n    elements.forEach((element) => {\n      this._needsRender.add(element);\n    });\n\n    this._renderFlaggedViewports();\n  }\n\n  private _setViewportsToBeRenderedNextFrame(elements: HTMLDivElement[]) {\n    const elementsEnabled = [...this._viewportElements.values()];\n\n    // Add the viewports to the set of flagged viewports\n    elements.forEach((element) => {\n      // only enabledElement need to render\n      if (elementsEnabled.indexOf(element) !== -1) {\n        this._needsRender.add(element);\n      }\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   * _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedViewports\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  _triggerRender(element) {\n    const enabledElement = getEnabledElement(element);\n\n    if (!enabledElement) {\n      console.warn('Element has been disabled');\n      return;\n    }\n\n    const renderingEngine = getRenderingEngine(\n      enabledElement.renderingEngineId\n    );\n    if (!renderingEngine) {\n      console.warn('rendering Engine has been destroyed');\n      return;\n    }\n\n    const enabledTools = getToolsWithModesForElement(element, [\n      Active,\n      Passive,\n      Enabled,\n    ]);\n\n    const { renderingEngineId, viewportId } = enabledElement;\n    const eventDetail: AnnotationRenderedEventDetail = {\n      element,\n      renderingEngineId,\n      viewportId,\n    };\n\n    // const enabledToolsWithAnnotations = enabledTools.filter((tool) => {\n    //   const annotations = getAnnotations(tool.getToolName(), {FrameOfReferenceUID});\n    //   return annotations && annotations.length;\n    // });\n\n    drawSvg(element, (svgDrawingHelper) => {\n      let anyRendered = false;\n      const handleDrawSvg = (tool) => {\n        if (tool.renderAnnotation) {\n          const rendered = tool.renderAnnotation(\n            enabledElement,\n            svgDrawingHelper\n          );\n          anyRendered = anyRendered || rendered;\n        }\n      };\n\n      /**\n       * We should be able to filter tools that don't have annotations, but\n       * currently some of tools have renderAnnotation method BUT\n       * don't keep annotation in the state, so if we do so, the tool will not be\n       * rendered.\n       */\n      enabledTools.forEach(handleDrawSvg);\n\n      if (anyRendered) {\n        triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n      }\n    });\n  }\n\n  /**\n   * _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n\n    this._setAllViewportsToBeRenderedNextFrame();\n  }\n}\n\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\n\n/**\n * It triggers the rendering of the annotations for the given HTML element using\n * the `AnnotationRenderingEngine`\n * @param element - The element to render the annotation on.\n */\nfunction triggerAnnotationRender(element: HTMLDivElement): void {\n  annotationRenderingEngine.renderViewport(element);\n}\n\nexport { annotationRenderingEngine, triggerAnnotationRender };\n\nexport default triggerAnnotationRender;\n","import { Enums, Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\n\n/**\n *  When the image is rendered, check what tools can be rendered for this element.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `renderAnnotation` method, then we render them.\n * - Note that these tools don't necessarily have to be instances of  `AnnotationTool`,\n *   Any tool may register a `renderAnnotation` method (e.g. a tool that displays an overlay).\n *\n * @param evt - The normalized IMAGE_RENDERED event.\n */\nconst onImageRendered = function (evt: Types.EventTypes.ImageRenderedEvent) {\n  // TODO: should we do this on camera modified instead of image rendered?\n  // e.g. no need to re-render annotations if only the VOI has changed\n  triggerAnnotationRender(evt.detail.element);\n};\n\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement): void {\n  element.removeEventListener(\n    Enums.Events.IMAGE_RENDERED,\n    onImageRendered as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized mouse event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized mouseDown event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  modesFilter: ModesFilter,\n  evtButton?: any\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button - we match those with\n    // any modifier keys too since they can be passively interacted with\n    const correctBinding =\n      evtButton != null && // not null or undefined\n      tool.bindings.length &&\n      tool.bindings.some((binding) => binding.mouseButton === evtButton);\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      // Should not filter by event's button\n      // or should, and the tool binding includes the event's button\n      (!evtButton || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When the camera is modified, check what tools need to react to this.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onCameraModified` method, we call it.\n *\n * @param evt - The normalized camera modified event.\n */\nconst onCameraModified = function (evt: Types.EventTypes.CameraModifiedEvent) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onCameraModified) {\n      tool.onCameraModified(evt);\n    }\n  });\n};\n\nconst enable = function (element) {\n  element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nconst disable = function (element) {\n  element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * When image spacing is calibrated modify the annotations for all of its tools\n * to consider the new calibration info.\n *\n * - First we get all tools which are active, passive or enabled on the element.\n * - If any of these tools have a `onImageSpacingCalibrated` method, we call it.\n *\n * @param evt - The normalized image calibration event.\n */\nconst onImageSpacingCalibrated = function (\n  evt: Types.EventTypes.ImageSpacingCalibratedEvent\n) {\n  // @ts-ignore\n  const enabledTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n    Enabled,\n  ]);\n\n  enabledTools.forEach((tool) => {\n    if (tool.onImageSpacingCalibrated) {\n      tool.onImageSpacingCalibrated(evt);\n    }\n  });\n};\n\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(\n    Enums.Events.IMAGE_SPACING_CALIBRATED,\n    onImageSpacingCalibrated as EventListener\n  );\n};\n\nexport default {\n  enable,\n  disable,\n};\n","import { state, ToolGroupManager } from '../../store';\nimport ToolModes from '../../enums/ToolModes';\n\nconst { Active } = ToolModes;\n\n/**\n * @function customCallbackHandler This is used as a generic event handler for tool events\n * on viewports. It:\n *\n * - Finds an \"active\" tool with:\n *    - A matching `handlerType`\n *    - A matching `customFunction` on its tool instance\n *\n * Then calls that custom function with raised event.\n *\n * @param handlerType - 'Mouse' | 'Touch' | 'MouseWheel'\n * @param customFunction - Function name that's expected to live on implementing\n *   (and event handling) active tool ex. 'doubleClickCallback'\n * @param evt\n */\nexport default function customCallbackHandler(\n  handlerType: string,\n  customFunction: string,\n  evt\n) {\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return false;\n  }\n\n  // TODO: Filter tools by interaction type?\n  /**\n   * Iterate tool group tools until we find a tool that is:\n   * - active\n   * - has the custom callback function\n   *\n   */\n  let activeTool;\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n    // TODO: Should be getter\n    const toolInstance = toolGroup.getToolInstance(toolName);\n\n    if (\n      // TODO: Should be enum?\n      tool.mode === Active &&\n      // TODO: Should be implements interface?\n      // Weird that we need concrete instance. Other options to filter / get callback?\n      typeof toolInstance[customFunction] === 'function'\n    ) {\n      activeTool = toolGroup.getToolInstance(toolName);\n      break;\n    }\n  }\n\n  if (!activeTool) {\n    return;\n  }\n\n  activeTool[customFunction](evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse click events. Uses `customCallbackHandler` to fire\n * the `mouseClickCallback` function on active tools.\n */\nconst mouseClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'mouseClickCallback'\n);\n\nexport default mouseClick;\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationsPair,\n  ToolsWithMoveableHandles,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools, returning only tools with moveable handles at the mouse location that are not locked\n *\n * @param element - The element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction (e.g. 'mouse' or 'touch')\n * @returns The filtered array.\n */\nexport default function filterToolsWithMoveableHandles(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolsWithMoveableHandles[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n  const toolsWithMoveableHandles = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const handle = tool.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        proximity\n      );\n\n      if (handle) {\n        toolsWithMoveableHandles.push({\n          tool,\n          annotation,\n          handle,\n        });\n        break;\n      }\n    }\n  });\n\n  return toolsWithMoveableHandles;\n}\n","import { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport { ToolAnnotationsPair } from '../types/InternalToolTypes';\nimport type AnnotationTool from '../tools/base/AnnotationTool';\nimport BaseTool from '../tools/base/BaseTool';\nimport { getEnabledElement } from '@cornerstonejs/core';\n\n/**\n * Filters an array of tools, returning only tools which have annotation.\n *\n * @param element - The cornerstone3D enabled element.\n * @param tools - The array of tools to check.\n *\n * @returns The array of tools with their found annotations.\n */\nexport default function filterToolsWithAnnotationsForElement(\n  element: HTMLDivElement,\n  tools: AnnotationTool[]\n): ToolAnnotationsPair[] {\n  const result = [];\n  for (let i = 0; i < tools.length; i++) {\n    const tool = tools[i];\n\n    if (!tool) {\n      console.warn('undefined tool in filterToolsWithAnnotationsForElement');\n      continue;\n    }\n\n    let annotations = getAnnotations(\n      (tool.constructor as typeof BaseTool).toolName,\n      element\n    );\n\n    if (!annotations?.length) {\n      continue;\n    }\n\n    if (typeof tool.filterInteractableAnnotationsForElement === 'function') {\n      // If the tool has a annotations filter (e.g. with in-plane-annotations-only filtering), use it.\n      annotations = tool.filterInteractableAnnotationsForElement(\n        element,\n        annotations\n      );\n    }\n\n    if (annotations.length > 0) {\n      result.push({ tool, annotations });\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport {\n  ToolAnnotationPair,\n  ToolAnnotationsPair,\n} from '../types/InternalToolTypes';\n\n/**\n * Filters an array of tools with annotations, returning the first annotation\n * for each tool that is moveable and at the mouse location. It results in\n * one annotation per tool.\n *\n *\n * @param element - The HTML element\n * @param ToolAndAnnotations - The input tool array.\n * @param canvasCoords - The coordinates of the mouse position.\n * @param interactionType - The type of interaction that is taking place.\n * @returns The filtered array containing ToolAndAnnotation\n */\nexport default function filterMoveableAnnotationTools(\n  element: HTMLDivElement,\n  ToolAndAnnotations: ToolAnnotationsPair[],\n  canvasCoords: Types.Point2,\n  interactionType = 'mouse'\n): ToolAnnotationPair[] {\n  const proximity = interactionType === 'touch' ? 36 : 6;\n\n  // TODO - This could get pretty expensive pretty quickly. We don't want to fetch the camera\n  // And do world to canvas on each coord.\n\n  // We want to produce a matrix from canvas to world for the viewport and just do a matrix operation on each handle.\n  // This could still be expensive for ROIs, but we probably shouldn't have \"handles\" for them anyway.\n\n  const moveableAnnotationTools = [];\n\n  ToolAndAnnotations.forEach(({ tool, annotations }) => {\n    for (const annotation of annotations) {\n      if (annotation.isLocked || !annotation.isVisible) {\n        continue;\n      }\n\n      const near = tool.isPointNearTool(\n        element,\n        annotation,\n        canvasCoords,\n        proximity,\n        interactionType\n      );\n\n      if (near) {\n        moveableAnnotationTools.push({\n          tool,\n          annotation,\n        });\n        break;\n      }\n    }\n  });\n\n  return moveableAnnotationTools;\n}\n","/**\n * Mouse This enum enumerates the different buttons returned by `.buttons` on the mouse event.\n * These values are used when setting a tool active in a tool group.\n *\n * See also: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n */\nenum MouseBindings {\n  /** usually the left button */\n  Primary = 1,\n  /** usually the right button */\n  Secondary = 2,\n  Primary_And_Secondary = 3,\n  /** usually mouse wheel button */\n  Auxiliary = 4,\n  Primary_And_Auxiliary = 5,\n  Secondary_And_Auxiliary = 6,\n  Primary_And_Secondary_And_Auxiliary = 7,\n  /** usually \"Browser Back\" button */\n  Fourth_Button = 8,\n  /** usually \"Browser Forward\" button */\n  Fifth_Button = 16,\n}\n\nenum KeyboardBindings {\n  Shift = 16,\n  Ctrl = 17,\n  Alt = 18,\n  Meta = 91,\n  ShiftCtrl = 1617,\n  ShiftAlt = 1618,\n  ShiftMeta = 1691,\n  CtrlAlt = 1718,\n  CtrlMeta = 1791,\n  AltMeta = 1891,\n}\n\nexport { MouseBindings, KeyboardBindings };\n","import { KeyboardBindings as kb } from '../../enums';\n\n/**\n * Gets the mouse modifier key from a mouse event.\n * Supports Shift, Ctrl, Alt, in singly and in combinations of 2\n * Supports Meta singly.\n */\nconst getMouseModifierKey = (evt) => {\n  // The logic is a hard coded key mapping\n  if (evt.shiftKey) {\n    if (evt.ctrlKey) {\n      return kb.ShiftCtrl;\n    }\n    if (evt.altKey) {\n      return kb.ShiftAlt;\n    }\n    if (evt.metaKey) {\n      return kb.ShiftMeta;\n    }\n    return kb.Shift;\n  }\n  if (evt.ctrlKey) {\n    if (evt.altKey) {\n      return kb.CtrlAlt;\n    }\n    if (evt.metaKey) {\n      return kb.CtrlMeta;\n    }\n    return kb.Ctrl;\n  }\n  if (evt.altKey) {\n    return (evt.metaKey && kb.AltMeta) || kb.Alt;\n  }\n  if (evt.metaKey) {\n    return kb.Meta;\n  }\n  return undefined;\n};\n\nexport default getMouseModifierKey;\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our MouseEvent's `buttons`. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The event dispatcher mouse event.\n *\n * @returns tool\n */\nexport default function getActiveToolForMouseEvent(\n  evt: EventTypes.NormalizedMouseEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForMouseEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const mouseEvent = evt.detail.event;\n\n  // If any keyboard modifier key is also pressed - get the mouse version\n  // first since it handles combinations, while the key event handles non-modifier\n  // keys.\n  const modifierKey =\n    getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some((binding) => {\n        return (\n          binding.mouseButton ===\n            (mouseEvent ? mouseEvent.buttons : defaultMousePrimary) &&\n          binding.modifierKey === modifierKey\n        );\n      });\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\n// Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getToolsWithActionsForMouseEvent from '../shared/getToolsWithActionsForMouseEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * Look for active or passive annotations with an action that could handle the\n * event based on the bindings and invoke the first one found.\n *\n * @param evt - The normalized mouseDown event.\n * @returns True if an action has executed or false otherwise\n */\nexport default function mouseDownAnnotationAction(\n  evt: EventTypes.MouseDownEventType\n): boolean {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return false;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { canvas: canvasCoords } = eventDetail.currentPoints;\n\n  if (!enabledElement) {\n    return false;\n  }\n\n  // Find all tools that might respond to this mouse down\n  const toolsWithActions = getToolsWithActionsForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const tools = Array.from(toolsWithActions.keys());\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    tools\n  );\n\n  // Only moveable annotations (unlocked, visible and close to the canvas coordinates) may trigger actions\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = moveableAnnotationTools[0];\n    const action = toolsWithActions.get(tool);\n    const method =\n      typeof action.method === 'string' ? tool[action.method] : action.method;\n\n    method.call(tool, evt, annotation);\n\n    return true;\n  }\n\n  return false;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport mouseDownAnnotationAction from './mouseDownAnnotationAction';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * When the mouse is depressed we check which entities can process these events in the following manner:\n *\n * - First we get the `activeTool` for the mouse button pressed.\n * - If the `activeTool` has a `preMouseDownCallback`, this is called. If the callback returns `true`,\n *   the event does not propagate further.\n * - Next we get all tools which are active or passive (`activeAndPassiveTools`), as annotation. for these tools could\n *   possibly catch and handle these events. We then filter the `activeAndPassiveTools` using `filterToolsWithAnnotationsForElement`, which filters tools with annotations\n *   for this frame of reference. Optionally a tool can employ a further filtering (via a\n *   `filterInteractableAnnotationsForElement` callback) for tools interactable within the current camera view\n *   (e.g. tools that only render when viewed from a certain direction).\n * - Next we check if any handles are interactable for each tool (`filterToolsWithMoveableHandles`). If interactable\n *   handles are found, the first tool/handle found consumes the event and the event does not propagate further.\n * - Next we check any tools are interactable (e.g. moving an entire length annotation rather than one of its handles:\n *   `filterMoveableAnnotationTools`). If interactable tools are found, the first tool found consumes the event and the\n *   event does not propagate further.\n * - If the `activeTool` has `postMouseDownCallback`, this is called.  If the callback returns `true`,\n *   the event does not propagate further.\n * - Finally, look for annotations actions that could handle the event such as showing a dropdown to allow the user\n *   change the magnifying glass zoom factor.\n *\n * If the event is not consumed the event will bubble to the `mouseDownActivate` handler.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDown(evt: EventTypes.MouseDownEventType) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  // Check for preMouseDownCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.preMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  // Find all tools that might respond to this mouse down\n  const isPrimaryClick = evt.detail.event.buttons === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForMouseEvent(\n    evt,\n    [Active],\n    evt.detail.event.buttons\n  );\n  const passiveToolsIfEventWasPrimaryMouseButton = isPrimaryClick\n    ? getToolsWithModesForMouseEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryMouseButton || []),\n  ];\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this mouse down\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // Preserve existing selections when shift key is pressed\n  const isMultiSelect = !!evt.detail.event.shiftKey;\n\n  // If there are annotation tools whose handle is near the mouse, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Mouse');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the mouse, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'mouse'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Mouse', canvasCoords);\n\n    return;\n  }\n\n  // Run the postMouseDownCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postMouseDownCallback === 'function') {\n    const consumedEvent = activeTool.postMouseDownCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  const actionExecuted = mouseDownAnnotationAction(evt);\n\n  if (actionExecuted) {\n    return;\n  }\n\n  // Don't stop propagation so that mouseDownActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { ToolAction, EventTypes } from '../../types';\n\nimport { keyEventListener } from '../../eventListeners';\nimport getMouseModifier from './getMouseModifier';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the mouse event and a list of tool modes, find all tool instances\n * with actions that were added to the tool group associated with the viewport\n * that triggered the event.\n *\n * @param evt - mouseDown event triggered by a cornerstone viewport\n * @param toolModes - List of tool modes used to filter the tools registered\n *                    in the viewport's tool group\n */\nexport default function getToolsWithActionsForMouseEvent(\n  evt: EventTypes.MouseMoveEventType,\n  toolModes: ToolModes[]\n): Map<any, ToolAction> {\n  const toolsWithActions = new Map();\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return toolsWithActions;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n  const mouseEvent = evt.detail.event;\n  const mouseButton = mouseEvent?.buttons ?? defaultMousePrimary;\n  const modifierKey =\n    getMouseModifier(mouseEvent) || keyEventListener.getModifierKey();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.getToolInstance(toolName);\n    const actions = tool.configuration?.actions;\n\n    if (!actions?.length || !toolModes.includes(tool.mode)) {\n      continue;\n    }\n\n    const action = actions.find(\n      (action) =>\n        action.bindings.length &&\n        action.bindings.some(\n          (binding) =>\n            binding.mouseButton === mouseButton &&\n            binding.modifierKey === modifierKey\n        )\n    );\n\n    if (action) {\n      toolsWithActions.set(tool, action);\n    }\n  }\n\n  return toolsWithActions;\n}\n","import { state } from '../../store';\nimport getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { EventTypes } from '../../types';\n\n/**\n * If the `mouseDown` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * mouse button pressed.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDownActivate(\n  evt: EventTypes.MouseDownActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'mouse');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * @function mouseDoubleClick - Event handler for mouse double click events. Uses `customCallbackHandler` to fire\n * the `doubleClickCallback` function on active tools.\n */\nconst mouseDoubleClick = customCallbackHandler.bind(\n  null,\n  'Mouse',\n  'doubleClickCallback'\n);\n\nexport default mouseDoubleClick;\n","import getActiveToolForMouseEvent from '../shared/getActiveToolForMouseEvent';\nimport { state } from '../../store';\nimport { MouseDragEventType } from '../../types/EventTypes';\n\n/**\n * mouseDrag - Event handler for mouse drag events. Fires the `mouseDragCallback`\n * function on active tools.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseDrag(evt: MouseDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForMouseEvent(evt);\n\n  const noFoundToolOrDoesNotHaveMouseDragCallback =\n    !activeTool || typeof activeTool.mouseDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveMouseDragCallback) {\n    return;\n  }\n\n  activeTool.mouseDragCallback(evt);\n}\n","// // State\nimport { state } from '../../store';\nimport { ToolModes } from '../../enums';\n\n// // Util\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport getToolsWithModesForMouseEvent from '../shared/getToolsWithModesForMouseEvent';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport { MouseMoveEventType } from '../../types/EventTypes';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * mouseMove - On mouse move when not dragging, fire tools `mouseMoveCallback`s.\n * This is mostly used to update the [un]hover state\n * of a tool.\n *\n * @param evt - The normalized mouseDown event.\n */\nexport default function mouseMove(evt: MouseMoveEventType) {\n  // Tool interactions when mouse moved are handled inside each tool.\n  // This function is mostly used to update the [un]hover state\n  if (state.isInteractingWithTool || state.isMultiPartToolActive) {\n    return;\n  }\n\n  const activeAndPassiveTools = getToolsWithModesForMouseEvent(evt, [\n    Active,\n    Passive,\n  ]);\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Annotation tool specific\n  const toolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    activeAndPassiveTools\n  );\n\n  const toolsWithoutAnnotations = activeAndPassiveTools.filter((tool) => {\n    const doesNotHaveAnnotations = !toolsWithAnnotations.some(\n      (toolAndAnnotation) =>\n        toolAndAnnotation.tool.getToolName() === tool.getToolName()\n    );\n\n    return doesNotHaveAnnotations;\n  });\n\n  let annotationsNeedToBeRedrawn = false;\n\n  for (const { tool, annotations } of toolsWithAnnotations) {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      annotationsNeedToBeRedrawn =\n        tool.mouseMoveCallback(evt, annotations) || annotationsNeedToBeRedrawn;\n    }\n  }\n\n  // Run mouse move handlers for non-annotation tools\n  toolsWithoutAnnotations.forEach((tool) => {\n    if (typeof tool.mouseMoveCallback === 'function') {\n      tool.mouseMoveCallback(evt);\n    }\n  });\n\n  // Annotation activation status changed, redraw the annotations\n  if (annotationsNeedToBeRedrawn === true) {\n    triggerAnnotationRender(element);\n  }\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * mouseClick - Event handler for mouse up events. Uses `customCallbackHandler` to fire\n * the `mouseUpCallback` function on active tools.\n */\nconst mouseUp = customCallbackHandler.bind(null, 'Mouse', 'mouseUpCallback');\n\nexport default mouseUp;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * Event handler for mouse wheel events. Uses `customCallbackHandler` to fire\n * the `mouseWheelCallback` function on active tools.\n */\nconst mouseWheel = customCallbackHandler.bind(\n  null,\n  'MouseWheel',\n  'mouseWheelCallback'\n);\n\nexport default mouseWheel;\n","import Events from '../enums/Events';\n\nimport {\n  mouseClick,\n  mouseDown,\n  mouseDownActivate,\n  mouseDoubleClick,\n  mouseDrag,\n  mouseMove,\n  mouseUp,\n  mouseWheel,\n} from './mouseEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.addEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.addEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.addEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.addEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.addEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.addEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.addEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.MOUSE_CLICK, mouseClick as EventListener);\n  element.removeEventListener(Events.MOUSE_DOWN, mouseDown as EventListener);\n  element.removeEventListener(\n    Events.MOUSE_DOWN_ACTIVATE,\n    mouseDownActivate as EventListener\n  );\n  element.removeEventListener(\n    Events.MOUSE_DOUBLE_CLICK,\n    mouseDoubleClick as EventListener\n  );\n  element.removeEventListener(Events.MOUSE_DRAG, mouseDrag as EventListener);\n  element.removeEventListener(Events.MOUSE_MOVE, mouseMove as EventListener);\n  element.removeEventListener(Events.MOUSE_UP, mouseUp as EventListener);\n  element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel as EventListener);\n};\n\nconst mouseToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default mouseToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes, MouseBindings } from '../../enums';\nimport { keyEventListener } from '../../eventListeners';\nimport { EventTypes } from '../../types';\nimport { getMouseButton } from '../../eventListeners/mouse/mouseDownListener';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our Keyboard pressed keys. It's possible there will be no match\n * (no active tool for that mouse button combination).\n *\n * @param evt - The normalized keyboard event.\n *\n * @returns tool\n */\nexport default function getActiveToolForKeyboardEvent(\n  evt: EventTypes.KeyDownEventType\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  // Get the current mouse button clicked\n  const mouseButton = getMouseButton();\n\n  // If any keyboard modifier key is also pressed\n  const modifierKey = keyEventListener.getModifierKey();\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    // tool has binding that matches the mouse button, if mouseEvent is undefined\n    // it uses the primary button\n    const correctBinding =\n      toolOptions.bindings.length &&\n      toolOptions.bindings.some(\n        (binding) =>\n          binding.mouseButton === (mouseButton ?? defaultMousePrimary) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { KeyDownEventType } from '../../types/EventTypes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyDown(evt: KeyDownEventType): void {\n  // get the active tool given the key and mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  const toolName = activeTool.getToolName();\n  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n    toolGroup.setViewportsCursorByToolName(toolName);\n  }\n}\n","import { resetModifierKey } from '../../eventListeners/keyboard/keyDownListener';\nimport { ToolGroupManager } from '../../store';\nimport getActiveToolForKeyboardEvent from '../shared/getActiveToolForKeyboardEvent';\nimport { KeyDownEventType } from '../../types/EventTypes';\n\n/**\n * KeyDown event listener to handle viewport cursor icon changes\n *\n * @param evt - The KeyboardEvent\n */\nexport default function keyUp(evt: KeyDownEventType): void {\n  // get the active tool for the primary mouse button\n  const activeTool = getActiveToolForKeyboardEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  const { renderingEngineId, viewportId } = evt.detail;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  // Reset the modifier key\n  resetModifierKey();\n\n  const toolName = activeTool.getToolName();\n  if (Object.keys(toolGroup.toolOptions).includes(toolName)) {\n    toolGroup.setViewportsCursorByToolName(toolName);\n  }\n}\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\n\n/**\n * Enable Key down and key up listeners\n *\n * @param element - The HTML element to attach the event listeners to.\n */\nconst enable = function (element: HTMLDivElement) {\n  element.addEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.addEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\n/**\n * Disable Key down and key up listeners\n * @param element - The HTML element to attach the event listeners to.\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.KEY_DOWN, keyDown as EventListener);\n  element.removeEventListener(Events.KEY_UP, keyUp as EventListener);\n};\n\nconst keyboardToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default keyboardToolEventDispatcher;\n","import { ToolGroupManager } from '../../store';\nimport { MouseBindings, ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport getMouseModifier from './getMouseModifier';\nimport { keyEventListener } from '../../eventListeners';\n\nconst { Active } = ToolModes;\n\n/**\n * Iterate tool group tools until we find a tool that has a \"ToolBinding\"\n * that matches our TouchEvent's `buttons`. It's possible there will be no match\n * (no active tool for that touch button combination).\n *\n * @param evt - The event dispatcher touch event.\n *\n * @returns tool\n */\nexport default function getActiveToolForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType\n) {\n  // Todo: we should refactor this to use getToolsWithModesForTouchEvent instead\n  const { renderingEngineId, viewportId } = evt.detail;\n  const touchEvent = evt.detail.event;\n\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  const numTouchPoints = Object.keys(touchEvent.touches).length;\n\n  // If any keyboard modifier key is also pressed\n  const modifierKey =\n    getMouseModifier(touchEvent) || keyEventListener.getModifierKey();\n  const defaultMousePrimary = toolGroup.getDefaultMousePrimary();\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const toolOptions = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      toolOptions.bindings.length &&\n      /**\n       * TODO: setActiveTool treats MouseBindings.Primary in a special way\n       * which is analgous to numTouchPoints === 1 as the primary interaction\n       * for touch based applications. The ToolGroup set active and get active\n       * logic should be updated to account for numTouchPoints === 1\n       */\n      toolOptions.bindings.some(\n        (binding) =>\n          (binding.numTouchPoints === numTouchPoints ||\n            (numTouchPoints === 1 &&\n              binding.mouseButton === defaultMousePrimary)) &&\n          binding.modifierKey === modifierKey\n      );\n\n    if (toolOptions.mode === Active && correctBinding) {\n      return toolGroup.getToolInstance(toolName);\n    }\n  }\n}\n","import { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\n\ntype ModesFilter = Array<ToolModes>;\n\n/**\n * Given the normalized touch event and a filter of modes,\n * find all the tools on the element that are in one of the specified modes.\n * If the evtButton is specified, only tools with a matching binding will be returned.\n * @param evt - The normalized touchStart event.\n * @param modesFilter - An array of entries from the `ToolModes` enum.\n */\nexport default function getToolsWithModesForTouchEvent(\n  evt: EventTypes.NormalizedTouchEventType,\n  modesFilter: ModesFilter,\n  numTouchPoints?: number\n) {\n  const { renderingEngineId, viewportId } = evt.detail;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return [];\n  }\n\n  const enabledTools = [];\n\n  const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n\n  for (let j = 0; j < toolGroupToolNames.length; j++) {\n    const toolName = toolGroupToolNames[j];\n    const tool = toolGroup.toolOptions[toolName];\n\n    const correctBinding =\n      numTouchPoints != null &&\n      tool.bindings.length &&\n      tool.bindings.some(\n        (binding) => binding.numTouchPoints === numTouchPoints\n      );\n\n    if (\n      modesFilter.includes(tool.mode) &&\n      (!numTouchPoints || correctBinding)\n    ) {\n      const toolInstance = toolGroup.getToolInstance(toolName);\n      enabledTools.push(toolInstance);\n    }\n  }\n\n  return enabledTools;\n}\n","import { state } from '../../store';\nimport { ToolModes } from '../../enums';\nimport { EventTypes } from '../../types';\nimport {\n  ToolAnnotationPair,\n  ToolsWithMoveableHandles,\n} from '../../types/InternalToolTypes';\n\nimport {\n  setAnnotationSelected,\n  isAnnotationSelected,\n} from '../../stateManagement/annotation/annotationSelection';\n\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\n\n// Util\nimport filterToolsWithMoveableHandles from '../../store/filterToolsWithMoveableHandles';\nimport filterToolsWithAnnotationsForElement from '../../store/filterToolsWithAnnotationsForElement';\nimport filterMoveableAnnotationTools from '../../store/filterMoveableAnnotationTools';\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport getToolsWithModesForTouchEvent from '../shared/getToolsWithModesForTouchEvent';\n\nconst { Active, Passive } = ToolModes;\n\n/**\n * touchStart - Event handler for touchStart events. Uses `customCallbackHandler` to fire\n * the `touchStartCallback` function on active tools.\n */\nexport default function touchStart(evt: EventTypes.TouchStartEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  // Check for preTouchStartCallbacks,\n  // If the tool claims it consumed the event, prevent further checks.\n  if (activeTool && typeof activeTool.preTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.preTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      return;\n    }\n  }\n\n  const isPrimaryClick = Object.keys(evt.detail.event.touches).length === 1;\n  const activeToolsWithEventBinding = getToolsWithModesForTouchEvent(\n    evt,\n    [Active],\n    Object.keys(evt.detail.event.touches).length\n  );\n  const passiveToolsIfEventWasPrimaryTouchButton = isPrimaryClick\n    ? getToolsWithModesForTouchEvent(evt, [Passive])\n    : undefined;\n  const applicableTools = [\n    ...(activeToolsWithEventBinding || []),\n    ...(passiveToolsIfEventWasPrimaryTouchButton || []),\n    activeTool,\n  ];\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Filter tools with annotations for this element\n  const annotationToolsWithAnnotations = filterToolsWithAnnotationsForElement(\n    element,\n    applicableTools\n  );\n\n  const canvasCoords = eventDetail.currentPoints.canvas;\n\n  // For the canvas coordinates, find all tools that might respond to this touch start\n  // on their handles. This filter will call getHandleNearImagePoint for each tool\n  // instance (each annotation)\n  const annotationToolsWithMoveableHandles = filterToolsWithMoveableHandles(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  const isMultiSelect = false;\n\n  // If there are annotation tools whose handle is near the touch, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (annotationToolsWithMoveableHandles.length > 0) {\n    const { tool, annotation, handle } = getAnnotationForSelection(\n      annotationToolsWithMoveableHandles\n    ) as ToolsWithMoveableHandles;\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.handleSelectedCallback(evt, annotation, handle, 'Touch');\n\n    return;\n  }\n\n  // If there were no annotation tools whose handle was near the touch, try to check\n  // if any of the annotation tools are interactable (e.g. moving an entire length annotation)\n  const moveableAnnotationTools = filterMoveableAnnotationTools(\n    element,\n    annotationToolsWithAnnotations,\n    canvasCoords,\n    'touch'\n  );\n\n  // If there are annotation tools that are interactable, select the first one\n  // that isn't locked. If there's only one annotation tool, select it.\n  if (moveableAnnotationTools.length > 0) {\n    const { tool, annotation } = getAnnotationForSelection(\n      moveableAnnotationTools\n    );\n\n    toggleAnnotationSelection(annotation.annotationUID, isMultiSelect);\n    tool.toolSelectedCallback(evt, annotation, 'Touch');\n\n    return;\n  }\n\n  // Run the postTouchStartCallback for the active tool if it exists\n  if (activeTool && typeof activeTool.postTouchStartCallback === 'function') {\n    const consumedEvent = activeTool.postTouchStartCallback(evt);\n\n    if (consumedEvent) {\n      // If the tool claims it consumed the event, prevent further checks.\n      return;\n    }\n  }\n\n  // Don't stop propagation so that touchStartActivate can handle the event\n}\n\n/**\n * If there are multiple annotation tools, return the first one that isn't locked neither hidden.\n * If there's only one annotation tool, return it\n * @param annotationTools - An array of tools and annotation.\n * @returns The candidate for selection\n */\nfunction getAnnotationForSelection(\n  toolsWithMovableHandles: ToolAnnotationPair[]\n): ToolAnnotationPair {\n  return (\n    (toolsWithMovableHandles.length > 1 &&\n      toolsWithMovableHandles.find(\n        (item) =>\n          !isAnnotationLocked(item.annotation) &&\n          isAnnotationVisible(item.annotation.annotationUID)\n      )) ||\n    toolsWithMovableHandles[0]\n  );\n}\n\n/**\n * If the annotation is selected, deselect it. If it's not selected, select it\n * @param annotationUID - The AnnotationUID that we\n * want to toggle the selection of.\n * @param isMultiSelect - If true, the annotation. will be deselected if it is\n * already selected, or deselected if it is selected.\n */\nfunction toggleAnnotationSelection(\n  annotationUID: string,\n  isMultiSelect = false\n): void {\n  if (isMultiSelect) {\n    if (isAnnotationSelected(annotationUID)) {\n      setAnnotationSelected(annotationUID, false);\n    } else {\n      const preserveSelected = true;\n      setAnnotationSelected(annotationUID, true, preserveSelected);\n    }\n  } else {\n    const preserveSelected = false;\n    setAnnotationSelected(annotationUID, true, preserveSelected);\n  }\n}\n","import { state } from '../../store';\nimport { EventTypes } from '../../types';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\n\nimport getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\n\n/**\n * If the `touchStart` handler does not consume an event,\n * activate the creation loop of the active tool, if one is found for the\n * touch button pressed.\n *\n * @param evt - The normalized touchStart event.\n */\nexport default function touchStartActivate(\n  evt: EventTypes.TouchStartActivateEventType\n) {\n  // If a tool has locked the current state it is dealing with an interaction within its own eventLoop.\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  if (!activeTool) {\n    return;\n  }\n\n  if (state.isMultiPartToolActive) {\n    return;\n  }\n\n  if (activeTool.addNewAnnotation) {\n    const annotation = activeTool.addNewAnnotation(evt, 'touch');\n    setAnnotationSelected(annotation.annotationUID);\n  }\n}\n","import getActiveToolForTouchEvent from '../shared/getActiveToolForTouchEvent';\nimport { state } from '../../store';\nimport { TouchDragEventType } from '../../types/EventTypes';\n\n/**\n * touchDrag - Event handler for touchDrag events. Uses `customCallbackHandler` to fire\n * the `touchDragCallback` function on active tools.\n */\nexport default function touchDrag(evt: TouchDragEventType) {\n  if (state.isInteractingWithTool) {\n    return;\n  }\n\n  const activeTool = getActiveToolForTouchEvent(evt);\n\n  const noFoundToolOrDoesNotHaveTouchDragCallback =\n    !activeTool || typeof activeTool.touchDragCallback !== 'function';\n  if (noFoundToolOrDoesNotHaveTouchDragCallback) {\n    return;\n  }\n\n  activeTool.touchDragCallback(evt);\n}\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchEnd - Event handler for touchEnd events. Uses `customCallbackHandler` to fire\n * the `touchEndCallback` function on active tools.\n */\nconst touchEnd = customCallbackHandler.bind(null, 'Touch', 'touchEndCallback');\n\nexport default touchEnd;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchTap - Event handler for touch tap events. Uses `customCallbackHandler` to fire\n * the `touchTapCallback` function on active tools.\n */\nconst touchTap = customCallbackHandler.bind(null, 'Touch', 'touchTapCallback');\n\nexport default touchTap;\n","import customCallbackHandler from '../shared/customCallbackHandler';\n\n/**\n * touchPress - Event handler for touch press events. Uses `customCallbackHandler` to fire\n * the `touchPressCallback` function on active tools.\n */\nconst touchPress = customCallbackHandler.bind(\n  null,\n  'Touch',\n  'touchPressCallback'\n);\n\nexport default touchPress;\n","import Events from '../enums/Events';\n\nimport {\n  touchStart,\n  touchStartActivate,\n  touchDrag,\n  touchEnd,\n  touchTap,\n  touchPress,\n} from './touchEventHandlers';\n\n/**\n * Enable these listeners are emitted in order, and can be cancelled/prevented from bubbling\n * by any previous event.\n *\n * @param element - The element to add the event listeners to.\n */\nconst enable = function (element: HTMLDivElement): void {\n  element.addEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.addEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.addEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.addEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.addEventListener(Events.TOUCH_TAP, touchTap as EventListener);\n  element.addEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\n/**\n * Disable and Remove the MouseToolEventDispatcher handlers from the element.\n *\n * @param element - HTMLDivElement\n */\nconst disable = function (element: HTMLDivElement) {\n  element.removeEventListener(Events.TOUCH_START, touchStart as EventListener);\n  element.removeEventListener(\n    Events.TOUCH_START_ACTIVATE,\n    touchStartActivate as EventListener\n  );\n  element.removeEventListener(Events.TOUCH_DRAG, touchDrag as EventListener);\n  element.removeEventListener(Events.TOUCH_END, touchEnd as EventListener);\n  element.removeEventListener(Events.TOUCH_PRESS, touchPress as EventListener);\n};\n\nconst touchToolEventDispatcher = {\n  enable,\n  disable,\n};\n\nexport default touchToolEventDispatcher;\n","import { Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  touchToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n} from '../eventDispatchers';\nimport { state } from './state';\n\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\n/**\n * When an element is \"enabled\", add event listeners and dispatchers to it\n * so we can use interactions to affect tool behaviors\n *\n * @param evt - The ELEMENT_ENABLED event\n */\nexport default function addEnabledElement(\n  evt: Types.EventTypes.ElementEnabledEvent\n): void {\n  const { element, viewportId } = evt.detail;\n  const svgLayer = _createSvgAnnotationLayer(viewportId);\n\n  // Reset/Create svgNodeCache for element\n  _setSvgNodeCache(element);\n  _appendChild(svgLayer, element);\n\n  // Add this element to the annotation rendering engine\n  annotationRenderingEngine.addViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.enable(element);\n  wheelEventListener.enable(element);\n  touchEventListeners.enable(element);\n  keyEventListener.enable(element);\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.enable(element);\n  cameraModifiedEventDispatcher.enable(element);\n  imageSpacingCalibratedEventDispatcher.enable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.enable(element);\n  keyboardToolEventDispatcher.enable(element);\n  touchToolEventDispatcher.enable(element);\n\n  // labelmap\n  // State\n  state.enabledElements.push(element);\n}\n\n/**\n *\n */\nfunction _createSvgAnnotationLayer(viewportId: string): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgLayer = document.createElementNS(svgns, 'svg');\n\n  const svgLayerId = `svg-layer-${viewportId}`;\n  svgLayer.classList.add('svg-layer');\n  svgLayer.setAttribute('id', svgLayerId);\n  svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgLayer.style.width = '100%';\n  svgLayer.style.height = '100%';\n  svgLayer.style.pointerEvents = 'none';\n  svgLayer.style.position = 'absolute';\n  // TODO: we should test this on high-res monitors\n  //svgLayer.style.textRendering = 'optimizeSpeed'\n\n  // Single dropshadow config for now\n  const defs = document.createElementNS(svgns, 'defs');\n  const filter = document.createElementNS(svgns, 'filter');\n  const feOffset = document.createElementNS(svgns, 'feOffset');\n  const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n  const feBlend = document.createElementNS(svgns, 'feBlend');\n\n  //\n  filter.setAttribute('id', `shadow-${svgLayerId}`);\n  filter.setAttribute('filterUnits', 'userSpaceOnUse');\n\n  //\n  feOffset.setAttribute('result', 'offOut');\n  feOffset.setAttribute('in', 'SourceGraphic');\n  feOffset.setAttribute('dx', '0.5');\n  feOffset.setAttribute('dy', '0.5');\n\n  //\n  feColorMatrix.setAttribute('result', 'matrixOut');\n  feColorMatrix.setAttribute('in', 'offOut');\n  feColorMatrix.setAttribute('in2', 'matrix');\n  feColorMatrix.setAttribute(\n    'values',\n    '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0'\n  );\n\n  //\n  feBlend.setAttribute('in', 'SourceGraphic');\n  feBlend.setAttribute('in2', 'matrixOut');\n  feBlend.setAttribute('mode', 'normal');\n\n  filter.appendChild(feOffset);\n  filter.appendChild(feColorMatrix);\n  filter.appendChild(feBlend);\n  defs.appendChild(filter);\n  svgLayer.appendChild(defs);\n\n  return svgLayer;\n}\n\nfunction _setSvgNodeCache(element) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  // Create or reset\n  // TODO: If... Reset, we should blow out any nodes in DOM\n  state.svgNodeCache[elementHash] = {};\n}\n\n/**\n *\n * @param newNode\n * @param referenceNode\n */\nfunction _appendChild(\n  newNode: SVGElement,\n  referenceNode: HTMLDivElement\n): void {\n  referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * It returns all synchronizers that are not disabled and have a source viewport\n * with the given rendering engine Id and viewport Id\n * @param renderingEngineId - The Id of the rendering engine\n * @param viewportId - The Id of the viewport\n * @returns An array of synchronizers\n */\nfunction getSynchronizersForViewport(\n  viewportId: string,\n  renderingEngineId: string\n): Array<Synchronizer> {\n  const synchronizersFilteredByIds = [];\n\n  if (!renderingEngineId && !viewportId) {\n    throw new Error(\n      'At least one of renderingEngineId or viewportId should be given'\n    );\n  }\n\n  for (let i = 0; i < state.synchronizers.length; i++) {\n    const synchronizer = state.synchronizers[i];\n    const notDisabled = !synchronizer.isDisabled();\n    const hasSourceViewport = synchronizer.hasSourceViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    const hasTargetViewport = synchronizer.hasTargetViewport(\n      renderingEngineId,\n      viewportId\n    );\n\n    if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n      synchronizersFilteredByIds.push(synchronizer);\n    }\n  }\n\n  return synchronizersFilteredByIds;\n}\n\nexport default getSynchronizersForViewport;\n","import { getEnabledElement, Types } from '@cornerstonejs/core';\nimport {\n  mouseEventListeners,\n  wheelEventListener,\n  touchEventListeners,\n  keyEventListener,\n} from '../eventListeners';\nimport {\n  imageRenderedEventDispatcher,\n  cameraModifiedEventDispatcher,\n  mouseToolEventDispatcher,\n  keyboardToolEventDispatcher,\n  imageSpacingCalibratedEventDispatcher,\n  touchToolEventDispatcher,\n} from '../eventDispatchers';\n// ~~\n\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../utilities/triggerAnnotationRender';\n\nconst VIEWPORT_ELEMENT = 'viewport-element';\n\nfunction removeEnabledElement(\n  elementDisabledEvt: Types.EventTypes.ElementDisabledEvent\n): void {\n  // Is DOM element\n  const { element, viewportId } = elementDisabledEvt.detail;\n\n  _resetSvgNodeCache(element);\n  _removeSvgNode(element);\n\n  // Remove this element from the annotation rendering engine\n  annotationRenderingEngine.removeViewportElement(viewportId, element);\n\n  // Listeners\n  mouseEventListeners.disable(element);\n  wheelEventListener.disable(element);\n  touchEventListeners.disable(element);\n  keyEventListener.disable(element);\n  // labelmap\n\n  // Dispatchers: renderer\n  imageRenderedEventDispatcher.disable(element);\n  cameraModifiedEventDispatcher.disable(element);\n  imageSpacingCalibratedEventDispatcher.disable(element);\n  // Dispatchers: interaction\n  mouseToolEventDispatcher.disable(element);\n  keyboardToolEventDispatcher.disable(element);\n  touchToolEventDispatcher.disable(element);\n\n  // State\n  // @TODO: We used to \"disable\" the tool before removal. Should we preserve the hook that would call on tools?\n  _removeViewportFromSynchronizers(element);\n  _removeViewportFromToolGroup(element);\n\n  // _removeAllToolsForElement(canvas)\n  _removeEnabledElement(element);\n}\n\nconst _removeViewportFromSynchronizers = (element: HTMLDivElement) => {\n  const enabledElement = getEnabledElement(element);\n\n  const synchronizers = getSynchronizersForViewport(\n    enabledElement.viewportId,\n    enabledElement.renderingEngineId\n  );\n  synchronizers.forEach((sync) => {\n    sync.remove(enabledElement);\n  });\n};\n\nconst _removeViewportFromToolGroup = (element: HTMLDivElement) => {\n  const { renderingEngineId, viewportId } = getEnabledElement(element);\n\n  const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n  if (toolGroup) {\n    toolGroup.removeViewports(renderingEngineId, viewportId);\n  }\n};\n\nconst _removeAllToolsForElement = function (element) {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  toolsWithData.forEach(({ annotations }) => {\n    annotations.forEach((annotation) => {\n      removeAnnotation(annotation.annotationUID);\n    });\n  });\n};\n\nfunction _resetSvgNodeCache(element: HTMLDivElement) {\n  const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } =\n    element.dataset;\n  const elementHash = `${viewportId}:${renderingEngineId}`;\n\n  delete state.svgNodeCache[elementHash];\n}\n\nfunction _removeSvgNode(element: HTMLDivElement) {\n  const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n  const svgLayer = internalViewportNode.querySelector('svg');\n  if (svgLayer) {\n    internalViewportNode.removeChild(svgLayer);\n  }\n}\n\n/**\n * @private\n * @param enabledElement\n */\nconst _removeEnabledElement = function (element: HTMLDivElement) {\n  const foundElementIndex = state.enabledElements.findIndex(\n    (el) => el === element\n  );\n\n  if (foundElementIndex > -1) {\n    state.enabledElements.splice(foundElementIndex, 1);\n  }\n};\n\nexport default removeEnabledElement;\n","import type { Types } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\n\nexport function triggerAnnotationRenderForViewportIds(\n  renderingEngine: Types.IRenderingEngine,\n  viewportIdsToRender: string[]\n): void {\n  if (!viewportIdsToRender.length) {\n    return;\n  }\n\n  viewportIdsToRender.forEach((viewportId) => {\n    const { element } = renderingEngine.getViewport(viewportId);\n    triggerAnnotationRender(element);\n  });\n}\n\nexport default triggerAnnotationRenderForViewportIds;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\n/**\n * This is a callback function that is called when an annotation is modified.\n * Since we are throttling the cachedStats calculation for annotation tools,\n * we need to trigger a final render for the annotation. so that the annotation\n * textBox is updated.\n * Todo: This will trigger all the annotation tools to re-render, although DOM\n * will update those that have changed, but more efficient would be to only\n * update the changed annotation.\n * Todo: A better way is to extract the textBox render logic from the renderAnnotation\n * of all tools and just trigger a render for that (instead of the entire annotation., even if\n * no svg update happens since the attributes for handles are the same)\n */\nfunction annotationModifiedListener(evt): void {\n  const { viewportId, renderingEngineId } = evt.detail;\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n  triggerAnnotationRenderForViewportIds(renderingEngine, [viewportId]);\n}\n\nexport default annotationModifiedListener;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\n\n/**\n * When an annotation is deselected, trigger an annotation render for all viewports.\n * The reason for this is that, drawing an annotation in a different viewport\n * should deselect all other annotations in other viewports. In order to achieve\n * this, we need to trigger an annotation render for all viewports.\n * Todo: Although this is inefficient, but since annotations are only rendered if necessary,\n * it's probably not going to have a noticeable impact on performance.\n * @param evt - The event object.\n */\nfunction annotationSelectionListener(evt): void {\n  const deselectedAnnotation = evt.detail.removed;\n\n  if (!deselectedAnnotation.length) {\n    return;\n  }\n\n  const renderingEngines = getRenderingEngines();\n\n  renderingEngines.forEach((renderingEngine) => {\n    const viewports = renderingEngine.getViewports();\n    const viewportIds = viewports.map((vp) => vp.id);\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n  });\n}\n\nexport default annotationSelectionListener;\n","import { SegmentationModifiedEventType } from '../../types/EventTypes';\nimport {\n  getToolGroupIdsWithSegmentation,\n  getSegmentationRepresentations,\n} from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationRepresentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\n\n/** A function that listens to the `segmentationModified` event and triggers\n * the triggerSegmentationRepresentationModified on each toolGroup that\n * has a representation of the given segmentationId.\n */\nconst segmentationModifiedListener = function (\n  evt: SegmentationModifiedEventType\n): void {\n  const { segmentationId } = evt.detail;\n\n  const toolGroupIds = getToolGroupIdsWithSegmentation(segmentationId);\n\n  toolGroupIds.forEach((toolGroupId) => {\n    const segRepresentations = getSegmentationRepresentations(toolGroupId);\n    segRepresentations.forEach((representation) => {\n      if (representation.segmentationId === segmentationId) {\n        triggerSegmentationRepresentationModified(\n          toolGroupId,\n          representation.segmentationRepresentationUID\n        );\n      }\n    });\n  });\n};\n\nexport default segmentationModifiedListener;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Given a tool group Id, return the tool group\n * @param toolGroupId - The Id of the tool group to be retrieved.\n * @returns The tool group that has the same id as the tool group id that was\n * passed in.\n */\nfunction getToolGroup(toolGroupId: string): IToolGroup | undefined {\n  return state.toolGroups.find((s) => s.id === toolGroupId);\n}\n\nexport default getToolGroup;\n","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return assertThisInitialized(self);\n}","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\n\nimport {\n  RepresentationConfig,\n  SegmentationRepresentationConfig,\n  SegmentSpecificRepresentationConfig,\n} from '../../../types/SegmentationStateTypes';\n\n/**\n * It returns the global segmentation config.\n * @returns The global segmentation config containing the representations\n * config for each representation type and renderInactiveSegmentations flag.\n */\nfunction getGlobalConfig(): SegmentationRepresentationConfig {\n  return SegmentationState.getGlobalConfig();\n}\n\n/**\n * Set the global segmentation config\n * @param segmentationConfig - SegmentationConfig\n */\nfunction setGlobalConfig(\n  segmentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setGlobalConfig(segmentationConfig);\n}\n\n/**\n * Given a representation type, return the corresponding global representation config\n * @param representationType - The type of representation to query\n * @returns A representation configuration object.\n */\nfunction getGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations\n): RepresentationConfig['LABELMAP'] {\n  const globalConfig = getGlobalConfig();\n  return globalConfig.representations[representationType];\n}\n\n/**\n * Set the global configuration for a given representation type. It fires\n * a SEGMENTATION_MODIFIED event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param representationType - The type of representation to set config for\n * @param config - The configuration for the representation.\n */\nfunction setGlobalRepresentationConfig(\n  representationType: SegmentationRepresentations,\n  config: RepresentationConfig['LABELMAP']\n): void {\n  const globalConfig = getGlobalConfig();\n\n  setGlobalConfig({\n    ...globalConfig,\n    representations: {\n      ...globalConfig.representations,\n      [representationType]: {\n        ...globalConfig.representations[representationType],\n        ...config,\n      },\n    },\n  });\n}\n\n/**\n * Get the toolGroup specific segmentation config\n * @param toolGroupId - The Id of the tool group\n * @returns A SegmentationConfig object.\n */\nfunction getToolGroupSpecificConfig(\n  toolGroupId: string\n): SegmentationRepresentationConfig {\n  return SegmentationState.getToolGroupSpecificConfig(toolGroupId);\n}\n\n/**\n * Sets the tool group specific configuration for the segmentation\n * representation. This will apply to all segmentation representations.\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationConfig - This is the configuration object that you will use to set the default values for\n * the segmentation representation.\n */\nfunction setToolGroupSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationConfig: SegmentationRepresentationConfig\n): void {\n  SegmentationState.setToolGroupSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationConfig\n  );\n}\n\n/**\n * Give the segmentation representation UID, return the corresponding config\n * which is shared by all segments in the segmentation representation. This is\n * an optional level of configuration that can be set by the user, by default\n * it will fallback to the toolGroup specific config, if not set, it will fallback\n * to the global config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n * @returns - The configuration for the representation.\n */\nfunction getSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): RepresentationConfig {\n  return SegmentationState.getSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Set the segmentation representation specific configuration for the\n * segmentation representation. This will apply to all segments in the\n * segmentation representation and has higher priority than the toolGroup\n * specific config.\n *\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param config - The configuration for the representation. This is an object\n * only containing the representation type as key and the config as value.\n */\nfunction setSegmentationRepresentationSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: RepresentationConfig\n): void {\n  SegmentationState.setSegmentationRepresentationSpecificConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\n/**\n * Get the segment specific configuration for the segmentation representation.\n *\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID  - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @returns - The configuration for the segment index in the segmentation representation that is shown in the toolGroup's viewport\n */\nfunction getSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): RepresentationConfig {\n  return SegmentationState.getSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n}\n\n/**\n * Set the segment specific configuration for the segmentation representation.\n * This configuration, if specified, has higher priority than the segmentation representation specific config,\n * and the toolGroup specific config. The order of priority is: segment specific config > segmentation representation specific config > toolGroup specific config > global config\n * @param toolGroupId - The tool group id where the segmentation representation belongs to.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment\n * @param config - The configuration for the representation. This is an object\n */\nfunction setSegmentSpecificConfig(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  config: SegmentSpecificRepresentationConfig\n): void {\n  SegmentationState.setSegmentSpecificRepresentationConfig(\n    toolGroupId,\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport {\n  // Global\n  getGlobalConfig,\n  setGlobalConfig,\n  getGlobalRepresentationConfig,\n  setGlobalRepresentationConfig,\n  // ToolGroup Specific\n  getToolGroupSpecificConfig,\n  setToolGroupSpecificConfig,\n  // segmentation representation specific config\n  getSegmentationRepresentationSpecificConfig,\n  setSegmentationRepresentationSpecificConfig,\n  // segment specific config\n  getSegmentSpecificConfig,\n  setSegmentSpecificConfig,\n};\n","import { cache, Types } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/segmentationState';\nimport { ToolGroupSpecificRepresentation } from '../../../types/SegmentationStateTypes';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\n\nfunction getSegmentationIndices(segmentationId) {\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n\n  if (segmentation.type === SegmentationRepresentations.Labelmap) {\n    const volume = cache.getVolume(segmentationId);\n    const scalarData = volume.getScalarData();\n\n    const keySet = {};\n    for (let i = 0; i < scalarData.length; i++) {\n      const segmentIndex = scalarData[i];\n      if (segmentIndex !== 0 && !keySet[segmentIndex]) {\n        keySet[segmentIndex] = true;\n      }\n    }\n    return Object.keys(keySet).map((it) => parseInt(it, 10));\n  } else if (segmentation.type === SegmentationRepresentations.Contour) {\n    const geometryIds = segmentation.representationData.CONTOUR?.geometryIds;\n\n    if (!geometryIds) {\n      throw new Error(\n        `No geometryIds found for segmentationId ${segmentationId}`\n      );\n    }\n\n    return geometryIds.map((geometryId) => {\n      const geometry = cache.getGeometry(geometryId) as Types.IGeometry;\n      return (geometry.data as Types.IContourSet).getSegmentIndex();\n    });\n  }\n}\n\n/**\n * Set the visibility of a segmentation representation for a given tool group. It fires\n * a SEGMENTATION_REPRESENTATION_MODIFIED event. Visibility true will show all segments\n * and visibility false will hide all segments\"\n *\n * @triggers SEGMENTATION_REPRESENTATION_MODIFIED\n * @param toolGroupId - The Id of the tool group that contains the segmentation.\n * @param segmentationRepresentationUID - The id of the segmentation representation to modify its visibility.\n * @param visibility - boolean\n */\nfunction setSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  visibility: boolean\n): void {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden, segmentationId } = representation;\n\n  const indices = getSegmentationIndices(segmentationId);\n\n  // if visibility is set to be true, we need to remove all the segments\n  // from the segmentsHidden set, otherwise we need to add all the segments\n  // to the segmentsHidden set\n  if (visibility) {\n    segmentsHidden.clear();\n  } else {\n    indices.forEach((index) => {\n      segmentsHidden.add(index);\n    });\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    representation.segmentationRepresentationUID\n  );\n}\n\n/**\n * Get the visibility of a segmentation data for a given tool group.\n *\n * @param toolGroupId - The Id of the tool group that the segmentation\n * data belongs to.\n * @param segmentationRepresentationUID - The id of the segmentation data to get\n * @returns A boolean value that indicates whether the segmentation data is visible or\n * not on the toolGroup\n */\nfunction getSegmentationVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): boolean | undefined {\n  const toolGroupSegmentationRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  const representation = toolGroupSegmentationRepresentations.find(\n    (representation: ToolGroupSpecificRepresentation) =>\n      representation.segmentationRepresentationUID ===\n      segmentationRepresentationUID\n  );\n\n  if (!representation) {\n    return;\n  }\n\n  const { segmentsHidden } = representation;\n\n  return segmentsHidden.size === 0;\n}\n\n/**\n * Set the visibility of the given segment indices to the given visibility. This\n * is a helper to set the visibility of multiple segments at once and reduces\n * the number of events fired.\n *\n * @param toolGroupId -  The tool group id of the segmentation representation.\n * @param segmentationRepresentationUID -  The UID of the segmentation\n * representation.\n * @param segmentIndices -  The indices of the segments to be hidden/shown.\n * @param visibility -  The visibility to set the segments to.\n *\n */\nfunction setSegmentsVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndices: number[],\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  segmentIndices.forEach((segmentIndex) => {\n    visibility\n      ? segRepresentation.segmentsHidden.delete(segmentIndex)\n      : segRepresentation.segmentsHidden.add(segmentIndex);\n  });\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nfunction setSegmentVisibility(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  visibility: boolean\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    return;\n  }\n\n  visibility\n    ? segRepresentation.segmentsHidden.delete(segmentIndex)\n    : segRepresentation.segmentsHidden.add(segmentIndex);\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  setSegmentationVisibility,\n  getSegmentationVisibility,\n  setSegmentVisibility,\n  setSegmentsVisibility,\n};\n","import {\n  StackViewport,\n  utilities,\n  BaseVolumeViewport,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { Types } from '@cornerstonejs/core';\nimport { ToolModes } from '../../enums';\nimport { InteractionTypes, ToolProps, PublicToolProps } from '../../types';\n\nexport interface IBaseTool {\n  /** ToolGroup ID the tool instance belongs to */\n  toolGroupId: string;\n  /** Tool supported interaction types */\n  supportedInteractionTypes: InteractionTypes[];\n  /** Tool Mode : Active, Passive, Enabled, Disabled */\n  mode: ToolModes;\n  /** Tool Configuration */\n  configuration: {\n    preventHandleOutsideImage?: boolean;\n    strategies?: Record<string, any>;\n    defaultStrategy?: string;\n    activeStrategy?: string;\n    strategyOptions?: Record<string, unknown>;\n  };\n}\n\n/**\n * Abstract base class from which all tools derive.\n * Deals with cleanly merging custom and default configuration, and strategy\n * application.\n */\nabstract class BaseTool implements IBaseTool {\n  static toolName;\n  /** Supported Interaction Types - currently only Mouse */\n  public supportedInteractionTypes: InteractionTypes[];\n  public configuration: Record<string, any>;\n  /** ToolGroup ID the tool instance belongs to */\n  public toolGroupId: string;\n  /** Tool Mode - Active/Passive/Enabled/Disabled/ */\n  public mode: ToolModes;\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    const initialProps = utilities.deepMerge(defaultToolProps, toolProps);\n\n    const {\n      configuration = {},\n      supportedInteractionTypes,\n      toolGroupId,\n    } = initialProps;\n\n    // If strategies are not initialized in the tool config\n    if (!configuration.strategies) {\n      configuration.strategies = {};\n      configuration.defaultStrategy = undefined;\n      configuration.activeStrategy = undefined;\n      configuration.strategyOptions = {};\n    }\n\n    this.toolGroupId = toolGroupId;\n    this.supportedInteractionTypes = supportedInteractionTypes || [];\n    this.configuration = Object.assign({}, configuration);\n    this.mode = ToolModes.Disabled;\n  }\n\n  /**\n   * Returns the name of the tool\n   * @returns The name of the tool.\n   */\n  public getToolName(): string {\n    // Since toolName is static we get it from the class constructor\n    return (<typeof BaseTool>this.constructor).toolName;\n  }\n\n  /**\n   * It applies the active strategy to the enabled element.\n   * @param enabledElement - The element that is being operated on.\n   * @param operationData - The data that needs to be passed to the strategy.\n   * @returns The result of the strategy.\n   */\n  public applyActiveStrategy(\n    enabledElement: Types.IEnabledElement,\n    operationData: unknown\n  ): any {\n    const { strategies, activeStrategy } = this.configuration;\n    return strategies[activeStrategy].call(this, enabledElement, operationData);\n  }\n\n  /**\n   * merges the new configuration with the tool configuration\n   * @param configuration - toolConfiguration\n   */\n  public setConfiguration(newConfiguration: Record<string, any>): void {\n    this.configuration = utilities.deepMerge(\n      this.configuration,\n      newConfiguration\n    );\n  }\n\n  /**\n   * Sets the active strategy for a tool. Strategies are\n   * multiple implementations of tool behavior that can be switched by tool\n   * configuration.\n   *\n   * @param strategyName - name of the strategy to be set as active\n   */\n  public setActiveStrategy(strategyName: string): void {\n    this.setConfiguration({ activeStrategy: strategyName });\n  }\n\n  /**\n   * Returns the volumeId for the volume viewport. It will grabbed the volumeId\n   * from the volumeId if particularly specified in the tool configuration, or if\n   * not, the first actorUID in the viewport is returned as the volumeId. NOTE: for\n   * segmentations, actorUID is not necessarily the volumeId since the segmentation\n   * can have multiple representations, use segmentation helpers to get the volumeId\n   * based on the actorUID.\n   *\n   * @param viewport - Volume viewport\n   * @returns the volumeId for the viewport if specified in the tool configuration,\n   * or the first actorUID in the viewport if not.\n   */\n  private getTargetVolumeId(viewport: Types.IViewport): string | undefined {\n    if (this.configuration.volumeId) {\n      return this.configuration.volumeId;\n    }\n\n    // If volume not specified, then return the actorUID for the\n    // default actor - first actor\n    const actorEntries = viewport.getActors();\n\n    if (!actorEntries) {\n      return;\n    }\n\n    // find the first image actor of instance type vtkVolume\n    return actorEntries.find(\n      (actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume'\n    )?.uid;\n  }\n\n  /**\n   * Get the image that is displayed for the targetId in the cachedStats\n   * which can be either imageId:<imageId> or volumeId:<volumeId>\n   *\n   * @param targetId - annotation targetId stored in the cached stats\n   * @param renderingEngine - The rendering engine\n   * @returns The image data for the target.\n   */\n  protected getTargetIdImage(\n    targetId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): Types.IImageData | Types.CPUIImageData | Types.IImageVolume {\n    if (targetId.startsWith('imageId:')) {\n      const imageId = targetId.split('imageId:')[1];\n      const imageURI = utilities.imageIdToURI(imageId);\n      let viewports = utilities.getViewportsWithImageURI(\n        imageURI,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      viewports = viewports.filter((viewport) => {\n        return viewport.getCurrentImageId() === imageId;\n      });\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else if (targetId.startsWith('volumeId:')) {\n      const volumeId = targetId.split('volumeId:')[1];\n      const viewports = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n\n      if (!viewports || !viewports.length) {\n        return;\n      }\n\n      return viewports[0].getImageData();\n    } else {\n      throw new Error(\n        'getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"'\n      );\n    }\n  }\n\n  /**\n   * Get the target Id for the viewport which will be used to store the cached\n   * statistics scoped to that target in the annotations.\n   * For StackViewport, targetId is the viewportId, but for the volume viewport,\n   * the targetId will be grabbed from the volumeId if particularly specified\n   * in the tool configuration, or if not, the first actorUID in the viewport.\n   *\n   * @param viewport - viewport to get the targetId for\n   * @returns targetId\n   */\n  protected getTargetId(viewport: Types.IViewport): string | undefined {\n    if (viewport instanceof StackViewport) {\n      return `imageId:${viewport.getCurrentImageId()}`;\n    } else if (viewport instanceof BaseVolumeViewport) {\n      return `volumeId:${this.getTargetVolumeId(viewport)}`;\n    } else if (viewport instanceof VideoViewport) {\n      return '';\n    } else {\n      throw new Error(\n        'getTargetId: viewport must be a StackViewport or VolumeViewport'\n      );\n    }\n  }\n}\n\n// Note: this is a workaround since terser plugin does not support static blocks\n// yet and we can't easily say static toolName = \"BaseTool\" in the class definition.\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the surface representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the surface representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.startsWith(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n}\n\nexport default removeContourFromElement;\n","export function pointToString(point, decimals = 5) {\n  return (\n    parseFloat(point[0]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[1]).toFixed(decimals) +\n    ',' +\n    parseFloat(point[2]).toFixed(decimals) +\n    ','\n  );\n}\n","import {\n  getEnabledElement,\n  Enums,\n  VolumeViewport3D,\n} from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkClipClosedSurface from '@kitware/vtk.js/Filters/General/ClipClosedSurface';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { pointToString } from '../../../utilities/pointToString';\n\nconst polyDataCache = new Map();\n\nfunction addSurfaceToElement(\n  element: HTMLDivElement,\n  surface: any,\n  actorUID: string\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const points = surface.getPoints();\n  const polys = surface.getPolys();\n  const color = surface.getColor();\n\n  const polyData = vtkPolyData.newInstance();\n  polyData.getPoints().setData(points, 3);\n\n  const triangles = vtkCellArray.newInstance({\n    values: Float32Array.from(polys),\n  });\n  polyData.setPolys(triangles);\n\n  const mapper = vtkMapper.newInstance({});\n  let clippingFilter;\n  if (!(viewport instanceof VolumeViewport3D)) {\n    clippingFilter = vtkClipClosedSurface.newInstance({\n      clippingPlanes: [],\n      activePlaneId: 2,\n      passPointData: false,\n    });\n    clippingFilter.setInputData(polyData);\n    clippingFilter.setGenerateOutline(true);\n    clippingFilter.setGenerateFaces(false);\n    clippingFilter.update();\n    const filteredData = clippingFilter.getOutputData();\n    mapper.setInputData(filteredData);\n  } else {\n    mapper.setInputData(polyData);\n  }\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n\n  // sets the color of the surface actor\n  actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n  viewport.addActor({\n    actor,\n    uid: actorUID,\n    clippingFilter,\n  });\n\n  element.addEventListener(\n    Enums.Events.CLIPPING_PLANES_UPDATED,\n    updateSurfacePlanes\n  );\n}\n\n/**\n * Updates the clipping planes of a surface and caches the resulting poly data\n * @param evt\n */\nfunction updateSurfacePlanes(evt) {\n  const { actorEntry, vtkPlanes, viewport } = evt.detail;\n  if (!actorEntry?.clippingFilter) {\n    return;\n  }\n\n  const mapper = actorEntry.actor.getMapper();\n\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = `${viewport.id}-${pointToString(\n    viewPlaneNormal\n  )}-${imageIndex}`;\n\n  let actorCache = polyDataCache.get(actorEntry.uid);\n  if (!actorCache) {\n    actorCache = new Map();\n    polyDataCache.set(actorEntry.uid, actorCache);\n  }\n\n  let polyData = actorCache.get(cacheId);\n  if (!polyData) {\n    const clippingFilter = actorEntry.clippingFilter;\n    clippingFilter.setClippingPlanes(vtkPlanes);\n    try {\n      clippingFilter.update();\n      polyData = clippingFilter.getOutputData();\n      actorCache.set(cacheId, polyData);\n    } catch (e) {\n      console.error('Error clipping surface', e);\n    }\n  }\n  mapper.setInputData(polyData);\n}\n\nexport default addSurfaceToElement;\n","import {\n  cache,\n  getEnabledElementByIds,\n  Types,\n  utilities,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport * as SegmentationConfig from '../../../stateManagement/segmentation/config/segmentationConfig';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport {\n  RepresentationPublicInput,\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport removeSurfaceFromElement from './removeSurfaceFromElement';\nimport addSurfaceToElement from './addSurfaceToElement';\n\n/**\n * It adds a new segmentation representation to the segmentation state\n * @param toolGroupId - The id of the toolGroup that the segmentation\n * belongs to\n * @param representationInput - RepresentationPublicInput\n * @param toolGroupSpecificConfig - The configuration that is specific to the toolGroup.\n * @returns The segmentationRepresentationUID\n */\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId } = representationInput;\n  const segmentationRepresentationUID = utilities.uuidv4();\n  // Todo: make these configurable during representation input by user\n  const segmentsHidden = new Set() as Set<number>;\n  const colorLUTIndex = 0;\n  const active = true;\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: Representations.Surface,\n    segmentsHidden,\n    colorLUTIndex,\n    active,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: {},\n  };\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const mergedConfig = utilities.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n  SegmentationState.addSegmentationRepresentation(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n  return segmentationRepresentationUID;\n}\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeSurfaceFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the Surface  for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const SurfaceData = segmentation.representationData[Representations.Surface];\n  const { geometryId } = SurfaceData;\n\n  if (!geometryId) {\n    console.warn(\n      `No Surfaces found for segmentationId ${segmentationId}. Skipping render.`\n    );\n  }\n\n  const geometry = cache.getGeometry(geometryId);\n  if (!geometry) {\n    throw new Error(`No Surfaces found for geometryId ${geometryId}`);\n  }\n\n  if (geometry.type !== Enums.GeometryType.SURFACE) {\n    // Todo: later we can support converting other geometries to Surfaces\n    throw new Error(\n      `Geometry type ${geometry.type} not supported for rendering.`\n    );\n  }\n\n  if (!geometry.data) {\n    console.warn(\n      `No Surfaces found for geometryId ${geometryId}. Skipping render.`\n    );\n    return;\n  }\n\n  const surface = geometry.data;\n\n  const surfaceUID = `${segmentationRepresentationUID}_${surface.id}}`;\n  _renderSurface(viewport, surface, surfaceUID);\n\n  viewport.resetCamera();\n  viewport.render();\n}\n\nfunction _renderSurface(\n  viewport: Types.IVolumeViewport,\n  surface: any,\n  surfaceUID: string\n): void {\n  const actorUID = surfaceUID;\n  const actorEntry = viewport.getActor(actorUID);\n\n  if (!actorEntry) {\n    addSurfaceToElement(viewport.element, surface, actorUID);\n  } else {\n    throw new Error('Not implemented yet. (Update surface)');\n  }\n}\n\nfunction _removeSurfaceFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeSurfaceFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n};\n","import { Enums, Types } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { ToolGroupSpecificContourRepresentation } from '../../../types';\n\n/**\n * If the segment specific config exists for the given segment id, it returns\n * the segment specific config. Otherwise, it looks for the segment specific\n * config for the given index. If it doesn't exist, it returns null.\n *\n * @param contourRepresentation -  The representation object that is passed\n * to the tool.\n * @param segmentId -  The id of the segment.\n * @param index -  The index of the segment in the list of segments.\n * @returns the segment specific config for the given segment id.\n *\n */\nexport function getSegmentSpecificConfig(\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  segmentId: string,\n  index: number\n) {\n  let segmentSpecificConfig =\n    contourRepresentation.segmentSpecificConfig?.[segmentId];\n\n  if (!segmentSpecificConfig) {\n    // try the index\n    segmentSpecificConfig =\n      contourRepresentation.segmentSpecificConfig?.[index];\n  }\n\n  if (!segmentSpecificConfig) {\n    return null;\n  }\n\n  return segmentSpecificConfig.CONTOUR;\n}\n\n/**\n * takes a geometry object as an argument\n * and throws an error if the geometry object is not a contour\n * @param geometry -  The geometry object to be rendered.\n */\nexport function validateGeometry(geometry: Types.IGeometry): void {\n  if (!geometry) {\n    throw new Error(`No contours found for geometryId ${geometry.id}`);\n  }\n\n  const geometryId = geometry.id;\n\n  if (geometry.type !== Enums.GeometryType.CONTOUR) {\n    throw new Error(\n      `Geometry type ${geometry.type} not supported for rendering.`\n    );\n  }\n\n  if (!geometry.data) {\n    console.warn(\n      `No contours found for geometryId ${geometryId}. Skipping render.`\n    );\n    return;\n  }\n}\n\n/**\n * It takes a contourSet and returns a vtkPolyData for that contourSet. A contour set\n * is a collection of contours. Each contour is a collection of points. Each point\n * is x,y,z in the world coordinate system.\n *\n * @param contourSet -  the contour set that you want to convert to polyData\n * @returns A vtkPolyData object\n */\nexport function getPolyData(contourSet: Types.IContourSet) {\n  const pointArray = [];\n\n  const points = vtkPoints.newInstance();\n  const lines = vtkCellArray.newInstance();\n\n  // this variable will indicate the index of the first point in the current line\n  // so we can correctly generate the point index list to add in the cellArray\n  let pointIndex = 0;\n  contourSet.getContours().forEach((contour: Types.IContour) => {\n    const pointList = contour.getPoints();\n    const flatPoints = contour.getFlatPointsArray();\n    const type = contour.getType();\n\n    // creating a point index list that defines a line\n    const pointIndexes = pointList.map(\n      (_, pointListIndex) => pointListIndex + pointIndex\n    );\n\n    // if close planar, add the first point index to the list\n    if (type === Enums.ContourType.CLOSED_PLANAR) {\n      pointIndexes.push(pointIndexes[0]);\n    }\n\n    const linePoints = Float32Array.from(flatPoints);\n    // add the current points into the point list\n    pointArray.push(...linePoints);\n    // add the point indexes into the cell array\n    lines.insertNextCell([...pointIndexes]);\n    // update the first point index\n    pointIndex = pointIndex + pointList.length;\n  });\n\n  // converts the pointArray into vtkPoints\n  points.setData(pointArray, 3);\n\n  // creates the polyData\n  const polygon = vtkPolyData.newInstance();\n  polygon.setPoints(points);\n  polygon.setLines(lines);\n\n  return polygon;\n}\n","type ConfigCache = {\n  segmentsHidden: Set<number>;\n  outlineWidthActive: number;\n  visibility: boolean;\n};\n\n/**\n * Config cache is used to store the config for a given segmentation\n * representation. This is used to avoid having to recompute the config\n * every time the user changes the active segment, and also for performance\n * reasons.\n */\nconst configCachePerSegmentationRepresentationUID = new Map();\n\nexport function getConfigCache(\n  segmentationRepresentationUID: string\n): ConfigCache {\n  return configCachePerSegmentationRepresentationUID.get(\n    segmentationRepresentationUID\n  );\n}\n\nexport function setConfigCache(\n  segmentationRepresentationUID: string,\n  config: ConfigCache\n) {\n  configCachePerSegmentationRepresentationUID.set(\n    segmentationRepresentationUID,\n    config\n  );\n}\n\nexport function deleteConfigCache(segmentationRepresentationUID: string) {\n  configCachePerSegmentationRepresentationUID.delete(\n    segmentationRepresentationUID\n  );\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkAppendPolyData from '@kitware/vtk.js/Filters/General/AppendPolyData';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\n\nimport {\n  getPolyData,\n  getSegmentSpecificConfig,\n  validateGeometry,\n} from './utils';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\n\nexport function addContourSetsToElement(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const appendPolyData = vtkAppendPolyData.newInstance();\n\n  const scalarToColorMap = new Map();\n  const segmentSpecificMap = new Map();\n\n  geometryIds.forEach((geometryId) => {\n    const geometry = cache.getGeometry(geometryId);\n\n    if (!geometry) {\n      console.warn(\n        `No geometry found for geometryId ${geometryId}. Skipping render.`\n      );\n      return;\n    }\n\n    const segmentIndex = (geometry.data as Types.IContourSet).getSegmentIndex();\n\n    validateGeometry(geometry);\n\n    const segmentSpecificConfig = getSegmentSpecificConfig(\n      contourRepresentation,\n      geometryId,\n      segmentIndex\n    );\n\n    const contourSet = geometry.data;\n    const polyData = getPolyData(contourSet as Types.IContourSet);\n    const color = contourSet.getColor();\n\n    const size = polyData.getPoints().getNumberOfPoints();\n\n    const scalars = vtkDataArray.newInstance({\n      size: size * 4,\n      numberOfComponents: 4,\n      dataType: 'Uint8Array',\n    });\n    for (let i = 0; i < size; ++i) {\n      scalars.setTuple(i, [...color, 255]);\n    }\n    polyData.getPointData().setScalars(scalars);\n\n    if (segmentSpecificConfig) {\n      segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n    }\n\n    scalarToColorMap.set(segmentIndex, [\n      ...color,\n      segmentsHidden.has(segmentIndex) ? 0 : 255,\n    ]);\n\n    segmentIndex === 0\n      ? appendPolyData.setInputData(polyData)\n      : appendPolyData.addInputData(polyData);\n  });\n\n  const polyDataOutput = appendPolyData.getOutputData();\n\n  const outlineWidthActive =\n    contourRepresentationConfig.representations.CONTOUR.outlineWidthActive;\n\n  const mapper = vtkMapper.newInstance();\n  mapper.setInputData(polyDataOutput);\n\n  const actor = vtkActor.newInstance();\n  actor.setMapper(mapper);\n  actor.getProperty().setLineWidth(outlineWidthActive);\n\n  // set the config cache for later update of the contour\n  setConfigCache(\n    segmentationRepresentationUID,\n    Object.assign({}, getConfigCache(segmentationRepresentationUID), {\n      segmentsHidden: new Set(segmentsHidden),\n      segmentSpecificMap,\n      outlineWidthActive,\n    })\n  );\n\n  actor.setForceOpaque(true);\n\n  viewport.addActor({\n    uid: contourActorUID,\n    actor: actor as unknown as Types.Actor,\n  });\n  viewport.resetCamera();\n  viewport.render();\n}\n","import { cache, Types } from '@cornerstonejs/core';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { getConfigCache, setConfigCache } from './contourConfigCache';\nimport { getSegmentSpecificConfig } from './utils';\n\nexport function updateContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig,\n  contourActorUID: string\n) {\n  const { segmentationRepresentationUID, segmentsHidden } =\n    contourRepresentation;\n  const newContourConfig = contourRepresentationConfig.representations.CONTOUR;\n  const cachedConfig = getConfigCache(segmentationRepresentationUID);\n\n  const contourSetsActor = viewport.getActor(contourActorUID);\n\n  if (!contourSetsActor) {\n    console.warn(\n      `No contour actor found for actorUID ${contourActorUID}. Skipping render.`\n    );\n    return;\n  }\n\n  const { actor } = contourSetsActor;\n\n  const newOutlineWithActive = newContourConfig.outlineWidthActive;\n\n  if (cachedConfig?.outlineWidthActive !== newOutlineWithActive) {\n    (actor as unknown as vtkActor)\n      .getProperty()\n      .setLineWidth(newOutlineWithActive);\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        outlineWidthActive: newOutlineWithActive,\n      })\n    );\n  }\n\n  const mapper = (actor as unknown as vtkActor).getMapper();\n  const lut = mapper.getLookupTable();\n\n  const segmentsToSetToInvisible = [];\n  const segmentsToSetToVisible = [];\n\n  for (const segmentIndex of segmentsHidden) {\n    if (!cachedConfig.segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToInvisible.push(segmentIndex);\n    }\n  }\n\n  // the other way around\n  for (const segmentIndex of cachedConfig.segmentsHidden) {\n    if (!segmentsHidden.has(segmentIndex)) {\n      segmentsToSetToVisible.push(segmentIndex);\n    }\n  }\n\n  const mergedInvisibleSegments = Array.from(cachedConfig.segmentsHidden)\n    .filter((segmentIndex) => !segmentsToSetToVisible.includes(segmentIndex))\n    .concat(segmentsToSetToInvisible);\n\n  const { contourSets, segmentSpecificConfigs } = geometryIds.reduce(\n    (acc, geometryId) => {\n      const geometry = cache.getGeometry(geometryId);\n      const { data: contourSet } = geometry;\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const segmentSpecificConfig = getSegmentSpecificConfig(\n        contourRepresentation,\n        geometryId,\n        segmentIndex\n      );\n\n      acc.contourSets.push(contourSet);\n      acc.segmentSpecificConfigs[segmentIndex] = segmentSpecificConfig ?? {};\n\n      return acc;\n    },\n    { contourSets: [], segmentSpecificConfigs: {} }\n  );\n\n  const affectedSegments = [\n    ...mergedInvisibleSegments,\n    ...segmentsToSetToVisible,\n  ];\n\n  const hasCustomSegmentSpecificConfig = Object.values(\n    segmentSpecificConfigs\n  ).some((config) => Object.keys(config).length > 0);\n\n  let polyDataModified = false;\n\n  if (affectedSegments.length || hasCustomSegmentSpecificConfig) {\n    const appendPolyData = mapper.getInputData();\n    const appendScalars = appendPolyData.getPointData().getScalars();\n    const appendScalarsData = appendScalars.getData();\n    // below we will only manipulate the polyData of the contourSets that are affected\n    // by picking the correct offset in the scalarData array\n    let offset = 0;\n    contourSets.forEach((contourSet) => {\n      const segmentIndex = (contourSet as Types.IContourSet).getSegmentIndex();\n      const size = contourSet.getTotalNumberOfPoints();\n\n      if (\n        affectedSegments.includes(segmentIndex) ||\n        segmentSpecificConfigs[segmentIndex]?.fillAlpha // Todo: add others\n      ) {\n        const color = contourSet.getColor();\n        let visibility = mergedInvisibleSegments.includes(segmentIndex)\n          ? 0\n          : 255;\n\n        const segmentConfig = segmentSpecificConfigs[segmentIndex];\n        if (segmentConfig.fillAlpha !== undefined) {\n          visibility = segmentConfig.fillAlpha * 255;\n        }\n\n        for (let i = 0; i < size; ++i) {\n          appendScalarsData[offset + i * 4] = color[0];\n          appendScalarsData[offset + i * 4 + 1] = color[1];\n          appendScalarsData[offset + i * 4 + 2] = color[2];\n          appendScalarsData[offset + i * 4 + 3] = visibility;\n        }\n\n        polyDataModified = true;\n      }\n\n      offset = offset + size * 4;\n    });\n\n    if (polyDataModified) {\n      appendPolyData.modified();\n    }\n\n    setConfigCache(\n      segmentationRepresentationUID,\n      Object.assign({}, cachedConfig, {\n        segmentsHidden: new Set(segmentsHidden),\n      })\n    );\n\n    mapper.setLookupTable(lut);\n  }\n\n  viewport.render();\n}\n","import { Types } from '@cornerstonejs/core';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificContourRepresentation,\n} from '../../../types';\nimport { addContourSetsToElement } from './addContourSetsToElement';\nimport { updateContourSets } from './updateContourSets';\n\nexport function addOrUpdateContourSets(\n  viewport: Types.IVolumeViewport,\n  geometryIds: string[],\n  contourRepresentation: ToolGroupSpecificContourRepresentation,\n  contourRepresentationConfig: SegmentationRepresentationConfig\n) {\n  const { segmentationRepresentationUID } = contourRepresentation;\n  const actorUID = `CONTOUR_${segmentationRepresentationUID}`;\n  const actor = viewport.getActor(actorUID);\n\n  const addOrUpdateFn = actor ? updateContourSets : addContourSetsToElement;\n  addOrUpdateFn(\n    viewport,\n    geometryIds,\n    contourRepresentation,\n    contourRepresentationConfig,\n    actorUID\n  );\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the contour representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the contour representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeContourFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const actorEntries = (viewport as Types.IVolumeViewport).getActors();\n\n  // remove actors whose id has the same prefix as the segmentationRepresentationUID\n  const actorUIDsToRemove = actorEntries\n    .map(({ uid }) =>\n      uid.includes(segmentationRepresentationUID) ? uid : undefined\n    )\n    .filter(Boolean);\n\n  // @ts-ignore\n  viewport.removeActors(actorUIDsToRemove);\n}\n\nexport default removeContourFromElement;\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n  StackViewport,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationConfig from '../../../stateManagement/segmentation/config/segmentationConfig';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport {\n  RepresentationPublicInput,\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\nimport { addOrUpdateContourSets } from './addOrUpdateContourSets';\nimport removeContourFromElement from './removeContourFromElement';\nimport { deleteConfigCache } from './contourConfigCache';\n\n/**\n * It adds a new segmentation representation to the segmentation state\n * @param toolGroupId - The id of the toolGroup that the segmentation\n * belongs to\n * @param representationInput - RepresentationPublicInput\n * @param toolGroupSpecificConfig - The configuration that is specific to the toolGroup.\n * @returns The segmentationRepresentationUID\n */\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId } = representationInput;\n  const segmentationRepresentationUID = csUtils.uuidv4();\n  // Todo: make these configurable during representation input by user\n  const segmentsHidden = new Set() as Set<number>;\n  const visibility = true;\n  const colorLUTIndex = 0;\n  const active = true;\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: Representations.Contour,\n    segmentsHidden,\n    colorLUTIndex,\n    active,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: {},\n  };\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const mergedConfig = csUtils.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n  SegmentationState.addSegmentationRepresentation(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n  return segmentationRepresentationUID;\n}\n\n/**\n * It removes a segmentation representation from the tool group's viewports and\n * from the segmentation state\n * @param toolGroupId - The toolGroupId of the toolGroup that the\n * segmentationRepresentation belongs to.\n * @param segmentationRepresentationUID - This is the unique identifier\n * for the segmentation representation.\n * @param renderImmediate - If true, the viewport will be rendered\n * immediately after the segmentation representation is removed.\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeContourFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  deleteConfigCache(segmentationRepresentationUID);\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * It renders the contour sets for the given segmentation\n * @param viewport - The viewport object\n * @param representation - ToolGroupSpecificRepresentation\n * @param toolGroupConfig - This is the configuration object for the tool group\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representationConfig: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const { segmentationId } = representationConfig;\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const contourData = segmentation.representationData[Representations.Contour];\n  const { geometryIds } = contourData;\n\n  // We don't have a good way to handle stack viewports for contours at the moment.\n  // Plus, if we add a segmentation to one viewport, it gets added to all the viewports in the toolGroup too.\n  if (viewport instanceof StackViewport) {\n    return;\n  }\n\n  if (!geometryIds?.length) {\n    console.warn(\n      `No contours found for segmentationId ${segmentationId}. Skipping render.`\n    );\n  }\n\n  // add the contour sets to the viewport\n  addOrUpdateContourSets(\n    viewport,\n    geometryIds,\n    representationConfig,\n    toolGroupConfig\n  );\n}\n\nfunction _removeContourFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeContourFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nexport default {\n  render,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n};\n","import {\n  getEnabledElement,\n  addVolumesToViewports,\n  Types,\n  Enums,\n} from '@cornerstonejs/core';\n\n/**\n * It adds a labelmap segmentation representation of the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that will be rendered.\n * @param volumeId - The volume id of the labelmap.\n * @param segmentationRepresentationUID - The segmentation representation UID.\n *\n * @internal\n */\nasync function addLabelmapToElement(\n  element: HTMLDivElement,\n  volumeId: string,\n  segmentationRepresentationUID: string\n): Promise<void> {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n  const { id: viewportId } = viewport;\n\n  // Default to true since we are setting a new segmentation, however,\n  // in the event listener, we will make other segmentations visible/invisible\n  // based on the config\n  const visibility = true;\n  const immediateRender = false;\n  const suppressEvents = true;\n\n  // Todo: Right now we use MIP blend mode for the labelmap, since the\n  // composite blend mode has a non linear behavior regarding fill and line\n  // opacity. This should be changed to a custom labelmap blendMode which does\n  // what composite does, but with a linear behavior.\n  const volumeInputs: Types.IVolumeInput[] = [\n    {\n      volumeId,\n      actorUID: segmentationRepresentationUID,\n      visibility,\n      blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n    },\n  ];\n\n  // Add labelmap volumes to the viewports to be be rendered, but not force the render\n  await addVolumesToViewports(\n    renderingEngine,\n    volumeInputs,\n    [viewportId],\n    immediateRender,\n    suppressEvents\n  );\n}\n\nexport default addLabelmapToElement;\n","import { StackViewport, getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Remove the labelmap segmentation representation from the viewport's HTML Element.\n * NOTE: This function should not be called directly.\n *\n * @param element - The element that the segmentation is being added to.\n * @param segmentationRepresentationUID - The UID of the labelmap representation to remove.\n * @param removeFromCache - boolean\n *\n * @internal\n */\nfunction removeLabelmapFromElement(\n  element: HTMLDivElement,\n  segmentationRepresentationUID: string,\n  removeFromCache = false // Todo\n): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (viewport instanceof StackViewport) {\n    // Todo: we don't have stack segmentation yet\n    return;\n  }\n\n  (viewport as Types.IVolumeViewport).removeVolumeActors([\n    segmentationRepresentationUID,\n  ]);\n}\n\nexport default removeLabelmapFromElement;\n","import vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\n\nimport {\n  cache,\n  getEnabledElementByIds,\n  Types,\n  utilities,\n} from '@cornerstonejs/core';\n\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport * as SegmentationConfig from '../../../stateManagement/segmentation/config/segmentationConfig';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../../store/ToolGroupManager';\nimport type {\n  LabelmapConfig,\n  LabelmapRenderingConfig,\n} from '../../../types/LabelmapTypes';\nimport {\n  RepresentationPublicInput,\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../../types/SegmentationStateTypes';\n\nimport addLabelmapToElement from './addLabelmapToElement';\n\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\n\nconst MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\n\n/**\n * For each viewport, in the toolGroup it adds the segmentation labelmap\n * representation to its viewports.\n * @param toolGroup - the tool group that contains the viewports\n * @param representationInput - The segmentation representation input\n * @param toolGroupSpecificConfig - The configuration object for toolGroup\n *\n * @returns The UID of the new segmentation representation\n */\nasync function addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  const { segmentationId } = representationInput;\n  const segmentationRepresentationUID = utilities.uuidv4();\n\n  // Todo: make these configurable during representation input by user\n  const segmentsHidden = new Set() as Set<number>;\n  const colorLUTIndex = 0;\n  const active = true;\n  const cfun = vtkColorTransferFunction.newInstance();\n  const ofun = vtkPiecewiseFunction.newInstance();\n\n  ofun.addPoint(0, 0);\n\n  const toolGroupSpecificRepresentation: ToolGroupSpecificRepresentation = {\n    segmentationId,\n    segmentationRepresentationUID,\n    type: Representations.Labelmap,\n    segmentsHidden,\n    colorLUTIndex,\n    active,\n    segmentationRepresentationSpecificConfig: {},\n    segmentSpecificConfig: {},\n    config: {\n      cfun,\n      ofun,\n    },\n  };\n\n  // Update the toolGroup specific configuration\n  if (toolGroupSpecificConfig) {\n    // Since setting configuration on toolGroup will trigger a segmentationRepresentation\n    // update event, we don't want to trigger the event twice, so we suppress\n    // the first one\n    const currentToolGroupConfig =\n      SegmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n\n    const mergedConfig = utilities.deepMerge(\n      currentToolGroupConfig,\n      toolGroupSpecificConfig\n    );\n\n    SegmentationConfig.setToolGroupSpecificConfig(toolGroupId, {\n      renderInactiveSegmentations:\n        mergedConfig.renderInactiveSegmentations || true,\n      representations: {\n        ...mergedConfig.representations,\n      },\n    });\n  }\n\n  SegmentationState.addSegmentationRepresentation(\n    toolGroupId,\n    toolGroupSpecificRepresentation\n  );\n\n  return segmentationRepresentationUID;\n}\n\n/**\n * For each viewport, and for each segmentation, set the segmentation for the viewport's enabled element\n * Initializes the global and viewport specific state for the segmentation in the\n * SegmentationStateManager.\n * @param toolGroup - the tool group that contains the viewports\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param renderImmediate - If true, there will be a render call after the labelmap is removed\n */\nfunction removeSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  renderImmediate = false\n): void {\n  _removeLabelmapFromToolGroupViewports(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n  SegmentationState.removeSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  if (renderImmediate) {\n    const viewportsInfo = getToolGroup(toolGroupId).getViewportsInfo();\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      enabledElement.viewport.render();\n    });\n  }\n}\n\n/**\n * Checks if a segmentation data have the same frameOfReference as the series\n * displayed in a given viewport\n * @param viewport\n * @param referencedVolumeId volume id of the segmentation reference series\n * @returns\n */\nfunction isSameFrameOfReference(viewport, referencedVolumeId) {\n  // if the referencedVolumeId is not defined, we acted as before to not break\n  // applications as referencedVolumeId is inserted in this change\n  // Can modify that in the future commits\n  if (!referencedVolumeId) {\n    return true;\n  }\n  const defaultActor = viewport.getDefaultActor();\n  if (!defaultActor) {\n    return false;\n  }\n  const { uid: defaultActorUID } = defaultActor;\n  const volume = cache.getVolume(defaultActorUID);\n\n  if (volume) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (\n      referencedVolume &&\n      volume.metadata.FrameOfReferenceUID ===\n        referencedVolume.metadata.FrameOfReferenceUID\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * It takes the enabled element, the segmentation Id, and the configuration, and\n * it sets the segmentation for the enabled element as a labelmap\n * @param enabledElement - The cornerstone enabled element\n * @param segmentationId - The id of the segmentation to be rendered.\n * @param configuration - The configuration object for the labelmap.\n */\nasync function render(\n  viewport: Types.IVolumeViewport,\n  representation: ToolGroupSpecificRepresentation,\n  toolGroupConfig: SegmentationRepresentationConfig\n): Promise<void> {\n  const {\n    colorLUTIndex,\n    active,\n    segmentationId,\n    segmentationRepresentationUID,\n    segmentsHidden,\n    config: renderingConfig,\n  } = representation;\n\n  const segmentation = SegmentationState.getSegmentation(segmentationId);\n  const labelmapData =\n    segmentation.representationData[Representations.Labelmap];\n  const { volumeId: labelmapUID } = labelmapData;\n\n  const labelmap = cache.getVolume(labelmapUID);\n\n  if (!labelmap) {\n    throw new Error(`No Labelmap found for volumeId: ${labelmapUID}`);\n  }\n\n  if (!isSameFrameOfReference(viewport, labelmapData?.referencedVolumeId)) {\n    return;\n  }\n  let actorEntry = viewport.getActor(segmentationRepresentationUID);\n\n  if (!actorEntry) {\n    const segmentation = SegmentationState.getSegmentation(segmentationId);\n    const { volumeId } =\n      segmentation.representationData[Representations.Labelmap];\n    // only add the labelmap to ToolGroup viewports if it is not already added\n    await _addLabelmapToViewport(\n      viewport,\n      volumeId,\n      segmentationRepresentationUID\n    );\n\n    actorEntry = viewport.getActor(segmentationRepresentationUID);\n  }\n\n  if (!actorEntry) {\n    return;\n  }\n\n  const { cfun, ofun } = renderingConfig as LabelmapRenderingConfig;\n\n  const renderInactiveSegmentations =\n    toolGroupConfig.renderInactiveSegmentations;\n\n  _setLabelmapColorAndOpacity(\n    viewport.id,\n    actorEntry,\n    cfun,\n    ofun,\n    colorLUTIndex,\n    toolGroupConfig.representations[Representations.Labelmap],\n    representation,\n    active,\n    renderInactiveSegmentations,\n    segmentsHidden\n  );\n}\n\nfunction _setLabelmapColorAndOpacity(\n  viewportId: string,\n  actorEntry: Types.ActorEntry,\n  cfun: vtkColorTransferFunction,\n  ofun: vtkPiecewiseFunction,\n  colorLUTIndex: number,\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentation: ToolGroupSpecificRepresentation,\n  isActiveLabelmap: boolean,\n  renderInactiveSegmentations: boolean,\n  segmentsHidden: Set<number>\n): void {\n  const { segmentSpecificConfig, segmentationRepresentationSpecificConfig } =\n    segmentationRepresentation;\n\n  const segmentationRepresentationLabelmapConfig =\n    segmentationRepresentationSpecificConfig[Representations.Labelmap];\n\n  // Note: MAX_NUMBER_COLORS = 256 is needed because the current method to generate\n  // the default color table uses RGB.\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  const numColors = Math.min(256, colorLUT.length);\n  const volumeActor = actorEntry.actor as Types.VolumeActor;\n  const { uid: actorUID } = actorEntry;\n\n  // Note: right now outlineWidth and renderOutline are not configurable\n  // at the segment level, so we don't need to check for segment specific\n  // configuration in the loop, Todo: make them configurable at the segment level\n  const { outlineWidth, renderOutline, outlineOpacity } = _getLabelmapConfig(\n    toolGroupLabelmapConfig,\n    segmentationRepresentationLabelmapConfig,\n    isActiveLabelmap\n  );\n\n  // Todo: the below loop probably can be optimized so that we don't hit it\n  // unless a config has changed. Right now we get into the following loop\n  // even for brush drawing which does not makes sense\n  for (let i = 0; i < numColors; i++) {\n    const segmentIndex = i;\n    const segmentColor = colorLUT[segmentIndex];\n\n    const segmentSpecificLabelmapConfig =\n      segmentSpecificConfig[segmentIndex]?.[Representations.Labelmap];\n\n    const { fillAlpha, outlineWidth, renderFill, renderOutline } =\n      _getLabelmapConfig(\n        toolGroupLabelmapConfig,\n        segmentationRepresentationLabelmapConfig,\n        isActiveLabelmap,\n        segmentSpecificLabelmapConfig\n      );\n\n    const { forceOpacityUpdate, forceColorUpdate } =\n      _needsTransferFunctionUpdate(viewportId, actorUID, segmentIndex, {\n        fillAlpha,\n        renderFill,\n        renderOutline,\n        segmentColor,\n        outlineWidth,\n        segmentsHidden,\n      });\n\n    if (forceColorUpdate) {\n      cfun.addRGBPoint(\n        segmentIndex,\n        segmentColor[0] / MAX_NUMBER_COLORS,\n        segmentColor[1] / MAX_NUMBER_COLORS,\n        segmentColor[2] / MAX_NUMBER_COLORS\n      );\n    }\n\n    if (forceOpacityUpdate) {\n      if (renderFill) {\n        const segmentOpacity = segmentsHidden.has(segmentIndex)\n          ? 0\n          : (segmentColor[3] / 255) * fillAlpha;\n\n        ofun.removePoint(segmentIndex);\n        ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n      } else {\n        ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n      }\n    }\n  }\n\n  volumeActor.getProperty().setRGBTransferFunction(0, cfun);\n\n  ofun.setClamping(false);\n  volumeActor.getProperty().setScalarOpacity(0, ofun);\n\n  volumeActor.getProperty().setInterpolationTypeToNearest();\n\n  volumeActor.getProperty().setUseLabelOutline(renderOutline);\n\n  // @ts-ignore: setLabelOutlineWidth is not in the vtk.d.ts apparently\n  volumeActor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n  volumeActor.getProperty().setLabelOutlineThickness(outlineWidth);\n\n  // Set visibility based on whether actor visibility is specifically asked\n  // to be turned on/off (on by default) AND whether is is in active but\n  // we are rendering inactive labelmap\n  const visible = isActiveLabelmap || renderInactiveSegmentations;\n  volumeActor.setVisibility(visible);\n}\n\nfunction _getLabelmapConfig(\n  toolGroupLabelmapConfig: LabelmapConfig,\n  segmentationRepresentationLabelmapConfig: LabelmapConfig,\n  isActiveLabelmap: boolean,\n  segmentsLabelmapConfig?: LabelmapConfig\n) {\n  const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n\n  const configToUse = {\n    ...toolGroupLabelmapConfig,\n    ...segmentationRepresentationLabelmapConfig,\n    ...segmentLabelmapConfig,\n  };\n\n  const fillAlpha = isActiveLabelmap\n    ? configToUse.fillAlpha\n    : configToUse.fillAlphaInactive;\n  const outlineWidth = isActiveLabelmap\n    ? configToUse.outlineWidthActive\n    : configToUse.outlineWidthInactive;\n\n  const renderFill = isActiveLabelmap\n    ? configToUse.renderFill\n    : configToUse.renderFillInactive;\n\n  const renderOutline = configToUse.renderOutline;\n\n  const outlineOpacity = isActiveLabelmap\n    ? configToUse.outlineOpacity\n    : configToUse.outlineOpacityInactive;\n\n  return {\n    fillAlpha,\n    outlineWidth,\n    renderFill,\n    renderOutline,\n    outlineOpacity,\n  };\n}\n\nfunction _needsTransferFunctionUpdate(\n  viewportId: string,\n  actorUID: string,\n  segmentIndex: number,\n  {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    segmentColor,\n    outlineWidth,\n    segmentsHidden,\n  }: {\n    fillAlpha: number;\n    renderFill: boolean;\n    renderOutline: boolean;\n    outlineWidth: number;\n    segmentColor: number[];\n    segmentsHidden: Set<number>;\n  }\n) {\n  const cacheUID = `${viewportId}-${actorUID}-${segmentIndex}`;\n  const oldConfig = labelMapConfigCache.get(cacheUID);\n\n  if (!oldConfig) {\n    labelMapConfigCache.set(cacheUID, {\n      fillAlpha,\n      renderFill,\n      renderOutline,\n      outlineWidth,\n      segmentColor: segmentColor.slice(), // Create a copy\n      segmentsHidden: new Set(segmentsHidden), // Create a copy\n    });\n\n    return {\n      forceOpacityUpdate: true,\n      forceColorUpdate: true,\n    };\n  }\n\n  const {\n    fillAlpha: oldFillAlpha,\n    renderFill: oldRenderFill,\n    renderOutline: oldRenderOutline,\n    outlineWidth: oldOutlineWidth,\n    segmentColor: oldSegmentColor,\n    segmentsHidden: oldSegmentsHidden,\n  } = oldConfig;\n\n  const forceColorUpdate =\n    oldSegmentColor[0] !== segmentColor[0] ||\n    oldSegmentColor[1] !== segmentColor[1] ||\n    oldSegmentColor[2] !== segmentColor[2];\n\n  const forceOpacityUpdate =\n    oldSegmentColor[3] !== segmentColor[3] ||\n    oldFillAlpha !== fillAlpha ||\n    oldRenderFill !== renderFill ||\n    oldRenderOutline !== renderOutline ||\n    oldOutlineWidth !== outlineWidth ||\n    oldSegmentsHidden.has(segmentIndex) !== segmentsHidden.has(segmentIndex);\n\n  // update the cache\n  labelMapConfigCache.set(cacheUID, {\n    fillAlpha,\n    renderFill,\n    renderOutline,\n    outlineWidth,\n    segmentColor: segmentColor.slice(), // Create a copy\n    segmentsHidden: new Set(segmentsHidden), // Create a copy\n  });\n\n  return {\n    forceOpacityUpdate,\n    forceColorUpdate,\n  };\n}\n\nfunction _removeLabelmapFromToolGroupViewports(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    throw new Error(`ToolGroup with ToolGroupId ${toolGroupId} does not exist`);\n  }\n\n  const { viewportsInfo } = toolGroup;\n\n  for (const viewportInfo of viewportsInfo) {\n    const { viewportId, renderingEngineId } = viewportInfo;\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    removeLabelmapFromElement(\n      enabledElement.viewport.element,\n      segmentationRepresentationUID\n    );\n  }\n}\n\nasync function _addLabelmapToViewport(\n  viewport: Types.IVolumeViewport,\n  volumeId: string,\n  segmentationRepresentationUID: string\n): Promise<void> {\n  await addLabelmapToElement(\n    viewport.element,\n    volumeId,\n    segmentationRepresentationUID\n  );\n}\n\nexport default {\n  render,\n  addSegmentationRepresentation,\n  removeSegmentationRepresentation,\n};\n","import {\n  getEnabledElementByIds,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { setSegmentationVisibility } from '../../stateManagement/segmentation/config/segmentationVisibility';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/segmentationState';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport { PublicToolProps, ToolProps } from '../../types';\nimport { BaseTool } from '../base';\n\nimport {\n  SegmentationRepresentationConfig,\n  ToolGroupSpecificRepresentation,\n} from '../../types/SegmentationStateTypes';\nimport { surfaceDisplay } from './Surface';\nimport { contourDisplay } from './Contour';\nimport { labelmapDisplay } from './Labelmap';\n\n/**\n * In Cornerstone3DTools, displaying of segmentations are handled by the SegmentationDisplayTool.\n * Generally, any Segmentation can be viewed in various representations such as\n * labelmap (3d), contours, surface etc. As of now, Cornerstone3DTools only implements\n * Labelmap representation.\n *\n * SegmentationDisplayTool works at ToolGroup level, and is responsible for displaying the\n * segmentation representation for ALL viewports of a toolGroup, this way we can support complex\n * scenarios for displaying segmentations.\n *\n * Current Limitations:\n * - Only supports rendering of the volumetric segmentations in 3D space. (StackViewport segmentations are not supported yet)\n * - Labelmap representation is the only supported representation for now.\n *\n * Similar to other tools in Cornerstone3DTools, the SegmentationDisplayTool should\n * be added to the CornerstoneTools by calling cornerstoneTools.addTool(SegmentationDisplayTool)\n * and a toolGroup should be created for it using the ToolGroupManager API, finally\n * viewports information such as viewportId and renderingEngineId should be provided\n * to the toolGroup and the SegmentationDisplayTool should be set to be activated.\n *\n *\n */\nclass SegmentationDisplayTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility true\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          true\n        );\n      }\n    );\n  }\n\n  onSetToolDisabled(): void {\n    const toolGroupId = this.toolGroupId;\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // for each segmentationData, make the visibility false\n    toolGroupSegmentationRepresentations.forEach(\n      (segmentationRepresentation) => {\n        setSegmentationVisibility(\n          toolGroupId,\n          segmentationRepresentation.segmentationRepresentationUID,\n          false\n        );\n      }\n    );\n  }\n\n  /**\n   * It is used to trigger the render for each segmentations in the toolGroup.\n   * Based on the segmentation representation type, it will call the corresponding\n   * render function.\n   *\n   * @param toolGroupId - the toolGroupId\n   */\n  renderSegmentation = (toolGroupId: string): void => {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      return;\n    }\n\n    const toolGroupSegmentationRepresentations =\n      getSegmentationRepresentations(toolGroupId);\n\n    if (\n      !toolGroupSegmentationRepresentations ||\n      toolGroupSegmentationRepresentations.length === 0\n    ) {\n      return;\n    }\n\n    // toolGroup Viewports\n    const toolGroupViewports = toolGroup.viewportsInfo.map(\n      ({ renderingEngineId, viewportId }) => {\n        const enabledElement = getEnabledElementByIds(\n          viewportId,\n          renderingEngineId\n        );\n\n        if (enabledElement) {\n          return enabledElement.viewport;\n        }\n      }\n    );\n\n    // Render each segmentationData, in each viewport in the toolGroup\n    const segmentationRenderList = toolGroupSegmentationRepresentations.map(\n      (representation: ToolGroupSpecificRepresentation) => {\n        const config = this._getMergedRepresentationsConfig(toolGroupId);\n\n        const viewportsRenderList = [];\n\n        const renderers = {\n          [Representations.Labelmap]: labelmapDisplay,\n          [Representations.Contour]: contourDisplay,\n          [Representations.Surface]: surfaceDisplay,\n        };\n\n        const display = renderers[representation.type];\n\n        for (const viewport of toolGroupViewports) {\n          const renderedViewport = display.render(\n            viewport as Types.IVolumeViewport,\n            representation,\n            config\n          );\n\n          viewportsRenderList.push(renderedViewport);\n        }\n        return viewportsRenderList;\n      }\n    );\n\n    Promise.allSettled(segmentationRenderList).then(() => {\n      // for all viewports in the toolGroup trigger a re-render\n      toolGroupViewports.forEach((viewport) => {\n        viewport.render();\n      });\n    });\n  };\n\n  /**\n   * Merge the toolGroup specific configuration with the default global configuration\n   * @param toolGroupId\n   * @returns\n   */\n  _getMergedRepresentationsConfig(\n    toolGroupId: string\n  ): SegmentationRepresentationConfig {\n    const toolGroupConfig =\n      segmentationConfig.getToolGroupSpecificConfig(toolGroupId);\n    const globalConfig = segmentationConfig.getGlobalConfig();\n\n    // merge two configurations and override the global config\n    const mergedConfig = csUtils.deepMerge(globalConfig, toolGroupConfig);\n\n    return mergedConfig;\n  }\n}\n\nSegmentationDisplayTool.toolName = 'SegmentationDisplay';\nexport default SegmentationDisplayTool;\n","import {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\nimport { Events as csToolsEvents } from '../../enums';\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../../store/ToolGroupManager';\n\nimport SegmentationDisplayTool from '../../tools/displayTools/SegmentationDisplayTool';\nimport { SegmentationRenderedEventDetail } from '../../types/EventTypes';\n\n/**\n * SegmentationRenderingEngine is a class that is responsible for rendering\n * segmentations for a toolGroup. It will call SegmentationDisplayTool to render the segmentation\n * based on the segmentation data and their configurations. Note: This is a Singleton class\n * and should not be instantiated directly. To trigger a render for all the\n * segmentations of a tool group you can use.\n *\n * ```\n * triggerSegmentationRender(toolGroupId)\n * ```\n */\nclass SegmentationRenderingEngine {\n  private _needsRender: Set<string> = new Set();\n  private _animationFrameSet = false;\n  private _animationFrameHandle: number | null = null;\n  public hasBeenDestroyed: boolean;\n\n  public removeToolGroup(toolGroupId) {\n    this._needsRender.delete(toolGroupId);\n\n    if (this._needsRender.size === 0) {\n      this._reset();\n    }\n  }\n\n  public renderToolGroupSegmentations(toolGroupId): void {\n    this._setToolGroupSegmentationToBeRenderedNextFrame([toolGroupId]);\n  }\n\n  /**\n   *  _throwIfDestroyed Throws an error if trying to interact with the `RenderingEngine`\n   * instance after its `destroy` method has been called.\n   */\n  private _throwIfDestroyed() {\n    if (this.hasBeenDestroyed) {\n      throw new Error(\n        'this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.'\n      );\n    }\n  }\n\n  private _setToolGroupSegmentationToBeRenderedNextFrame(\n    toolGroupIds: string[]\n  ) {\n    // Add the viewports to the set of flagged viewports\n    toolGroupIds.forEach((toolGroupId) => {\n      this._needsRender.add(toolGroupId);\n    });\n\n    // Render any flagged viewports\n    this._render();\n  }\n\n  /**\n   *  _render Sets up animation frame if necessary\n   */\n  private _render() {\n    // If we have viewports that need rendering and we have not already\n    // set the RAF callback to run on the next frame.\n    if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n      this._animationFrameHandle = window.requestAnimationFrame(\n        this._renderFlaggedToolGroups\n      );\n\n      // Set the flag that we have already set up the next RAF call.\n      this._animationFrameSet = true;\n    }\n  }\n\n  private _renderFlaggedToolGroups = () => {\n    this._throwIfDestroyed();\n\n    // for each toolGroupId insides the _needsRender set, render the segmentation\n    const toolGroupIds = Array.from(this._needsRender.values());\n\n    for (const toolGroupId of toolGroupIds) {\n      this._triggerRender(toolGroupId);\n\n      // This viewport has been rendered, we can remove it from the set\n      this._needsRender.delete(toolGroupId);\n\n      // If there is nothing left that is flagged for rendering, stop here\n      // and allow RAF to be called again\n      if (this._needsRender.size === 0) {\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        return;\n      }\n    }\n  };\n  _triggerRender(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n\n    if (!toolGroup) {\n      console.warn(`No tool group found with toolGroupId: ${toolGroupId}`);\n      return;\n    }\n\n    const { viewportsInfo } = toolGroup;\n    const viewports = [];\n\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const renderingEngine = getRenderingEngine(renderingEngineId);\n\n      if (!renderingEngine) {\n        console.warn('rendering Engine has been destroyed');\n        return;\n      }\n\n      viewports.push(renderingEngine.getViewport(viewportId));\n    });\n\n    const segmentationDisplayToolInstance = toolGroup.getToolInstance(\n      SegmentationDisplayTool.toolName\n    ) as SegmentationDisplayTool;\n    if (!segmentationDisplayToolInstance) {\n      console.warn('No segmentation tool found inside', toolGroupId);\n      return;\n    }\n\n    function onSegmentationRender(evt: Types.EventTypes.ImageRenderedEvent) {\n      const { element, viewportId, renderingEngineId } = evt.detail;\n\n      element.removeEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender as EventListener\n      );\n\n      const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n\n      if (!toolGroup) {\n        console.warn('toolGroup has been destroyed');\n        return;\n      }\n\n      const eventDetail: SegmentationRenderedEventDetail = {\n        toolGroupId: toolGroup.id,\n        viewportId,\n      };\n\n      triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n        ...eventDetail,\n      });\n    }\n\n    // Todo: for other representations we probably need the drawSVG, but right now we are not using it\n    // drawSvg(element, (svgDrawingHelper) => {\n    //   const handleDrawSvg = (tool) => {\n    //     if (tool instanceof SegmentationDisplayTool && tool.renderAnnotation) {\n    //       tool.renderAnnotation({ detail: eventDetail })\n    //       triggerEvent(element, csToolsEvents.SEGMENTATION_RENDERED, { ...eventDetail })\n    //     }\n    //   }\n    //   enabledTools.forEach(handleDrawSvg)\n    // })\n\n    viewports.forEach(({ element }) => {\n      element.addEventListener(\n        Enums.Events.IMAGE_RENDERED,\n        onSegmentationRender\n      );\n    });\n\n    segmentationDisplayToolInstance.renderSegmentation(toolGroupId);\n  }\n\n  /**\n   *  _reset Resets the `RenderingEngine`\n   */\n  private _reset() {\n    window.cancelAnimationFrame(this._animationFrameHandle);\n\n    this._needsRender.clear();\n    this._animationFrameSet = false;\n    this._animationFrameHandle = null;\n  }\n}\n\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\n\n/**\n * It triggers a render for all the segmentations of the tool group with the given Id.\n * @param toolGroupId - The Id of the tool group to render.\n */\nfunction triggerSegmentationRender(toolGroupId: string): void {\n  segmentationRenderingEngine.renderToolGroupSegmentations(toolGroupId);\n}\n\nexport { segmentationRenderingEngine, triggerSegmentationRender };\nexport default triggerSegmentationRender;\n","import { cache } from '@cornerstonejs/core';\n\nimport triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport * as SegmentationState from '../../stateManagement/segmentation/segmentationState';\nimport { SegmentationDataModifiedEventType } from '../../types/EventTypes';\n\n/** A callback function that is called when the segmentation data is modified which\n *  often is as a result of tool interactions e.g., scissors, eraser, etc.\n */\nconst onSegmentationDataModified = function (\n  evt: SegmentationDataModifiedEventType\n): void {\n  const { segmentationId, modifiedSlicesToUse } = evt.detail;\n\n  const { representationData, type } =\n    SegmentationState.getSegmentation(segmentationId);\n\n  let toolGroupIds;\n  if (type === SegmentationRepresentations.Labelmap) {\n    // get the volume from cache, we need the openGLTexture to be updated to GPU\n    const segmentationVolume = cache.getVolume(\n      representationData[type].volumeId\n    );\n\n    if (!segmentationVolume) {\n      console.warn('segmentation not found in cache');\n      return;\n    }\n\n    const { imageData, vtkOpenGLTexture } = segmentationVolume;\n\n    // Update the texture for the volume in the GPU\n    let slicesToUpdate;\n    if (modifiedSlicesToUse && Array.isArray(modifiedSlicesToUse)) {\n      slicesToUpdate = modifiedSlicesToUse;\n    } else {\n      const numSlices = imageData.getDimensions()[2];\n      slicesToUpdate = [...Array(numSlices).keys()];\n    }\n\n    slicesToUpdate.forEach((i) => {\n      vtkOpenGLTexture.setUpdatedFrame(i);\n    });\n\n    // Trigger modified on the imageData to update the image\n    imageData.modified();\n    toolGroupIds =\n      SegmentationState.getToolGroupIdsWithSegmentation(segmentationId);\n  } else {\n    throw new Error(\n      `onSegmentationDataModified: representationType ${type} not supported yet`\n    );\n  }\n\n  toolGroupIds.forEach((toolGroupId) => {\n    triggerSegmentationRender(toolGroupId);\n  });\n};\n\nexport default onSegmentationDataModified;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationModifiedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationStateModified` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationModifiedListener = function (\n  evt: SegmentationRepresentationModifiedEventType\n): void {\n  const { toolGroupId } = evt.detail;\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationModifiedListener;\n","import triggerSegmentationRender from '../../utilities/segmentation/triggerSegmentationRender';\nimport { SegmentationRepresentationRemovedEventType } from '../../types/EventTypes';\n\n/** A function that listens to the `segmentationRepresentationRemoved` event and triggers\n * the `triggerSegmentationRender` function. This function is called when the\n * segmentation state or config is modified.\n */\nconst segmentationRepresentationRemovedEventListener = function (\n  evt: SegmentationRepresentationRemovedEventType\n): void {\n  const { toolGroupId, segmentationRepresentationUID } = evt.detail;\n\n  triggerSegmentationRender(toolGroupId);\n};\n\nexport default segmentationRepresentationRemovedEventListener;\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\n\nimport {\n  getSegmentationRepresentations,\n  getSegmentationRepresentationByUID,\n} from './segmentationState';\n\n/**\n * Remove the segmentation representation (representation) from the viewports of the toolGroup.\n * @param toolGroupId - The Id of the toolGroup to remove the segmentation from.\n * @param segmentationRepresentationUIDs - The UIDs of the segmentation representations to remove.\n * @param immediate - if True the viewport will be re-rendered immediately.\n */\nfunction removeSegmentationsFromToolGroup(\n  toolGroupId: string,\n  segmentationRepresentationUIDs?: string[] | undefined,\n  immediate?: boolean\n): void {\n  const toolGroupSegRepresentations =\n    getSegmentationRepresentations(toolGroupId);\n\n  if (\n    !toolGroupSegRepresentations ||\n    toolGroupSegRepresentations.length === 0\n  ) {\n    return;\n  }\n\n  const toolGroupSegRepresentationUIDs = toolGroupSegRepresentations.map(\n    (representation) => representation.segmentationRepresentationUID\n  );\n\n  let segRepresentationUIDsToRemove = segmentationRepresentationUIDs;\n  if (segRepresentationUIDsToRemove) {\n    // make sure the segmentationDataUIDs that are going to be removed belong\n    // to the toolGroup\n    const invalidSegRepresentationUIDs = segmentationRepresentationUIDs.filter(\n      (segRepresentationUID) =>\n        !toolGroupSegRepresentationUIDs.includes(segRepresentationUID)\n    );\n\n    if (invalidSegRepresentationUIDs.length > 0) {\n      throw new Error(\n        `The following segmentationRepresentationUIDs are not part of the toolGroup: ${JSON.stringify(\n          invalidSegRepresentationUIDs\n        )}`\n      );\n    }\n  } else {\n    // remove all segmentation representations\n    segRepresentationUIDsToRemove = toolGroupSegRepresentationUIDs;\n  }\n\n  segRepresentationUIDsToRemove.forEach((segmentationDataUID) => {\n    _removeSegmentation(toolGroupId, segmentationDataUID, immediate);\n  });\n}\n\nfunction _removeSegmentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  immediate?: boolean\n): void {\n  const segmentationRepresentation = getSegmentationRepresentationByUID(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  const { type } = segmentationRepresentation;\n\n  if (type === SegmentationRepresentations.Labelmap) {\n    labelmapDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else if (type === SegmentationRepresentations.Contour) {\n    contourDisplay.removeSegmentationRepresentation(\n      toolGroupId,\n      segmentationRepresentationUID,\n      immediate\n    );\n  } else {\n    throw new Error(`The representation ${type} is not supported yet`);\n  }\n}\n\nexport default removeSegmentationsFromToolGroup;\n","import { state } from '../index';\nimport { removeSegmentationsFromToolGroup } from '../../stateManagement/segmentation';\nimport { segmentationRenderingEngine } from '../../utilities/segmentation/triggerSegmentationRender';\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it\n\n/**\n * Given a tool group Id, destroy the toolGroup. It will also cleanup all segmentations\n * associated with that tool group too\n *\n * @param toolGroupId - The Id of the tool group to be destroyed.\n */\nfunction destroyToolGroup(toolGroupId: string): void {\n  const toolGroupIndex = state.toolGroups.findIndex(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupIndex > -1) {\n    segmentationRenderingEngine.removeToolGroup(toolGroupId);\n    // Todo: this should not happen here)\n    removeSegmentationsFromToolGroup(toolGroupId);\n    state.toolGroups.splice(toolGroupIndex, 1);\n  }\n}\n\nexport default destroyToolGroup;\n","// `BaseManager` or IManager interface for duplicate API between ToolGroup/Synchronizer?\nimport { state as csToolsState } from '../index';\nimport destroyToolGroup from './destroyToolGroup';\n\n// ToolGroups function entirely by their \"state\" being queried and leveraged\n// removing a ToolGroup from state is equivalent to killing it. Calling\n// destroyToolGroup() to make sure the SegmentationDisplayTools\n// have been removed from the toolGroup Viewports. //Todo: this makes more sense\n// to be based on events, but we don't have any toolGroup created/removed events\n\n/**\n * Destroy all tool groups\n */\nfunction destroy(): void {\n  const toolGroups = [...csToolsState.toolGroups];\n\n  for (const toolGroup of toolGroups) {\n    destroyToolGroup(toolGroup.id);\n  }\n\n  csToolsState.toolGroups = [];\n}\n\nexport default destroy;\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { getDefaultSegmentationStateManager } from './stateManagement/segmentation/segmentationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport {\n  annotationSelectionListener,\n  segmentationDataModifiedEventListener,\n  segmentationRepresentationModifiedEventListener,\n  segmentationRepresentationRemovedEventListener,\n  segmentationModifiedListener,\n  annotationModifiedListener,\n} from './eventListeners';\n\nimport * as ToolGroupManager from './store/ToolGroupManager';\n\nlet csToolsInitialized = false;\n\n/**\n * Initialize the cornerstoneTools package. It will add event listeners for mouse\n * and keyboard events.\n * @param defaultConfiguration - A configuration object that will be used to\n * initialize the tool.\n */\nexport function init(defaultConfiguration = {}): void {\n  if (csToolsInitialized) {\n    return;\n  }\n\n  _addCornerstoneEventListeners();\n  _addCornerstoneToolsEventListeners();\n\n  csToolsInitialized = true;\n}\n\n/**\n * It destroys and cleanup state for cornerstone3DTools. It removes all the tools\n * that were added to the tool groups and restore states. It also removes all\n * event listeners.\n */\nexport function destroy(): void {\n  _removeCornerstoneEventListeners();\n  _removeCornerstoneToolsEventListeners();\n\n  // Important: destroy ToolGroups first, in order for cleanup to work correctly for the\n  // added tools.\n  ToolGroupManager.destroy();\n\n  // Remove all tools\n  resetCornerstoneToolsState();\n\n  // remove all annotation.\n  const annotationManager = getAnnotationManager();\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  annotationManager.restoreAnnotations({});\n  segmentationStateManager.resetState();\n  csToolsInitialized = false;\n}\n\n/**\n * Wires up event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n * @internal\n */\nfunction _addCornerstoneEventListeners(): void {\n  // Clear any listeners that may already be set\n  _removeCornerstoneEventListeners();\n\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n}\n\n/**\n * Removes event listeners for the Cornerstone#ElementDisabled and\n * Cornerstone#ElementEnabled events.\n *\n */\nfunction _removeCornerstoneEventListeners(): void {\n  const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n  const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n\n  eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n  eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n}\n\n/**\n * It adds an event listener to the event target (the cornerstoneTools object) for\n * the annotation selected and annotation modified events.\n */\nfunction _addCornerstoneToolsEventListeners() {\n  // Clear any listeners that may already be set\n  _removeCornerstoneToolsEventListeners();\n\n  /**\n   * Annotation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.addEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\n/**\n * Remove the event listener for the the annotation selected and annotation modified events.\n */\nfunction _removeCornerstoneToolsEventListeners() {\n  /**\n   * Annotation\n   */\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_MODIFIED,\n    annotationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE,\n    annotationSelectionListener\n  );\n\n  /**\n   * Segmentation\n   */\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_MODIFIED,\n    segmentationModifiedListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED,\n    segmentationDataModifiedEventListener\n  );\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED,\n    segmentationRepresentationModifiedEventListener\n  );\n\n  eventTarget.removeEventListener(\n    TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_REMOVED,\n    segmentationRepresentationRemovedEventListener\n  );\n}\n\nexport default init;\n","import { state } from './state';\n\n/**\n * Adds the tool class to the cornerstoneTools to be used later. This function\n * should be called before creating the toolGroups and adding tools and setting their mode.\n * The flow is:\n * - addTool(ToolClass) // where ToolClass is the tool constructor imported from CornerstoneTools or created by a 3rd party\n * - createToolGroup(toolGroupId)\n * - toolGroup.addTool(${toolName}) // NOT THE TOOL CLASS\n * - toolGroup.setToolActive(${toolName})\n *\n * @param ToolClass - A tool calls to instantiate.\n * @param toolOptions - The tool-specific configuration options for the tool.\n * @returns\n */\nexport function addTool(ToolClass): void {\n  // Check if tool exists and name is not undefined\n  const toolName = ToolClass.toolName;\n  const toolAlreadyAdded = state.tools[toolName] !== undefined;\n\n  if (!toolName) {\n    throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n  }\n\n  if (toolAlreadyAdded) {\n    throw new Error(`${toolName} has already been added globally`);\n  }\n\n  // Stores the toolNames and ToolClass to be instantiated in the toolGroup on toolGroup.addTool\n  state.tools[toolName] = {\n    toolClass: ToolClass,\n  };\n}\n\n/**\n * Removes the tool class from the cornerstoneTools.\n *\n * @param ToolClass - A tool calls to instantiate.\n */\nexport function removeTool(ToolClass): void {\n  const toolName = ToolClass.toolName;\n\n  if (!toolName) {\n    throw new Error(`No tool found for: ${ToolClass.name}`);\n  }\n\n  if (!state.tools[toolName] !== undefined) {\n    delete state.tools[toolName];\n  } else {\n    throw new Error(\n      `${toolName} cannot be removed because it has not been added`\n    );\n  }\n}\n\nexport default addTool;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\n\n/**\n * Cancel the current active manipulation that is being performed on the provided\n * element. It filters all the active and passive tools for the enabledElement\n * and calls cancel() method for all of them, and returns the tool that has executed its\n * cancellation (returned its annotationUID), since tools that are not being manipulated will\n * short circuit early. Note: not all tools currently implement a cancel method.\n *\n * @param element - canvas element\n * @returns annotationUID that is cancelled\n */\nexport default function cancelActiveManipulations(\n  element: HTMLDivElement\n): string | undefined {\n  const tools = getToolsWithModesForElement(element, [\n    ToolModes.Active,\n    ToolModes.Passive,\n  ]);\n\n  const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n  for (const { tool } of toolsWithData) {\n    const annotationUID = tool.cancel(element);\n    if (annotationUID) {\n      return annotationUID;\n    }\n  }\n}\n","import {\n  getRenderingEngine,\n  getEnabledElement,\n  Enums,\n  Types,\n} from '@cornerstonejs/core';\n\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Synchronizer is a class that listens to a specific event on a specific source\n * targets and fires a specific event on a specific target elements. Use cases\n * include: synchronizing a camera between two viewports, synchronizing a\n * windowLevel between various viewports.\n */\nclass Synchronizer {\n  //\n  private _enabled: boolean;\n  private _eventName: string;\n  private _eventHandler: ISynchronizerEventHandler;\n  private _ignoreFiredEvents: boolean;\n  private _sourceViewports: Array<Types.IViewportId>;\n  private _targetViewports: Array<Types.IViewportId>;\n  private _viewportOptions: Record<string, Record<string, unknown>> = {};\n  private _options: any;\n  public id: string;\n\n  constructor(\n    synchronizerId: string,\n    eventName: string,\n    eventHandler: ISynchronizerEventHandler,\n    options?: any\n  ) {\n    this._enabled = true;\n    this._eventName = eventName;\n    this._eventHandler = eventHandler;\n    this._ignoreFiredEvents = false;\n    this._sourceViewports = [];\n    this._targetViewports = [];\n    this._options = options || {};\n\n    //\n    this.id = synchronizerId;\n  }\n\n  /**\n   * \"Returns true if the synchronizer is disabled.\"\n   * @returns A boolean value.\n   */\n  public isDisabled(): boolean {\n    return !this._enabled || !this._hasSourceElements();\n  }\n\n  /**\n   * Sets the options for the viewport id.  This can be used to\n   * provide configuration on a viewport basis for things like offsets\n   * to the general synchronization, or turn on/off synchronization of certain\n   * attributes.\n   */\n  public setOptions(\n    viewportId: string,\n    options: Record<string, unknown> = {}\n  ): void {\n    this._viewportOptions[viewportId] = options;\n  }\n\n  /** Gets the options for the given viewport id */\n  public getOptions(viewportId: string): Record<string, unknown> | undefined {\n    return this._viewportOptions[viewportId];\n  }\n\n  /**\n   * Add a viewport to the list of targets and sources both.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public add(viewportInfo: Types.IViewportId): void {\n    this.addTarget(viewportInfo);\n    this.addSource(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of sources (source ONLY)\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addSource(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._sourceViewports, viewportInfo)) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = viewportInfo;\n\n    const { element } =\n      getRenderingEngine(renderingEngineId).getViewport(viewportId);\n\n    // @ts-ignore\n    element.addEventListener(this._eventName, this._onEvent.bind(this));\n    this._updateDisableHandlers();\n\n    this._sourceViewports.push(viewportInfo);\n  }\n\n  /**\n   * Add a viewport to the list of viewports that will get the eventHandler\n   * executed when the event is fired on the source viewport.\n   * @param viewportInfo - The viewportId and its renderingEngineId to add to the list of targets and sources.\n   */\n  public addTarget(viewportInfo: Types.IViewportId): void {\n    if (_containsViewport(this._targetViewports, viewportInfo)) {\n      return;\n    }\n\n    this._targetViewports.push(viewportInfo);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Get the list of source viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getSourceViewports(): Array<Types.IViewportId> {\n    return this._sourceViewports;\n  }\n\n  /**\n   * Get the list of target viewports (as {viewportId, renderingEngineId} objects)\n   * @returns An array of {viewportId, renderingEngineId} objects.\n   */\n  public getTargetViewports(): Array<Types.IViewportId> {\n    return this._targetViewports;\n  }\n\n  public destroy(): void {\n    this._sourceViewports.forEach((s) => this.removeSource(s));\n    this._targetViewports.forEach((t) => this.removeTarget(t));\n  }\n\n  /**\n   * Remove the viewport from the list of targets and sources\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public remove(viewportInfo: Types.IViewportId): void {\n    this.removeTarget(viewportInfo);\n    this.removeSource(viewportInfo);\n  }\n\n  /**\n   * Remove the viewport from the list of source viewports\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   */\n  public removeSource(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    const element = _getViewportElement(viewportInfo);\n\n    this._sourceViewports.splice(index, 1);\n    // @ts-ignore\n    element.removeEventListener(this._eventName, this._eventHandler);\n    this._updateDisableHandlers();\n  }\n\n  /**\n   * Remove the viewport from the list of viewports that are currently targeted by\n   * this handler\n   * @param viewportInfo - The viewport info including viewportId and renderingEngineId.\n   *\n   */\n  public removeTarget(viewportInfo: Types.IViewportId): void {\n    const index = _getViewportIndex(this._targetViewports, viewportInfo);\n\n    if (index === -1) {\n      return;\n    }\n\n    this._targetViewports.splice(index, 1);\n    this._updateDisableHandlers();\n  }\n\n  public hasSourceViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._sourceViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  public hasTargetViewport(\n    renderingEngineId: string,\n    viewportId: string\n  ): boolean {\n    return _containsViewport(this._targetViewports, {\n      renderingEngineId,\n      viewportId,\n    });\n  }\n\n  private fireEvent(sourceViewport: Types.IViewportId, sourceEvent: any): void {\n    if (this.isDisabled() || this._ignoreFiredEvents) {\n      return;\n    }\n\n    this._ignoreFiredEvents = true;\n    const promises = [];\n    try {\n      for (let i = 0; i < this._targetViewports.length; i++) {\n        const targetViewport = this._targetViewports[i];\n        const targetIsSource =\n          sourceViewport.viewportId === targetViewport.viewportId;\n\n        if (targetIsSource) {\n          continue;\n        }\n        promises.push(\n          this._eventHandler(\n            this,\n            sourceViewport,\n            targetViewport,\n            sourceEvent,\n            this._options\n          )\n        );\n      }\n    } catch (ex) {\n      console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n    } finally {\n      if (promises.length) {\n        Promise.allSettled(promises).then(() => {\n          this._ignoreFiredEvents = false;\n        });\n      } else {\n        this._ignoreFiredEvents = false;\n      }\n    }\n  }\n\n  private _onEvent = (evt: any): void => {\n    if (this._ignoreFiredEvents === true) {\n      return;\n    }\n\n    // If no target viewports, then return immediately, this is useful\n    // when switching between layouts, when previous layout has disabled\n    // its viewports, and the new layout has not yet enabled them.\n    // Right now we don't \"delete\" the synchronizer if all source and targets\n    // are removed, but we may want to do that in the future.\n    if (!this._targetViewports.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(evt.currentTarget);\n\n    if (!enabledElement) {\n      return;\n    }\n\n    const { renderingEngineId, viewportId } = enabledElement;\n\n    // If the viewport has been removed from the synchronizer before the event is\n    // fired, then return immediately.\n    if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n      return;\n    }\n\n    this.fireEvent(\n      {\n        renderingEngineId,\n        viewportId,\n      },\n      evt\n    );\n  };\n\n  private _hasSourceElements(): boolean {\n    return this._sourceViewports.length !== 0;\n  }\n\n  private _updateDisableHandlers(): void {\n    const viewports = _getUniqueViewports(\n      this._sourceViewports,\n      this._targetViewports\n    );\n    const _remove = this.remove;\n    const disableHandler = (elementDisabledEvent) => {\n      _remove(elementDisabledEvent.detail.element);\n    };\n\n    viewports.forEach(function (vUid) {\n      const renderingEngine = getRenderingEngine(\n        vUid.renderingEngineId\n      ).getViewport(vUid.viewportId);\n\n      if (!renderingEngine) {\n        return;\n      }\n\n      const { element } = renderingEngine;\n\n      element.removeEventListener(\n        Enums.Events.ELEMENT_DISABLED,\n        disableHandler\n      );\n      element.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n    });\n  }\n}\n\nfunction _getUniqueViewports(\n  vp1: Array<Types.IViewportId>,\n  vp2: Array<Types.IViewportId>\n): Array<Types.IViewportId> {\n  const unique = [];\n\n  const vps = vp1.concat(vp2);\n\n  for (let i = 0; i < vps.length; i++) {\n    const vp = vps[i];\n    if (\n      !unique.some(\n        (u) =>\n          vp.renderingEngineId === u.renderingEngineId &&\n          vp.viewportId === u.viewportId\n      )\n    ) {\n      unique.push(vp);\n    }\n  }\n\n  return unique;\n}\n\nfunction _getViewportIndex(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n): number {\n  return arr.findIndex(\n    (ar) =>\n      vp.renderingEngineId === ar.renderingEngineId &&\n      vp.viewportId === ar.viewportId\n  );\n}\n\nfunction _containsViewport(\n  arr: Array<Types.IViewportId>,\n  vp: Types.IViewportId\n) {\n  return arr.some(\n    (ar) =>\n      ar.renderingEngineId === vp.renderingEngineId &&\n      ar.viewportId === vp.viewportId\n  );\n}\n\nfunction _getViewportElement(vp: Types.IViewportId): HTMLDivElement {\n  const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(`No RenderingEngine for Id: ${vp.renderingEngineId}`);\n  }\n\n  return renderingEngine.getViewport(vp.viewportId).element;\n}\n\nexport default Synchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\nimport { ISynchronizerEventHandler } from '../../types';\n\n/**\n * Create a new synchronizer instance from Synchronizer class\n * @param synchronizerId - The id of the synchronizer.\n * @param eventName - The name of the event that will be emitted by the\n * synchronizer.\n * @param eventHandler - The event handler that will be\n * called when the event is emitted.\n * @param options - Options for the synchronizer.\n * @returns A reference to the synchronizer.\n */\nfunction createSynchronizer(\n  synchronizerId: string,\n  eventName: string,\n  eventHandler: ISynchronizerEventHandler,\n  options?: any\n): Synchronizer {\n  const synchronizerWithSameIdExists = state.synchronizers.some(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerWithSameIdExists) {\n    throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n  }\n\n  // Create\n  const synchronizer = new Synchronizer(\n    synchronizerId,\n    eventName,\n    eventHandler,\n    options\n  );\n\n  // Update state\n  state.synchronizers.push(synchronizer);\n\n  // Return reference\n  return synchronizer;\n}\n\nexport default createSynchronizer;\n","import { state } from '../index';\n\n/**\n * \"Destroy all synchronizers.\"\n */\nfunction destroy(): void {\n  while (state.synchronizers.length > 0) {\n    const synchronizer = state.synchronizers.pop();\n\n    synchronizer.destroy();\n  }\n}\n\nexport default destroy;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Get the synchronizer with the given id from the state.\n * @param synchronizerId - The id of the synchronizer to be retrieved.\n * @returns A synchronizer object.\n */\nfunction getSynchronizer(synchronizerId: string): Synchronizer | void {\n  return state.synchronizers.find((s) => s.id === synchronizerId);\n}\n\nexport default getSynchronizer;\n","import { state } from '../index';\nimport Synchronizer from './Synchronizer';\n\n/**\n * Return the array of synchronizers\n * @returns An array of synchronizers.\n */\nfunction getAllSynchronizers(): Array<Synchronizer> {\n  return state.synchronizers;\n}\n\nexport default getAllSynchronizers;\n","import { state } from '../index';\n\n// Synchronizers are a bit more tenacious. We need to make sure we remove\n// any attached events\n// We should probably just have a destroySynchronizer call\n// then use getByX to allow versatility in how we can call destroy\n\n/**\n * Destroy a synchronizer by its ID.\n * @param synchronizerId - The id of the synchronizer to destroy.\n */\nfunction destroySynchronizer(synchronizerId: string): void {\n  const synchronizerIndex = state.synchronizers.findIndex(\n    (sync) => sync.id === synchronizerId\n  );\n\n  if (synchronizerIndex > -1) {\n    const synchronizer = state.synchronizers[synchronizerIndex];\n\n    synchronizer.destroy();\n    state.synchronizers.splice(synchronizerIndex, 1);\n  }\n}\n\nexport default destroySynchronizer;\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n  'alias',\n  'all-scroll',\n  'auto',\n  'cell',\n  'col-resize',\n  'context-menu',\n  'copy',\n  'crosshair',\n  'default',\n  'e-resize',\n  'ew-resize',\n  'grab',\n  'grabbing',\n  'help',\n  'move',\n  'ne-resize',\n  'nesw-resize',\n  'no-drop',\n  'none',\n  'not-allowed',\n  'n-resize',\n  'ns-resize',\n  'nw-resize',\n  'nwse-resize',\n  'pointer',\n  'progress',\n  'row-resize',\n  'se-resize',\n  's-resize',\n  'sw-resize',\n  'text',\n  'vertical-text',\n  'wait',\n  'w-resize',\n  'zoom-in',\n  'zoom-out',\n]);\n\nexport default class MouseCursor {\n  private name: string;\n  private fallback: MouseCursor | undefined;\n\n  constructor(name: string, fallback?: MouseCursor | undefined) {\n    this.name = name + '';\n    this.fallback = fallback;\n  }\n\n  getName(): string {\n    return this.name + '';\n  }\n\n  addFallbackStyleProperty(style: string): string {\n    const { fallback } = this;\n    if (fallback instanceof MouseCursor) {\n      return `${style}, ${fallback.getStyleProperty()}`;\n    }\n    return style + '';\n  }\n\n  getStyleProperty(): string {\n    return this.addFallbackStyleProperty(this.name) + '';\n  }\n\n  static getDefinedCursor(name: string): MouseCursor | undefined {\n    const definedCursors = getDefinedCursors(\n      // @ts-ignore\n      MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n      DEFINED_CURSORS\n    );\n    let mouseCursor = definedCursors.get(name);\n    if (mouseCursor instanceof MouseCursor) {\n      return mouseCursor;\n    }\n    if (STANDARD_CURSORS.has(name)) {\n      mouseCursor = new MouseCursor(name);\n      definedCursors.set(name, mouseCursor);\n      return mouseCursor;\n    }\n  }\n\n  static setDefinedCursor(name: string, cursor: MouseCursor): boolean {\n    if (cursor instanceof MouseCursor) {\n      const definedCursors = getDefinedCursors(\n        // @ts-ignore\n        MouseCursor as Record<symbol, Map<string, MouseCursor>>,\n        DEFINED_CURSORS\n      );\n      definedCursors.set(name, cursor);\n      return true;\n    }\n    return false;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction getDefinedCursors(\n  context: Record<symbol, Map<string, MouseCursor>>,\n  symbol: symbol\n): Map<string, MouseCursor> {\n  let definedCursors = context[symbol];\n  if (!(definedCursors instanceof Map)) {\n    definedCursors = new Map();\n    Object.defineProperty(context, symbol, { value: definedCursors });\n  }\n  return definedCursors;\n}\n\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","import superPropBase from \"./superPropBase.js\";\nexport default function _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}","import getPrototypeOf from \"./getPrototypeOf.js\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}","/**\n * AnnotationStyleStates - This enum defines the 4 possible states available for\n *  a Annotation instance.\n *\n * Default:\n *   The default state for the annotation instance\n * Highlighted:\n *   The annotation should be rendered in \"highlighted\" mode in response to\n *   direct user interaction;\n * Selected:\n *   The annotation has been selected by the user;\n * Locked:\n *   The annotation has been locked;\n */\nenum AnnotationStyleStates {\n  Default = '',\n  Highlighted = 'Highlighted',\n  Selected = 'Selected',\n  Locked = 'Locked',\n}\n\nexport default AnnotationStyleStates;\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\n\nconst DEFAULT_NAME = 'image-cursor';\n\nexport default class ImageMouseCursor extends MouseCursor {\n  private url: string;\n  private x: number;\n  private y: number;\n\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(\n      name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME),\n      fallback\n    );\n    this.url = url;\n    this.x = Number(x) || 0;\n    this.y = Number(y) || 0;\n  }\n\n  getStyleProperty(): string {\n    const { url, x, y } = this;\n    let style = `url('${url}')`;\n    if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n      style += ` ${x} ${y}`;\n    }\n    return this.addFallbackStyleProperty(style);\n  }\n\n  static getUniqueInstanceName(prefix: string): string {\n    return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n  }\n}\n","import { SVGCursorDescriptor } from '../types';\n\n/*\n * Definitions\n */\n\nconst BASE: SVGCursorDescriptor = {\n  iconContent: '',\n  iconSize: 16,\n  viewBox: {\n    x: 16,\n    y: 16,\n  },\n  mousePoint: {\n    x: 8,\n    y: 8,\n  },\n  mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\n\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n  x: 127,\n  y: 60,\n};\n\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\n\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\n\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\n\nconst CursorSVG: Record<string, SVGCursorDescriptor> = {\n  Angle: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  ArrowAnnotate: extend(BASE, {\n    iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Bidirectional: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n    viewBox: {\n      x: 48,\n      y: 48,\n    },\n  }),\n  CobbAngle: extend(BASE, {\n    iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  CircleROI: extend(BASE, {\n    iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  EllipticalROI: extend(BASE, {\n    iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n    viewBox: {\n      x: 32,\n      y: 32,\n    },\n  }),\n  FreehandROI: extend(BASE, {\n    iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  FreehandROISculptor: extend(BASE, {\n    iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Length: extend(BASE, {\n    iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n    viewBox: {\n      x: 24,\n      y: 24,\n    },\n  }),\n  Probe: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  RectangleROI: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  TextMarker: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Crosshairs: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Eraser: extend(BASE, {\n    iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n    viewBox: {\n      x: 2048,\n      y: 1792,\n    },\n  }),\n  Magnify: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n    viewBox: {\n      x: 512,\n      y: 512,\n    },\n  }),\n  Pan: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  Rotate: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  StackScroll: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n    viewBox: {\n      x: 24,\n      y: 28,\n    },\n  }),\n  WindowLevelRegion: extend(BASE, {\n    iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n    viewBox: {\n      x: 1792,\n      y: 1792,\n    },\n  }),\n  WindowLevel: extend(BASE, {\n    iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n    viewBox: {\n      x: 18,\n      y: 18,\n    },\n  }),\n  Zoom: extend(BASE, {\n    iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n    viewBox: {\n      x: 640,\n      y: 512,\n    },\n  }),\n\n  /*\n   * Segmentation Cursors\n   */\n\n  SegmentationFreeHandEraseInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillInside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandEraseOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationFreeHandFillOutside: extend(BASE, {\n    iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  SegmentationRectangleEraseInside: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  // Default Rectangle Scissors\n  RectangleScissor: extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n    iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  CircleScissor: extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_INSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n\n  'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n    iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n    viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n  }),\n};\n\n/*\n * Utils\n */\n\nfunction extend(\n  base: SVGCursorDescriptor,\n  values: Record<string, unknown>\n): SVGCursorDescriptor {\n  return Object.assign(Object.create(base), values);\n}\n\n/**\n * Registers a cursor to the list, so that it will be used for the given `toolName`.\n * Overwrites the given cursor if it is already set.\n *\n * @param toolName - The name of the tool to assign a cursor to.\n * @param iconContent - The SVG icon content of the cursor.\n * @param viewBox - The viewBox of the cursor object.\n */\nfunction registerCursor(\n  toolName: string,\n  iconContent: string,\n  viewBox: { x: number; y: number }\n) {\n  CursorSVG[toolName] = extend(BASE, {\n    iconContent,\n    viewBox,\n  });\n}\n\nfunction getDefinedSVGCursorDescriptor(\n  name: string\n): SVGCursorDescriptor | undefined {\n  return CursorSVG[name];\n}\n\n/*\n * Exports\n */\nconst svgCursorNames = Object.keys(CursorSVG);\n\nexport {\n  getDefinedSVGCursorDescriptor,\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n};\n","import {\n  StyleConfig,\n  ToolStyleConfig,\n  StyleSpecifier,\n  AnnotationStyle,\n} from '../../../types/AnnotationStyle';\n\n/**\n * This class handles the configuration of the tool style. You can use it to set\n * the style of a tool at various levels (annotation, viewport, toolGroup, global).\n *\n * The hierarchy of the configuration is as follows (each level falls back to the\n * next level if not specified):\n *\n * 1) Annotation-level styles (with annotationUID)\n *     2) Viewport-level tool styles\n *         - Per-tool: Length on the viewport with viewportId\n *         - Global: All tools on the viewport with viewportId\n *             3) ToolGroup tool styles\n *                 - Per-tool: Angle on toolGroupId in all viewports of the toolGroup\n *                 - Global: All tools in the toolGroupId for all viewports\n *                     4) Default level:\n *                         - Per-tool: Length styles\n *                         - Global: Opinionated styles by CornerstoneJS\n */\nclass ToolStyle {\n  config: StyleConfig;\n\n  constructor() {\n    const defaultConfig = {\n      color: 'rgb(255, 255, 0)',\n      colorHighlighted: 'rgb(0, 255, 0)',\n      colorSelected: 'rgb(0, 220, 0)',\n      colorLocked: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '',\n      shadow: true,\n      textBoxVisibility: true,\n      textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n      textBoxFontSize: '14px',\n      textBoxColor: 'rgb(255, 255, 0)',\n      textBoxColorHighlighted: 'rgb(0, 255, 0)',\n      textBoxColorSelected: 'rgb(0, 255, 0)',\n      textBoxColorLocked: 'rgb(255, 255, 0)',\n      textBoxBackground: '',\n      textBoxLinkLineWidth: '1',\n      textBoxLinkLineDash: '2,3',\n      textBoxShadow: true,\n    };\n\n    this._initializeConfig(defaultConfig);\n  }\n\n  /**\n   * It returns the annotation-specific tool styles for the annotation with the given UID\n   * @param annotationUID - The unique identifier of the annotation.\n   * @returns The annotation tool styles for the annotation with the given UID.\n   */\n  getAnnotationToolStyles(annotationUID: string): AnnotationStyle {\n    return this.config.annotations && this.config.annotations[annotationUID];\n  }\n\n  /**\n   * It returns the styles for a given viewport. It includes tool-specific and\n   * global styles (all tools in the viewport)\n   * @param viewportId - The id of the viewport\n   * @returns The viewport tool styles for the given viewport id.\n   */\n  getViewportToolStyles(viewportId: string): ToolStyleConfig {\n    return this.config.viewports && this.config.viewports[viewportId];\n  }\n\n  /**\n   * It returns the tool style for the given toolGroup. It includes tool-specific and\n   * global styles (all tools in the toolGroup)\n   * @param toolGroupId - The id of the toolGroup.\n   * @returns The tool styles for the tool group with the given id.\n   */\n  getToolGroupToolStyles(toolGroupId: string): ToolStyleConfig {\n    return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n  }\n\n  /**\n   * It returns the default tool styles from the config file. It includes tool-specific and\n   * global styles (all tools in all tooLGroups)\n   * @returns The default tool styles.\n   */\n  getDefaultToolStyles(): ToolStyleConfig {\n    return this.config.default;\n  }\n\n  /**\n   * It takes an annotationUID and a style object and sets the styles at\n   * the annotationLevel (highest priority in the hierarchy). The styles is an\n   * object with key value pairs.\n   * @param annotationUID - string - The unique identifier for the annotation.\n   * @param styles - ToolStyles\n   */\n  setAnnotationStyles(annotationUID: string, styles: AnnotationStyle) {\n    let annotationSpecificStyles = this.config.annotations;\n\n    if (!annotationSpecificStyles) {\n      this.config = {\n        ...this.config,\n        annotations: {},\n      };\n\n      annotationSpecificStyles = this.config.annotations;\n    }\n\n    annotationSpecificStyles[annotationUID] = styles;\n  }\n\n  /**\n   * It takes a viewportId and a ToolStyles object, and adds the ToolStyles object\n   * at the viewport level (second highest priority in the hierarchy after the annotation level).\n   * @param viewportId - The id of the viewport\n   * @param styles - style object including tool-specific and/or global styles (All tools in the viewport)\n   */\n  setViewportToolStyles(viewportId: string, styles: ToolStyleConfig) {\n    let viewportSpecificStyles = this.config.viewports;\n\n    if (!viewportSpecificStyles) {\n      this.config = {\n        ...this.config,\n        viewports: {},\n      };\n\n      viewportSpecificStyles = this.config.viewports;\n    }\n\n    viewportSpecificStyles[viewportId] = styles;\n  }\n\n  /**\n   * It takes a toolGroupId and a ToolStyles object, and it adds the ToolStyles object\n   * at the toolGroup level (third highest priority in the hierarchy after the viewport level).\n   * @param toolGroupId - The id of the toolGroup\n   * @param styles - style object including tool-specific (in all viewports of the toolGroup) and/or\n   * global styles (All tools in the toolGroup for all viewports)\n   */\n  setToolGroupToolStyles(toolGroupId: string, styles: ToolStyleConfig) {\n    let toolGroupSpecificStyles = this.config.toolGroups;\n\n    if (!toolGroupSpecificStyles) {\n      this.config = {\n        ...this.config,\n        toolGroups: {},\n      };\n\n      toolGroupSpecificStyles = this.config.toolGroups;\n    }\n\n    toolGroupSpecificStyles[toolGroupId] = styles;\n  }\n\n  /**\n   * Sets the default tool styles for the editor. It overrides the default styles for all tools.\n   * @param styles - style object including tool-specific (a tool in all toolGroups) and/or\n   * global styles (All tools in all tooLGroups)\n   */\n  setDefaultToolStyles(styles: ToolStyleConfig) {\n    this.config.default = styles;\n  }\n\n  /**\n   * It returns the value for a given style key, based on the provided specifications.\n   * It starts by looking at the annotation-specific styles, then at the viewport-specific styles,\n   * then at the toolGroup-specific styles, and finally at the default styles.\n   * @param styleKey - The key of the style.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met\n   * @returns The value for the given style key.\n   */\n  getStyleProperty(toolStyle: string, specifications: StyleSpecifier) {\n    const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n\n    return this._getToolStyle(\n      toolStyle,\n      annotationUID,\n      viewportId,\n      toolGroupId,\n      toolName\n    );\n  }\n\n  private _getToolStyle(\n    property: string,\n    annotationUID: string,\n    viewportId: string,\n    toolGroupId: string,\n    toolName: string\n  ) {\n    if (annotationUID) {\n      const styles = this.getAnnotationToolStyles(annotationUID);\n\n      if (styles) {\n        // check first in the toolSpecific styles\n        if (styles[property]) {\n          return styles[property];\n        }\n      }\n    }\n\n    if (viewportId) {\n      const styles = this.getViewportToolStyles(viewportId);\n\n      if (styles) {\n        // check if we have the viewportId specific style\n        // check first in the toolSpecific styles\n        if (styles[toolName] && styles[toolName][property]) {\n          return styles[toolName][property];\n        }\n\n        // check if we have the style in the viewport specific global viewportSpecificStyles\n        if (styles.global && styles.global[property]) {\n          return styles.global[property];\n        }\n      }\n    }\n\n    if (toolGroupId) {\n      const styles = this.getToolGroupToolStyles(toolGroupId);\n\n      if (styles) {\n        // check first in the toolSpecific styles\n        if (styles[toolName] && styles[toolName][property]) {\n          return styles[toolName][property];\n        }\n\n        // check if we have the style in the toolGroup specific global styles\n        if (styles.global && styles.global[property]) {\n          return styles.global[property];\n        }\n      }\n    }\n\n    const globalStyles = this.getDefaultToolStyles();\n\n    if (globalStyles[toolName] && globalStyles[toolName][property]) {\n      return globalStyles[toolName][property];\n    }\n\n    if (globalStyles.global && globalStyles.global[property]) {\n      return globalStyles.global[property];\n    }\n  }\n\n  private _initializeConfig(config) {\n    const toolStyles = {};\n    for (const name in config) {\n      toolStyles[name] = config[name];\n    }\n\n    this.config = {\n      default: {\n        global: toolStyles as AnnotationStyle,\n      },\n    };\n  }\n}\n\nconst toolStyle = new ToolStyle();\n\nexport default toolStyle;\n","import { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport toolStyle from './ToolStyle';\n\n/**\n * Build a list of hierarchal property names in ascending order of priority\n * @param property - The base property name -- e.g., 'color'\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns A list of property names\n */\nfunction getHierarchalPropertyStyles(\n  property: string,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string[] {\n  const list = [`${property}`];\n  if (state) {\n    list.push(`${list[0]}${state}`);\n  }\n  if (mode) {\n    list.push(`${list[list.length - 1]}${mode}`);\n  }\n  return list;\n}\n\n/**\n * Get the value of a style property from the ToolStyle config\n * @param property - The name of the property to get.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - The state of the tool (Default, Locked etc.)\n * @param mode - The current tool mode. (Active, Passive etc.)\n * @returns The value of the property.\n */\nfunction getStyleProperty(\n  property: string,\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  // Hierarchal property styles is a list of property names with priority in ascending\n  // order like: ['color', 'colorSelected', 'colorSelectedActive'], if in the toolStyle\n  // config, the `colorSelectedActive` property is defined, it will be used, otherwise\n  // the `colorSelected` property will be used, and if that is not defined, the `color`\n  // property will be used. This is done to ensure that the most specific property is used.\n  // Thus, we attempt resolving property names in reverse order\n  const alternatives = getHierarchalPropertyStyles(property, state, mode);\n  for (let i = alternatives.length - 1; i >= 0; --i) {\n    const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n    if (style !== undefined) {\n      return style;\n    }\n  }\n}\n\nexport { getStyleProperty };\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport MouseCursor from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\n\nimport type { StyleSpecifier } from '../types/AnnotationStyle';\nimport type { SVGCursorDescriptor } from '../types';\n\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\n\nexport default class SVGMouseCursor extends ImageMouseCursor {\n  constructor(\n    url: string,\n    x?: number,\n    y?: number,\n    name?: string | undefined,\n    fallback?: MouseCursor | undefined\n  ) {\n    super(url, x, y, name, fallback);\n  }\n\n  /**\n   * Get a shared instance of the SVGMouseCursor class satisfying the given parameters.\n   *\n   * @param name - The name of the cursor (defined in SVGCursorDescriptor.ts);\n   * @param pointer - Should be true to use the version of the cursor containing\n   * a mouse pointer. Defaults to false (which does not add a pointer to the cursor);\n   * @param color - The color of the cursor. Defaults to tool.style.colorHighlightedActive;\n   * @returns a SVGMouseCursor instance or\n   * undefined if no SVG cursor descriptor was found with the given name;\n   */\n  static getDefinedCursor(\n    name: string,\n    pointer = false,\n    color?: string\n  ): MouseCursor {\n    if (!color) {\n      color = getStyleProperty(PROPERTY, {} as StyleSpecifier, STATE, MODE);\n    }\n    const urn = getCursorURN(name, pointer, color);\n    let cursor = super.getDefinedCursor(urn);\n    if (!cursor) {\n      const descriptor = getDefinedSVGCursorDescriptor(name);\n      if (descriptor) {\n        cursor = createSVGMouseCursor(\n          descriptor,\n          urn,\n          pointer,\n          color,\n          super.getDefinedCursor('default')\n        );\n        super.setDefinedCursor(urn, cursor);\n      }\n    }\n    return cursor;\n  }\n}\n\n/*\n * Helpers\n */\n\nfunction format(template: string, dictionary: Record<string, unknown>): string {\n  const dict = Object(dictionary);\n  const defined = Object.prototype.hasOwnProperty.bind(dict);\n  return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n    return defined(key) ? dict[key] + '' : '';\n  });\n}\n\nfunction getCursorURN(name: string, pointer: boolean, color: string) {\n  const type = pointer ? 'pointer' : 'cursor';\n  return `${type}:${name}/${color}`;\n}\n\nfunction createSVGMouseCursor(\n  descriptor: SVGCursorDescriptor,\n  name: string,\n  pointer: boolean,\n  color: string,\n  fallback: MouseCursor\n): SVGMouseCursor {\n  const { x, y } = descriptor.mousePoint;\n  return new SVGMouseCursor(\n    createSVGIconUrl(descriptor, pointer, { color }),\n    x,\n    y,\n    name,\n    fallback\n  );\n}\n\nfunction createSVGIconUrl(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): string {\n  return URL.createObjectURL(createSVGIconBlob(descriptor, pointer, options));\n}\n\nfunction createSVGIconBlob(\n  descriptor: SVGCursorDescriptor,\n  pointer: boolean,\n  options: Record<string, unknown>\n): Blob {\n  const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(\n    descriptor,\n    options\n  );\n  return new Blob([svgString], { type: 'image/svg+xml' });\n}\n\nfunction createSVGIcon(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n): string {\n  const { iconContent, iconSize, viewBox } = descriptor;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n  return format(svgString, options);\n}\n\nfunction createSVGIconWithPointer(\n  descriptor: SVGCursorDescriptor,\n  options: Record<string, unknown>\n) {\n  const { iconContent, iconSize, viewBox, mousePointerGroupString } =\n    descriptor;\n  const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n  const svgSize = 16 + iconSize;\n  const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g>${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n  return format(svgString, options);\n}\n","import { MouseCursor } from '.';\n\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\n\n/*\n * Public Methods\n */\n\nfunction initElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  _getElementCursors(element)[0] = cursor;\n  _setElementCursor(element, cursor);\n}\n\nfunction _setElementCursor(\n  element: HTMLDivElement,\n  cursor: MouseCursor | null\n): void {\n  const cursors = _getElementCursors(element);\n  cursors[1] = cursors[0];\n  cursors[0] = cursor;\n  element.style.cursor = (\n    cursor instanceof MouseCursor\n      ? cursor\n      : MouseCursor.getDefinedCursor('auto')\n  ).getStyleProperty();\n}\n\nfunction resetElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, _getElementCursors(element)[1]);\n}\n\nfunction hideElementCursor(element: HTMLDivElement): void {\n  _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\n\n/*\n * Helpers\n */\n\nfunction _getElementCursors(\n  element: HTMLDivElement\n): [MouseCursor | null, MouseCursor | null] {\n  let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n  if (!(map instanceof WeakMap)) {\n    map = new WeakMap();\n    Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n      value: map,\n    });\n  }\n  let cursors = map.get(element);\n  if (!cursors) {\n    cursors = [null, null];\n    map.set(element, cursors);\n  }\n  return cursors;\n}\n\n/*\n * Exports\n */\nexport {\n  initElementCursor,\n  resetElementCursor,\n  hideElementCursor,\n  _setElementCursor as setElementCursor,\n};\n","import { MouseBindings, ToolModes } from '../../enums';\nimport cloneDeep from 'lodash.clonedeep';\nimport get from 'lodash.get';\nimport {\n  triggerEvent,\n  eventTarget,\n  getRenderingEngine,\n  getRenderingEngines,\n  getEnabledElementByIds,\n  Settings,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport {\n  ToolActivatedEventDetail,\n  ToolModeChangedEventDetail,\n} from '../../types/EventTypes';\nimport { ToolGroupManager, state } from '../index';\nimport {\n  IToolBinding,\n  IToolClassReference,\n  IToolGroup,\n  SetToolBindingsType,\n  ToolOptionsType,\n  ToolConfiguration,\n} from '../../types';\n\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\n\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\n\n/**\n * ToolGroup class which is a container for tools and their modes and states.\n * In Cornerstone3DTools, you need to create a tool group in order to use the\n * tools. ToolGroup is a way to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports. Tools can set to be activated, enabled or disabled\n * in a toolGroup. You should not directly instantiate a ToolGroup. You need to use\n * ToolGroupManager helpers to create a new toolGroup or get a reference to an existing toolGroup.\n *\n * ```js\n * const toolGroup = csTools.ToolGroupManager.createToolGroup('toolGroupId')\n * ```\n */\nexport default class ToolGroup implements IToolGroup {\n  id: string;\n  viewportsInfo = [];\n  toolOptions = {};\n  _toolInstances = {};\n\n  constructor(id: string) {\n    this.id = id;\n  }\n\n  /**\n   * Get the viewport IDs of all the viewports in the current viewport\n   * @returns An array of viewport IDs.\n   */\n  getViewportIds(): string[] {\n    return this.viewportsInfo.map(({ viewportId }) => viewportId);\n  }\n\n  /**\n   * Returns the toolGroup viewports info which is an array of {viewportId, renderingEngineId}\n   */\n  getViewportsInfo(): Array<Types.IViewportId> {\n    return this.viewportsInfo.slice();\n  }\n\n  /**\n   * Get the tool instance for a given tool name in the toolGroup\n   * @param toolName - The name of the tool.\n   * @returns A tool instance.\n   */\n  public getToolInstance(toolInstanceName: string) {\n    const toolInstance = this._toolInstances[toolInstanceName];\n    if (!toolInstance) {\n      console.warn(\n        `'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`\n      );\n      return;\n    }\n\n    return toolInstance;\n  }\n  /**\n   * Add a tool to the tool group with the given tool name and tool configuration.\n   * Note that adding a tool to a tool group will not automatically set the tool\n   * to be active. You must call setToolActive or setToolPassive and other methods\n   * to set the tool to be active or passive or in other states.\n   *\n   * @param toolName - string\n   * @param configuration - Tool configuration objects and a custom statistics calculator if needed\n   */\n  addTool(toolName: string, configuration: ToolConfiguration = {}): void {\n    const toolDefinition = state.tools[toolName];\n    const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n    const localToolInstance = this.toolOptions[toolName];\n\n    if (!hasToolName) {\n      console.warn(\n        'Tool with configuration did not produce a toolName: ',\n        configuration\n      );\n      return;\n    }\n\n    if (!toolDefinition) {\n      console.warn(\n        `'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`\n      );\n      return;\n    }\n\n    if (localToolInstance) {\n      console.warn(\n        `'${toolName}' is already registered for ToolGroup ${this.id}.`\n      );\n      return;\n    }\n\n    // Should these be renamed higher up, so we don't have to alias?\n    // Wrap in try-catch so 3rd party tools don't explode?\n    const { toolClass: ToolClass } = toolDefinition;\n\n    const toolProps = {\n      name: toolName,\n      toolGroupId: this.id,\n      configuration,\n    };\n\n    const instantiatedTool = new ToolClass(toolProps);\n\n    // API instead of directly exposing schema?\n    // Maybe not here, but feels like a \"must\" for any method outside of the ToolGroup itself\n    this._toolInstances[toolName] = instantiatedTool;\n  }\n\n  public addToolInstance(\n    toolName: string,\n    parentClassName: string,\n    configuration = {}\n  ): void {\n    let ToolClassToUse = state.tools[toolName]\n      ?.toolClass as IToolClassReference;\n\n    if (!ToolClassToUse) {\n      // get parent class constructor\n      const ParentClass = state.tools[parentClassName]\n        .toolClass as IToolClassReference;\n\n      // Todo: could not find a way to make this work with typescript\n      // @ts-ignore\n      class ToolInstance extends ParentClass {}\n      // @ts-ignore\n      ToolInstance.toolName = toolName;\n      // @ts-ignore\n      ToolClassToUse = ToolInstance;\n\n      state.tools[toolName] = {\n        toolClass: ToolInstance as IToolClassReference,\n      };\n    }\n\n    // add the tool to the toolGroup\n    // @ts-ignore\n    this.addTool(ToolClassToUse.toolName, configuration);\n  }\n\n  //   class InstanceTool extends parentClass;\n  // InstanceTool.constructor.toolName = name;\n  // addTool(InstanceTool,configuration)\n  /**\n   * Add a viewport to the ToolGroup. It accepts viewportId and optional\n   * renderingEngineId parameter. If renderingEngineId is not provided,\n   * it checks if cornerstone-core has more than one renderingEngine; If so,\n   * it will throw an error. If cornerstone-core has only one renderingEngine,\n   * it will use that renderingEngine.\n   *\n   * @param viewportId - The unique identifier for the viewport.\n   * @param renderingEngineId - The rendering engine to use.\n   */\n  public addViewport(viewportId: string, renderingEngineId?: string): void {\n    const renderingEngines = getRenderingEngines();\n\n    if (!renderingEngineId && renderingEngines.length > 1) {\n      throw new Error(\n        'You must specify a renderingEngineId when there are multiple rendering engines.'\n      );\n    }\n\n    const renderingEngineUIDToUse = renderingEngineId || renderingEngines[0].id;\n\n    // Don't overwrite if it already exists\n    if (\n      !this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)\n    ) {\n      this.viewportsInfo.push({\n        viewportId,\n        renderingEngineId: renderingEngineUIDToUse,\n      });\n    }\n\n    // Handle the newly added viewport's mouse cursor\n    const toolName = this.getActivePrimaryMouseButtonTool();\n\n    const runtimeSettings = Settings.getRuntimeSettings();\n    if (runtimeSettings.get('useCursors')) {\n      this.setViewportsCursorByToolName(toolName);\n    }\n  }\n\n  /**\n   * Removes viewport from the toolGroup. If only renderingEngineId is defined\n   * it removes all the viewports with the same renderingEngineId, if viewportId\n   * is also provided, it will remove that specific viewport from the ToolGroup.\n   *\n   * @param renderingEngineId - renderingEngine id\n   * @param viewportId - viewport id\n   */\n  public removeViewports(renderingEngineId: string, viewportId?: string): void {\n    const indices = [];\n\n    this.viewportsInfo.forEach((vpInfo, index) => {\n      let match = false;\n      if (vpInfo.renderingEngineId === renderingEngineId) {\n        match = true;\n\n        if (viewportId && vpInfo.viewportId !== viewportId) {\n          match = false;\n        }\n      }\n      if (match) {\n        indices.push(index);\n      }\n    });\n\n    if (indices.length) {\n      // Note: Traverse the array backwards, such that when we remove items we\n      // do not immediately mess up our loop indicies.\n      for (let i = indices.length - 1; i >= 0; i--) {\n        this.viewportsInfo.splice(indices[i], 1);\n      }\n    }\n  }\n\n  public setActiveStrategy(toolName: string, strategyName: string) {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool configuration.`\n      );\n\n      return;\n    }\n\n    toolInstance.setActiveStrategy(strategyName);\n  }\n\n  setToolMode(\n    toolName: string,\n    mode: ToolModes,\n    options = {} as SetToolBindingsType\n  ): void {\n    if (!toolName) {\n      console.warn('setToolMode: toolName must be defined');\n      return;\n    }\n\n    if (mode === ToolModes.Active) {\n      this.setToolActive(toolName, options);\n      return;\n    }\n\n    if (mode === ToolModes.Passive) {\n      this.setToolPassive(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Enabled) {\n      this.setToolEnabled(toolName);\n      return;\n    }\n\n    if (mode === ToolModes.Disabled) {\n      this.setToolDisabled(toolName);\n      return;\n    }\n\n    console.warn('setToolMode: mode must be defined');\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Active. This means the tool\n   * can be actively used by the defined bindings (e.g., Mouse primary click)\n   *\n   * - Can be actively used by mouse/touch events mapped to its `ToolBinding`s.\n   * - Can add data if an annotation tool.\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   * @param toolBindingsOptions - tool bindings\n   */\n  public setToolActive(\n    toolName: string,\n    toolBindingsOptions = {} as SetToolBindingsType\n  ): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    if (!toolInstance) {\n      console.warn(\n        `'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`\n      );\n      return;\n    }\n\n    const prevBindings: IToolBinding[] = this.toolOptions[toolName]\n      ? this.toolOptions[toolName].bindings\n      : [];\n\n    const newBindings = toolBindingsOptions.bindings\n      ? toolBindingsOptions.bindings\n      : [];\n\n    // combine the new bindings with the previous bindings to avoid duplicates\n    // it allows duplicated mouse buttons as long as they don't have same\n    // modifier keys.\n    const bindingsToUse = [...prevBindings, ...newBindings].reduce(\n      (unique, binding) => {\n        const TouchBinding = binding.numTouchPoints !== undefined;\n        const MouseBinding = binding.mouseButton !== undefined;\n\n        if (\n          !unique.some((obj) => hasSameBinding(obj, binding)) &&\n          (TouchBinding || MouseBinding)\n        ) {\n          unique.push(binding);\n        }\n        return unique;\n      },\n      []\n    );\n\n    // We should not override the bindings if they are already set\n    const toolOptions: ToolOptionsType = {\n      bindings: bindingsToUse,\n      mode: Active,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    this._toolInstances[toolName].mode = Active;\n\n    // reset the mouse cursor if tool has left click binding\n    const runtimeSettings = Settings.getRuntimeSettings();\n    const useCursor = runtimeSettings.get('useCursors');\n\n    if (this._hasMousePrimaryButtonBinding(toolBindingsOptions) && useCursor) {\n      this.setViewportsCursorByToolName(toolName);\n    } else {\n      // reset to default cursor only if there is no other tool with primary binding\n      const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n      if (!activeToolIdentifier && useCursor) {\n        const cursor = MouseCursor.getDefinedCursor('default');\n        this._setCursorForViewports(cursor);\n      }\n    }\n\n    if (typeof toolInstance.onSetToolActive === 'function') {\n      toolInstance.onSetToolActive();\n    }\n    this._renderViewports();\n\n    const eventDetail: ToolActivatedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n    this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Passive.\n   *\n   * - Can be passively interacted by grabbing a tool or its handles.\n   * - Renders data if the tool has a `renderAnnotation` method.\n   *\n   * @param toolName - tool name\n   */\n  public setToolPassive(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    // We should only remove the primary button bindings and keep\n    // the other ones (Zoom on right click)\n    const prevToolOptions = this.getToolOptions(toolName);\n    const toolOptions = Object.assign(\n      {\n        bindings: prevToolOptions ? prevToolOptions.bindings : [],\n      },\n      prevToolOptions,\n      {\n        mode: Passive,\n      }\n    );\n\n    const defaultMousePrimary = this.getDefaultMousePrimary();\n\n    // Remove the primary button bindings without modifiers, if they exist\n    toolOptions.bindings = toolOptions.bindings.filter(\n      (binding) =>\n        binding.mouseButton !== defaultMousePrimary || binding.modifierKey\n    );\n    // If there are other bindings, set the tool to be active\n    let mode = Passive;\n    if (toolOptions.bindings.length !== 0) {\n      mode = Active;\n      toolOptions.mode = mode;\n    }\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = mode;\n\n    if (typeof toolInstance.onSetToolPassive === 'function') {\n      toolInstance.onSetToolPassive();\n    }\n    this._renderViewports();\n\n    // It would make sense to use `toolInstance.mode` as mode when setting a tool\n    // as passive because it can still be actived in the end but `Passive` must\n    // be used when synchronizing ToolGroups so that other ToolGroups can take the\n    // same action (update tool bindings). Should the event have two different modes\n    // to handle this special case?\n    this._triggerToolModeChangedEvent(toolName, Passive);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Enabled.\n   *\n   * - Renders data if the tool has a `renderAnnotation` method..\n   *\n   * @param toolName - tool name\n   */\n  public setToolEnabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Enabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Enabled;\n\n    if (typeof toolInstance.onSetToolEnabled === 'function') {\n      toolInstance.onSetToolEnabled();\n    }\n\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Enabled);\n  }\n\n  /**\n   * Set the tool mode on the toolGroup to be Disabled.\n   *\n   * - Annotation does not render.\n   *\n   * @param toolName - tool name\n   */\n  public setToolDisabled(toolName: string): void {\n    const toolInstance = this._toolInstances[toolName];\n\n    if (toolInstance === undefined) {\n      console.warn(\n        `Tool ${toolName} not added to toolGroup, can't set tool mode.`\n      );\n\n      return;\n    }\n\n    const toolOptions = {\n      bindings: [],\n      mode: Disabled,\n    };\n\n    this.toolOptions[toolName] = toolOptions;\n    toolInstance.mode = Disabled;\n\n    if (typeof toolInstance.onSetToolDisabled === 'function') {\n      toolInstance.onSetToolDisabled();\n    }\n    this._renderViewports();\n    this._triggerToolModeChangedEvent(toolName, Disabled);\n  }\n\n  /**\n   * Get the options for a given tool\n   * @param toolName - The name of the tool.\n   * @returns the tool options\n   */\n  public getToolOptions(toolName: string): ToolOptionsType {\n    const toolOptionsForTool = this.toolOptions[toolName];\n\n    if (toolOptionsForTool === undefined) {\n      return;\n    }\n\n    return toolOptionsForTool;\n  }\n\n  /**\n   * Find the name of the tool that is Active and has a primary button binding\n   * (Mouse primary click)\n   *\n   * @returns The name of the tool\n   */\n  public getActivePrimaryMouseButtonTool(): string {\n    return Object.keys(this.toolOptions).find((toolName) => {\n      const toolOptions = this.toolOptions[toolName];\n      return (\n        toolOptions.mode === Active &&\n        this._hasMousePrimaryButtonBinding(toolOptions)\n      );\n    });\n  }\n\n  public setViewportsCursorByToolName(\n    toolName: string,\n    strategyName?: string\n  ): void {\n    const cursor = this._getCursor(toolName, strategyName);\n\n    this._setCursorForViewports(cursor);\n  }\n\n  private _getCursor(toolName: string, strategyName?: string): MouseCursor {\n    let cursorName;\n    let cursor;\n\n    if (strategyName) {\n      // Try combinations with strategyName first:\n      // Try with toolName and toolInstanceName first.\n      cursorName = `${toolName}.${strategyName}`;\n\n      cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n      if (cursor) {\n        return cursor;\n      }\n    }\n\n    // Try with toolName and toolInstanceName first.\n    cursorName = `${toolName}`;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    // Try with just toolName.\n    cursorName = toolName;\n\n    cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n\n    if (cursor) {\n      return cursor;\n    }\n\n    return MouseCursor.getDefinedCursor('default');\n  }\n\n  _setCursorForViewports(cursor: MouseCursor): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const { viewport } = enabledElement;\n      initElementCursor(viewport.element, cursor);\n    });\n  }\n\n  /**\n   * Set a configuration of a tool by the given toolName.\n   * Use overwrite as true in case you want to overwrite any existing configuration (be careful, depending on config change it might break the annotation flow).\n   */\n  public setToolConfiguration(\n    toolName: string,\n    configuration: ToolConfiguration,\n    overwrite?: boolean\n  ): boolean {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return false;\n    }\n\n    let _configuration;\n\n    if (overwrite) {\n      _configuration = configuration;\n    } else {\n      // We should not deep copy here, it is the job of the application to\n      // deep copy the configuration before passing it to the toolGroup, otherwise\n      // some strange appending behaviour happens for the arrays\n      _configuration = Object.assign(\n        this._toolInstances[toolName].configuration,\n        configuration\n      );\n    }\n\n    this._toolInstances[toolName].configuration = _configuration;\n\n    this._renderViewports();\n\n    return true;\n  }\n\n  /**\n   * Returns the default mouse primary button.\n   *\n   */\n  public getDefaultMousePrimary(): MouseBindings {\n    return MouseBindings.Primary;\n  }\n\n  /**\n   * Get the configuration of tool. It returns only the config for the given path (in case exists).\n   * ConfigurationPath is the the path of the property to get separated by '.'.\n   *\n   * @example\n   * getToolConfiguration('LengthTool', 'firstLevel.secondLevel')\n   * // get from LengthTool instance the configuration value as being LengthToolInstance[configuration][firstLevel][secondLevel]\n   */\n  getToolConfiguration(toolName: string, configurationPath: string): any {\n    if (this._toolInstances[toolName] === undefined) {\n      console.warn(\n        `Tool ${toolName} not present, can't set tool configuration.`\n      );\n      return;\n    }\n\n    const _configuration = get(\n      this._toolInstances[toolName].configuration,\n      configurationPath\n    );\n\n    return cloneDeep(_configuration);\n  }\n\n  /**\n   *\n   * @param newToolGroupId - Id of the new (clone) tool group\n   * @param fnToolFilter - Function to filter which tools from this tool group\n   * should be added to the new (clone) one. Example: only annotations tools\n   * can be filtered and added to the new tool group.\n   * @returns A new tool group that is a clone of this one\n   */\n  public clone(\n    newToolGroupId,\n    fnToolFilter: (toolName: string) => void = null\n  ): IToolGroup {\n    let toolGroup = ToolGroupManager.getToolGroup(newToolGroupId);\n\n    if (toolGroup) {\n      console.warn(`ToolGroup ${newToolGroupId} already exists`);\n      return toolGroup;\n    }\n\n    toolGroup = ToolGroupManager.createToolGroup(newToolGroupId);\n    fnToolFilter = fnToolFilter ?? (() => true);\n\n    Object.keys(this._toolInstances)\n      .filter(fnToolFilter)\n      .forEach((toolName) => {\n        const sourceToolInstance = this._toolInstances[toolName];\n        const sourceToolOptions = this.toolOptions[toolName];\n        const sourceToolMode = sourceToolInstance.mode;\n\n        toolGroup.addTool(toolName);\n\n        (toolGroup as unknown as ToolGroup).setToolMode(\n          toolName,\n          sourceToolMode,\n          {\n            bindings: sourceToolOptions.bindings ?? [],\n          }\n        );\n      });\n\n    return toolGroup;\n  }\n\n  /**\n   * Check if the tool binding is set to be primary mouse button.\n   * @param toolOptions - The options for the tool mode.\n   * @returns A boolean value.\n   */\n  private _hasMousePrimaryButtonBinding(toolOptions) {\n    const defaultMousePrimary = this.getDefaultMousePrimary();\n\n    return toolOptions?.bindings?.some(\n      (binding) =>\n        binding.mouseButton === defaultMousePrimary &&\n        binding.modifierKey === undefined\n    );\n  }\n\n  /**\n   * It re-renders the viewports in the toolGroup\n   */\n  private _renderViewports(): void {\n    this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n    });\n  }\n\n  /**\n   * Trigger ToolModeChangedEvent when changing the tool mode\n   * @param toolName - Tool name\n   * @param mode - Tool mode\n   * @param toolBindingsOptions - Binding options used when a tool is activated\n   */\n  private _triggerToolModeChangedEvent(\n    toolName: string,\n    mode: ToolModes,\n    toolBindingsOptions?: SetToolBindingsType\n  ): void {\n    const eventDetail: ToolModeChangedEventDetail = {\n      toolGroupId: this.id,\n      toolName,\n      mode,\n      toolBindingsOptions,\n    };\n\n    triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n  }\n}\n\nfunction hasSameBinding(\n  binding1: IToolBinding,\n  binding2: IToolBinding\n): boolean {\n  if (binding1.mouseButton !== binding2.mouseButton) {\n    return false;\n  }\n\n  return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../index';\nimport ToolGroup from './ToolGroup';\nimport { IToolGroup } from '../../types';\n\n/**\n * Create a new tool group with the given name. ToolGroups are the new way\n * in Cornerstone3DTools to share tool configuration, state (enabled, disabled, etc.)\n * across a set of viewports.\n *\n * @param toolGroupId - The unique ID of the tool group.\n * @returns A reference to the tool group that was created.\n */\nfunction createToolGroup(toolGroupId: string): IToolGroup | undefined {\n  // Exit early if ID conflict\n  const toolGroupWithIdExists = state.toolGroups.some(\n    (tg) => tg.id === toolGroupId\n  );\n\n  if (toolGroupWithIdExists) {\n    console.warn(`'${toolGroupId}' already exists.`);\n    return;\n  }\n\n  const toolGroup = new ToolGroup(toolGroupId);\n\n  // Update state\n  state.toolGroups.push(toolGroup);\n\n  // Return reference\n  return toolGroup;\n}\n\nexport default createToolGroup;\n","import { state } from '../index';\nimport { IToolGroup } from '../../types';\n\n/**\n * Return the array of tool groups\n * @returns An array of tool groups.\n */\nfunction getAllToolGroups(): Array<IToolGroup> {\n  return state.toolGroups;\n}\n\nexport default getAllToolGroups;\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera by updating all camera\n * values.  See also zoomPanSyncCallback\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default function cameraSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  cameraModifiedEvent: CustomEvent\n): void {\n  const { camera } = cameraModifiedEvent.detail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n\n  tViewport.setCamera(camera);\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createCameraPositionSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const cameraPositionSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    cameraSyncCallback\n  );\n\n  return cameraPositionSynchronizer;\n}\n","import {\n  BaseVolumeViewport,\n  getRenderingEngine,\n  StackViewport,\n  Types,\n} from '@cornerstonejs/core';\n\n/**\n * Synchronizer callback to synchronize the voi of volumeActors of identical volumes\n * in different viewports.\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport.\n * @param voiModifiedEvent - The VOI_MODIFIED event.\n * @param options - Options for the synchronizer.\n */\nexport default function voiSyncCallback(\n  synchronizerInstance,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId,\n  voiModifiedEvent: Types.EventTypes.VoiModifiedEvent,\n  options?: any\n): void {\n  const eventDetail = voiModifiedEvent.detail;\n  const { volumeId, range, invertStateChanged, invert } = eventDetail;\n\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `Rendering Engine does not exist: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const tProperties:\n    | Types.VolumeViewportProperties\n    | Types.StackViewportProperties = {\n    voiRange: range,\n  };\n\n  if (options?.syncInvertState && invertStateChanged) {\n    tProperties.invert = invert;\n  }\n\n  if (tViewport instanceof BaseVolumeViewport) {\n    tViewport.setProperties(tProperties, volumeId);\n  } else if (tViewport instanceof StackViewport) {\n    tViewport.setProperties(tProperties);\n  } else {\n    throw new Error('Viewport type not supported.');\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\ntype VOISynchronizerOptions = {\n  syncInvertState: boolean;\n};\n\n/**\n * A helper that creates a new `Synchronizer`\n * which listens to the `VOI_MODIFIED` rendering event and calls the `voiSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @param options - The options for the synchronizer. By default the voi\n * synchronizer will also sync the invert state of the volume, but this can be\n * disabled by setting `syncInvertState` to false.\n *\n * @returns A new `Synchronizer` instance.\n */\nexport default function createVOISynchronizer(\n  synchronizerName: string,\n  options = { syncInvertState: true } as VOISynchronizerOptions\n): Synchronizer {\n  const VOISynchronizer = createSynchronizer(\n    synchronizerName,\n    Enums.Events.VOI_MODIFIED,\n    voiSyncCallback,\n    options\n  );\n\n  return VOISynchronizer;\n}\n","import { getRenderingEngine, Types } from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\n\n/**\n * Synchronizer callback to synchronize the camera. Synchronization\n *\n * targetViewport.options.syncZoom set to false to not sync the zoom\n * targetViewport.options.syncPan set to false to not sync the pan\n\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, different\n *   from sourceViewport\n */\nexport default function zoomPanSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): void {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n  const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n\n  if (options?.syncZoom !== false) {\n    const srcZoom = sViewport.getZoom();\n    // Do the zoom first, as the pan is relative to the zoom level\n    tViewport.setZoom(srcZoom);\n  }\n  if (options?.syncPan !== false) {\n    const srcPan = sViewport.getPan();\n    tViewport.setPan(srcPan);\n  }\n\n  tViewport.render();\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { CAMERA_MODIFIED } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `CAMERA_MODIFIED`\n * rendering event and calls the `cameraSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createZoomPanSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const zoomPanSynchronizer = createSynchronizer(\n    synchronizerName,\n    CAMERA_MODIFIED,\n    zoomPanSyncCallback\n  );\n\n  return zoomPanSynchronizer;\n}\n","/**\n * Clips a value to an upper and lower bound.\n * @export @public @method\n * @name clip\n *\n * @param  {number} val  The value to clip.\n * @param  {number} low  The lower bound.\n * @param  {number} high The upper bound.\n * @returns {number}      The clipped value.\n */\nexport function clip(val, low, high) {\n  return Math.min(Math.max(low, val), high);\n}\n\n/**\n * Clips a value within a box.\n * @export @public @method\n * @name clipToBox\n *\n * @param  {Object} point The point to clip\n * @param  {Object} box   The bounding box to clip to.\n * @returns {Object}       The clipped point.\n */\nexport function clipToBox(point, box) {\n  // Clip an {x, y} point to a box of size {width, height}\n  point.x = clip(point.x, 0, box.width);\n  point.y = clip(point.y, 0, box.height);\n}\n\nexport default clip;\n","import {\n  StackViewport,\n  Types,\n  VolumeViewport,\n  eventTarget,\n  EVENTS,\n  utilities as csUtils,\n  getEnabledElement,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport { ScrollOptions, EventTypes } from '../types';\n\n/**\n * It scrolls one slice in the Stack or Volume Viewport, it uses the options provided\n * to determine the slice to scroll to. For Stack Viewport, it scrolls in the 1 or -1\n * direction, for Volume Viewport, it uses the camera and focal point to determine the\n * slice to scroll to based on the spacings.\n * @param viewport - The viewport in which to scroll\n * @param options - Options to use for scrolling, including direction, invert, and volumeId\n * @returns\n */\nexport default function scroll(\n  viewport: Types.IViewport,\n  options: ScrollOptions\n): void {\n  // check if viewport is disabled then throw error\n  const enabledElement = getEnabledElement(viewport.element);\n\n  if (!enabledElement) {\n    throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n  }\n\n  if (\n    viewport instanceof StackViewport &&\n    viewport.getImageIds().length === 0\n  ) {\n    throw new Error('Scroll::Stack Viewport has no images');\n  }\n\n  const { type: viewportType } = viewport;\n  const { volumeId, delta } = options;\n\n  if (viewport instanceof StackViewport) {\n    viewport.scroll(delta, options.debounceLoading, options.loop);\n  } else if (viewport instanceof VolumeViewport) {\n    scrollVolume(viewport, volumeId, delta);\n  } else if (viewport instanceof VideoViewport) {\n    viewport.scroll(delta);\n  } else {\n    throw new Error(`Not implemented for Viewport Type: ${viewportType}`);\n  }\n}\n\nexport function scrollVolume(\n  viewport: VolumeViewport,\n  volumeId: string,\n  delta: number\n) {\n  const { numScrollSteps, currentStepIndex, sliceRangeInfo } =\n    csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n\n  if (!sliceRangeInfo) {\n    return;\n  }\n\n  const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n  const { focalPoint, viewPlaneNormal, position } = camera;\n\n  const { newFocalPoint, newPosition } = csUtils.snapFocalPointToSlice(\n    focalPoint,\n    position,\n    sliceRange,\n    viewPlaneNormal,\n    spacingInNormalDirection,\n    delta\n  );\n\n  viewport.setCamera({\n    focalPoint: newFocalPoint,\n    position: newPosition,\n  });\n  viewport.render();\n\n  const desiredStepIndex = currentStepIndex + delta;\n\n  if (\n    (desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n    viewport.getCurrentImageId() // Check that we are in the plane of acquistion\n  ) {\n    // One common use case of this trigger might be to load the next\n    // volume in a time series or the next segment of a partially loaded volume.\n\n    const VolumeScrollEventDetail = {\n      volumeId,\n      viewport,\n      delta,\n      desiredStepIndex,\n      currentStepIndex,\n      numScrollSteps,\n      currentImageId: viewport.getCurrentImageId(),\n    };\n\n    csUtils.triggerEvent(\n      eventTarget,\n      EVENTS.VOLUME_SCROLL_OUT_OF_BOUNDS,\n      VolumeScrollEventDetail as EventTypes.VolumeScrollOutOfBoundsEventDetail\n    );\n  }\n}\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n  Types,\n} from '@cornerstonejs/core';\nimport JumpToSliceOptions from '../../types/JumpToSliceOptions';\nimport clip from '../clip';\nimport scroll from '../scroll';\n\n/**\n * It uses the imageIndex in the Options to scroll to the slice that is intended.\n * It works for both Stack and Volume viewports. In VolumeViewports, the imageIndex\n * should be given with respect to the index in the 3D image in the view direction\n * (i.e. the index of the slice in Axial, Sagittal, Coronal, or Oblique).\n *\n * @param element - the HTML Div element scrolling inside\n * @param options - the options used for jumping to a slice\n * @returns Promise that resolves to ImageIdIndex\n */\nasync function jumpToSlice(\n  element: HTMLDivElement,\n  options = {} as JumpToSliceOptions\n): Promise<void> {\n  const { imageIndex, debounceLoading, volumeId } = options;\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error('Element has been disabled');\n  }\n\n  const { viewport } = enabledElement;\n\n  const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(\n    viewport,\n    debounceLoading\n  );\n\n  const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n  const delta = imageIndexToJump - currentImageIndex;\n\n  scroll(viewport, { delta, debounceLoading, volumeId });\n}\n\nfunction _getImageSliceData(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  debounceLoading?: boolean\n): Types.ImageSliceData {\n  if (viewport instanceof StackViewport) {\n    return {\n      numberOfSlices: viewport.getImageIds().length,\n      imageIndex: debounceLoading\n        ? viewport.getTargetImageIdIndex()\n        : viewport.getCurrentImageIdIndex(),\n    };\n  } else if (viewport instanceof VolumeViewport) {\n    return csUtils.getImageSliceDataForVolumeViewport(viewport);\n  } else {\n    throw new Error('Unsupported viewport type');\n  }\n}\n\nfunction _getImageIndexToJump(\n  numberOfSlices: number,\n  imageIndex: number\n): number {\n  const lastSliceIndex = numberOfSlices - 1;\n\n  return clip(imageIndex, 0, lastSliceIndex);\n}\n\nexport default jumpToSlice;\n","import { vec3, mat4 } from 'gl-matrix';\nimport {\n  getRenderingEngine,\n  Types,\n  metaData,\n  utilities,\n} from '@cornerstonejs/core';\nimport { Synchronizer } from '../../store';\nimport { jumpToSlice } from '../../utilities';\nimport areViewportsCoplanar from './areViewportsCoplanar ';\n\nconst getSpatialRegistration = (targetId, sourceId) =>\n  utilities.spatialRegistrationMetadataProvider.get(\n    'spatialRegistrationModule',\n    [targetId, sourceId]\n  );\n\n/**\n * Synchronizer callback to synchronize the source viewport image to the\n * target viewports closest image in its stack.\n *\n * This synchronizer does a setup (which can already be predefined as required)\n * to register the target and soruce viewports.  The registration will default\n * to the identity registration if the same FOR is present in both viewports,\n * unless the option `useInitialPosition` is set in the target viewport.\n *\n * The consuming apps using Cornerstone3D (OHIF, etc) MAY provide such data in\n * the registrationMetadataProvider to override the data here. This can be done\n * by various methods 1) Using spatialRegistrationModule inside dicom 2) assuming\n * the user has actually manually scrolled the target viewport to the correct\n * slice before initiating the synchronization 3) using some other method\n *\n * @param synchronizerInstance - The Instance of the Synchronizer\n * @param sourceViewport - The list of IDs defining the source viewport.\n * @param targetViewport - The list of IDs defining the target viewport, never\n *   the same as sourceViewport.\n * @param cameraModifiedEvent - The CAMERA_MODIFIED event.\n */\nexport default async function stackImageSyncCallback(\n  synchronizerInstance: Synchronizer,\n  sourceViewport: Types.IViewportId,\n  targetViewport: Types.IViewportId\n): Promise<void> {\n  const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n  if (!renderingEngine) {\n    throw new Error(\n      `No RenderingEngine for Id: ${targetViewport.renderingEngineId}`\n    );\n  }\n\n  const sViewport = renderingEngine.getViewport(\n    sourceViewport.viewportId\n  ) as Types.IStackViewport;\n\n  const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n\n  if (options?.disabled) {\n    return;\n  }\n\n  const tViewport = renderingEngine.getViewport(\n    targetViewport.viewportId\n  ) as Types.IStackViewport;\n\n  const imageId1 = sViewport.getCurrentImageId();\n  const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n  const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n\n  const targetImageIds = tViewport.getImageIds();\n\n  if (!areViewportsCoplanar(sViewport, tViewport)) {\n    return;\n  }\n\n  // if the frame of reference is different we need to use the registrationMetadataProvider\n  // and add that to the imagePositionPatient of the source viewport to get the\n  // imagePositionPatient of the target viewport's closest image in its stack\n  let registrationMatrixMat4 = getSpatialRegistration(\n    targetViewport.viewportId,\n    sourceViewport.viewportId\n  );\n\n  if (!registrationMatrixMat4) {\n    const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n    const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n    if (\n      frameOfReferenceUID1 === frameOfReferenceUID2 &&\n      options?.useInitialPosition !== false\n    ) {\n      registrationMatrixMat4 = mat4.identity(mat4.create());\n    } else {\n      utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n      registrationMatrixMat4 = getSpatialRegistration(\n        targetViewport.viewportId,\n        sourceViewport.viewportId\n      );\n    }\n    if (!registrationMatrixMat4) {\n      return;\n    }\n  }\n\n  // apply the registration matrix to the source viewport's imagePositionPatient\n  // to get the target viewport's imagePositionPatient\n  const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(\n    vec3.create(),\n    sourceImagePositionPatient,\n    registrationMatrixMat4\n  );\n\n  // find the closest image in the target viewport's stack to the\n  // targetImagePositionPatientWithRegistrationMatrix\n  const closestImageIdIndex2 = _getClosestImageIdIndex(\n    targetImagePositionPatientWithRegistrationMatrix,\n    targetImageIds\n  );\n\n  if (\n    closestImageIdIndex2.index !== -1 &&\n    tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index\n  ) {\n    await jumpToSlice(tViewport.element, {\n      imageIndex: closestImageIdIndex2.index,\n    });\n  }\n}\n\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n  // todo: this does not assume orientation yet, but that can be added later\n  // todo: handle multiframe images\n  return imageIds.reduce(\n    (closestImageIdIndex, imageId, index) => {\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n      const distance = vec3.distance(imagePositionPatient, targetPoint);\n\n      if (distance < closestImageIdIndex.distance) {\n        return {\n          distance,\n          index,\n        };\n      }\n      return closestImageIdIndex;\n    },\n    {\n      distance: Infinity,\n      index: -1,\n    }\n  );\n}\n","import { vec3 } from 'gl-matrix';\nimport { Types } from '@cornerstonejs/core';\n\nexport default function areViewportsCoplanar(\n  viewport1: Types.IStackViewport,\n  viewport2: Types.IStackViewport\n): boolean {\n  const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n  const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n  const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n  return Math.abs(dotProducts) > 0.9;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport stackImageSyncCallback from '../callbacks/stackImageSyncCallback';\nimport Synchronizer from '../../store/SynchronizerManager/Synchronizer';\n\nconst { STACK_NEW_IMAGE } = Enums.Events;\n\n/**\n * A helper that creates a new `Synchronizer` which listens to the `STACK_NEW_IMAGE`\n * rendering event and calls the `stackImageSyncCallback`.\n *\n * @param synchronizerName - The name of the synchronizer.\n * @returns A new `Synchronizer` instance.\n */\nexport default function createStackImageSynchronizer(\n  synchronizerName: string\n): Synchronizer {\n  const stackImageSynchronizer = createSynchronizer(\n    synchronizerName,\n    STACK_NEW_IMAGE,\n    stackImageSyncCallback\n  );\n\n  return stackImageSynchronizer;\n}\n","function _getHash(\n  annotationUID: string,\n  drawingElementType: string,\n  nodeUID: string\n): string {\n  return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\n\nexport default _getHash;\n","export function setAttributesIfNecessary(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const currentValue = svgNode.getAttribute(key);\n    const newValue = attributes[key];\n    if (newValue === undefined || newValue === '') {\n      svgNode.removeAttribute(key);\n    } else if (currentValue !== newValue) {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n  Object.keys(attributes).forEach((key) => {\n    const newValue = attributes[key];\n    if (newValue !== undefined && newValue !== '') {\n      svgNode.setAttribute(key, newValue);\n    }\n  });\n}\n\nexport default setNewAttributesIfValid;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\n\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawCircle(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  circleUID: string,\n  center: Types.Point2,\n  radius: number,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    fill,\n    width,\n    lineWidth,\n    lineDash,\n    fillOpacity,\n    strokeOpacity,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      fill: 'transparent',\n      width: '2',\n      lineDash: undefined,\n      lineWidth: undefined,\n      strokeOpacity: 1,\n      fillOpacity: 1,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  // variable for the namespace\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n  const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    r: `${radius}`,\n    stroke: color,\n    fill,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n    'fill-opacity': fillOpacity, // setting fill opacity\n    'stroke-opacity': strokeOpacity, // setting stroke opacity\n  };\n\n  if (existingCircleElement) {\n    setAttributesIfNecessary(attributes, existingCircleElement);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newCircleElement = document.createElementNS(svgns, 'circle');\n\n    if (dataId !== '') {\n      newCircleElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newCircleElement);\n\n    svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n  }\n}\n\nexport default drawCircle;\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\n\nfunction drawEllipse(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  ellipseUID: string,\n  corner1: Types.Point2,\n  corner2: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n  const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const w = Math.abs(corner1[0] - corner2[0]);\n  const h = Math.abs(corner1[1] - corner2[1]);\n  const xMin = Math.min(corner1[0], corner2[0]);\n  const yMin = Math.min(corner1[1], corner2[1]);\n\n  const center = [xMin + w / 2, yMin + h / 2];\n  const radiusX = w / 2;\n  const radiusY = h / 2;\n\n  const attributes = {\n    cx: `${center[0]}`,\n    cy: `${center[1]}`,\n    rx: `${radiusX}`,\n    ry: `${radiusY}`,\n    stroke: color,\n    fill: 'transparent',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingEllipse) {\n    setAttributesIfNecessary(attributes, existingEllipse);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n\n    if (dataId !== '') {\n      svgEllipseElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgEllipseElement);\n\n    svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n  }\n}\n\nexport default drawEllipse;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawHandles(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  handleGroupUID: string,\n  handlePoints: Array<Types.Point2>,\n  options = {}\n): void {\n  const { color, handleRadius, width, lineWidth, fill, type, opacity } =\n    Object.assign(\n      {\n        color: 'dodgerblue',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  for (let i = 0; i < handlePoints.length; i++) {\n    const handle = handlePoints[i];\n\n    // variable for the namespace\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(\n      annotationUID,\n      'handle',\n      `hg-${handleGroupUID}-index-${i}`\n    );\n\n    let attributes;\n    if (type === 'circle') {\n      attributes = {\n        cx: `${handle[0]}`,\n        cy: `${handle[1]}`,\n        r: handleRadius,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        opacity: opacity,\n      };\n    } else if (type === 'rect') {\n      const handleRadiusFloat = parseFloat(handleRadius);\n      const side = handleRadiusFloat * 1.5;\n      const x = handle[0] - side * 0.5;\n      const y = handle[1] - side * 0.5;\n\n      attributes = {\n        x: `${x}`,\n        y: `${y}`,\n        width: `${side}`,\n        height: `${side}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        rx: `${side * 0.1}`,\n        opacity: opacity,\n      };\n    } else {\n      throw new Error(`Unsupported handle type: ${type}`);\n    }\n\n    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n    if (existingHandleElement) {\n      setAttributesIfNecessary(attributes, existingHandleElement);\n\n      svgDrawingHelper.setNodeTouched(svgNodeHash);\n    } else {\n      const newHandleElement = document.createElementNS(svgns, type);\n\n      setNewAttributesIfValid(attributes, newHandleElement);\n\n      svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n    }\n  }\n}\n\nexport default drawHandles;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\nexport default function drawLine(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  lineUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash, shadow } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n      shadow: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n  const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n  const dropShadowStyle = shadow\n    ? `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`\n    : '';\n\n  const attributes = {\n    x1: `${start[0]}`,\n    y1: `${start[1]}`,\n    x2: `${end[0]}`,\n    y2: `${end[1]}`,\n    stroke: color,\n    style: dropShadowStyle,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newLine = document.createElementNS(svgns, 'line');\n\n    if (dataId !== '') {\n      newLine.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, newLine);\n\n    svgDrawingHelper.appendNode(newLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport { SVGDrawingHelper } from '../types';\n\n/**\n * Draws an SVG polyline with the given points.\n *\n * The `connectLastToFirst` option, if true, draws a closed polyline, with the\n * last point connected to the first.\n */\nexport default function drawPolyline(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  polylineUID: string,\n  points: Types.Point2[],\n  options: {\n    color?: string;\n    fillColor?: string;\n    fillOpacity?: number;\n    width?: number;\n    lineWidth?: number;\n    lineDash?: string;\n    connectLastToFirst?: boolean;\n  }\n): void {\n  if (points.length < 2) {\n    return;\n  }\n\n  const { fillColor, fillOpacity, color, width, lineWidth, lineDash } =\n    Object.assign(\n      {\n        color: 'dodgerblue',\n        width: '2',\n        fillColor: 'none',\n        fillOpacity: 0,\n        lineWidth: undefined,\n        lineDash: undefined,\n        connectLastToFirst: false,\n      },\n      options\n    );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n  const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  let pointsAttribute = '';\n\n  for (const point of points) {\n    pointsAttribute += `${point[0]}, ${point[1]} `;\n  }\n\n  if (options.connectLastToFirst) {\n    const firstPoint = points[0];\n\n    pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n  }\n\n  const attributes = {\n    points: pointsAttribute,\n    stroke: color,\n    fill: fillColor,\n    'fill-opacity': fillOpacity,\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingPolyLine) {\n    // This is run to avoid re-rendering annotations that actually haven't changed\n    setAttributesIfNecessary(attributes, existingPolyLine);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const newPolyLine = document.createElementNS(svgns, 'polyline');\n\n    setNewAttributesIfValid(attributes, newPolyLine);\n\n    svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\n\n/**\n * Draws a textBox.\n *\n * @param textLines - The text to display.\n * @param position - The x/y position of the textbox\n * @param options - Options for the textBox.\n * @returns Bounding box; can be used for isPointNearTool\n */\nfunction drawTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string>,\n  position: Types.Point2,\n  options = {}\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      fontFamily: 'Helvetica, Arial, sans-serif',\n      fontSize: '14px',\n      color: 'rgb(255, 255, 0)',\n      background: '',\n      padding: 25,\n      centerX: false,\n      centerY: true,\n    },\n    options\n  );\n\n  // Draw each of the text lines on top of the background box\n  const textGroupBoundingBox = _drawTextGroup(\n    svgDrawingHelper,\n    annotationUID,\n    textUID,\n    textLines,\n    position,\n    mergedOptions\n  );\n\n  return textGroupBoundingBox;\n}\n\nfunction _drawTextGroup(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textUID: string,\n  textLines: Array<string> = [''],\n  position: Types.Point2,\n  options: any\n): SVGRect {\n  const { padding, color, fontFamily, fontSize, background } = options;\n\n  let textGroupBoundingBox;\n  const [x, y] = [position[0] + padding, position[1] + padding];\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n  const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  // Todo: right now textBox gets a re-render even if the textBox has not changed\n  // and evenIf the attributes are not set again since they are the same.\n  if (existingTextGroup) {\n    // TODO: Iterate each node and update color? font-size?\n    const textElement = existingTextGroup.querySelector('text');\n    const textSpans = Array.from(textElement.children) as Array<SVGElement>;\n\n    for (let i = 0; i < textSpans.length; i++) {\n      const textSpanElement = textSpans[i];\n      const text = textLines[i] || '';\n\n      textSpanElement.textContent = text;\n    }\n\n    // if the textLines have changed size, we need to create textSpans for them\n    if (textLines.length > textSpans.length) {\n      for (let i = 0; i < textLines.length - textSpans.length; i++) {\n        const textLine = textLines[i + textSpans.length];\n        const textSpan = _createTextSpan(textLine);\n\n        textElement.appendChild(textSpan);\n      }\n\n      existingTextGroup.appendChild(textElement);\n      svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n    }\n\n    const textAttributes = {\n      fill: color,\n      'font-size': fontSize,\n      'font-family': fontFamily,\n    };\n\n    const textGroupAttributes = {\n      transform: `translate(${x} ${y})`,\n    };\n\n    // Todo: for some reason this does not work to not re-render the textBox\n    setAttributesIfNecessary(textAttributes, textElement);\n    setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n\n    textGroupBoundingBox = _drawTextBackground(existingTextGroup, background);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const textGroup = document.createElementNS(svgns, 'g');\n\n    textGroup.setAttribute('transform', `translate(${x} ${y})`);\n\n    //\n    const textElement = _createTextElement(svgDrawingHelper, options);\n    for (let i = 0; i < textLines.length; i++) {\n      const textLine = textLines[i];\n      const textSpan = _createTextSpan(textLine);\n\n      textElement.appendChild(textSpan);\n    }\n\n    textGroup.appendChild(textElement);\n    svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n    textGroupBoundingBox = _drawTextBackground(textGroup, background);\n  }\n\n  // We translate the group using `position`\n  // which means we also need to pluck those values when returning\n  // the bounding box\n  return Object.assign({}, textGroupBoundingBox, {\n    x,\n    y,\n    height: textGroupBoundingBox.height + padding,\n    width: textGroupBoundingBox.width + padding,\n  });\n}\n\nfunction _createTextElement(\n  svgDrawingHelper: SVGDrawingHelper,\n  options: any\n): SVGElement {\n  const { color, fontFamily, fontSize } = options;\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textElement = document.createElementNS(svgns, 'text');\n  const noSelectStyle =\n    'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n  const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n  const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n\n  // font-size=\"100\"\n  textElement.setAttribute('x', '0');\n  textElement.setAttribute('y', '0');\n  textElement.setAttribute('fill', color);\n  textElement.setAttribute('font-family', fontFamily);\n  textElement.setAttribute('font-size', fontSize);\n  textElement.setAttribute('style', combinedStyle);\n\n  return textElement;\n}\n\nfunction _createTextSpan(text): SVGElement {\n  const svgns = 'http://www.w3.org/2000/svg';\n  const textSpanElement = document.createElementNS(svgns, 'tspan');\n\n  // TODO: centerX\n  // (parent width / 2) - my width\n  // TODO: centerY\n\n  textSpanElement.setAttribute('x', '0');\n  textSpanElement.setAttribute('dy', '1.2em');\n  textSpanElement.textContent = text;\n\n  return textSpanElement;\n}\n\nfunction _drawTextBackground(group: SVGGElement, color: string) {\n  let element = group.querySelector('rect.background');\n\n  // If we have no background color, remove any element that exists and return\n  // the bounding box of the text\n  if (!color) {\n    if (element) {\n      group.removeChild(element);\n    }\n\n    return group.getBBox();\n  }\n\n  // Otherwise, check if we have a <rect> element. If not, create one\n  if (!element) {\n    element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    element.setAttribute('class', 'background');\n    group.insertBefore(element, group.firstChild);\n  }\n\n  // Get the text groups's bounding box and use it to draw the background rectangle\n  const bBox = group.getBBox();\n\n  const attributes = {\n    x: `${bBox.x}`,\n    y: `${bBox.y}`,\n    width: `${bBox.width}`,\n    height: `${bBox.height}`,\n    fill: color,\n  };\n\n  setAttributesIfNecessary(attributes, element);\n\n  return bBox;\n}\n\nexport default drawTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Find the closest point to the target point\n *\n * @param sourcePoints - The potential source points.\n * @param targetPoint - The target point, used to find the closest source.\n * @returns The closest point in the array of point sources\n */\nexport default function findClosestPoint(\n  sourcePoints: Array<Types.Point2>,\n  targetPoint: Types.Point2\n): Types.Point2 {\n  let minPoint = [0, 0];\n  let minDistance = Number.MAX_SAFE_INTEGER;\n\n  sourcePoints.forEach(function (sourcePoint) {\n    const distance = _distanceBetween(targetPoint, sourcePoint);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      minPoint = [...sourcePoint];\n    }\n  });\n\n  return minPoint as Types.Point2;\n}\n\n/**\n *\n * @private\n * @param p1\n * @param p2\n */\nfunction _distanceBetween(p1: Types.Point2, p2: Types.Point2): number {\n  const [x1, y1] = p1;\n  const [x2, y2] = p2;\n\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nimport { PlanarBoundingBox, SVGDrawingHelper } from '../types';\n\n/**\n * Draw a link between an annotation to a box.\n */\nfunction drawLink(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  linkUID: string,\n  // Find closest point to approx. bounding box\n  annotationAnchorPoints: Array<Types.Point2>,\n  refPoint: Types.Point2,\n  // Find bounding box point that's closest to our identified\n  // start point\n  boundingBox: PlanarBoundingBox,\n  options = {}\n): void {\n  // The closest anchor point (for the annotation) to the\n  // text box / bounding box\n  const start =\n    annotationAnchorPoints.length > 0\n      ? findClosestPoint(annotationAnchorPoints, refPoint)\n      : refPoint;\n\n  // Calculate the midpoints of the bounding box\n  const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n  // Find the closest textBox midpoint to the annotation's anchor/start point\n  const end = findClosestPoint(boundingBoxPoints, start);\n\n  // Finally we draw the dashed linking line\n  const mergedOptions = Object.assign(\n    {\n      color: 'rgb(255, 255, 0)',\n      lineWidth: '1',\n      lineDash: '2,3',\n    },\n    options\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    `link-${linkUID}`,\n    start,\n    end,\n    mergedOptions\n  );\n}\n\n/**\n * Find potential anchor points for a given bounding box. For example, it may\n * look nicer to draw a line from the \"middle left\" of a bounding box to an\n * annotation (instead of from a corner). This function calculates those points\n *\n * @param boundingBox\n */\nfunction _boundingBoxPoints(\n  boundingBox: PlanarBoundingBox\n): Array<Types.Point2> {\n  const { x: left, y: top, height, width } = boundingBox;\n  const halfWidth = width / 2;\n  const halfHeight = height / 2;\n\n  const topMiddle = [left + halfWidth, top] as Types.Point2;\n  const leftMiddle = [left, top + halfHeight] as Types.Point2;\n  const bottomMiddle = [left + halfWidth, top + height] as Types.Point2;\n  const rightMiddle = [left + width, top + halfHeight] as Types.Point2;\n\n  return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\n\nexport default drawLink;\n","import type { Types } from '@cornerstonejs/core';\n\nimport drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nimport { SVGDrawingHelper } from '../types';\n\nfunction drawLinkedTextBox(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  textBoxUID: string,\n  //\n  textLines: Array<string>,\n  textBoxPosition: Types.Point2,\n  annotationAnchorPoints: Array<Types.Point2>,\n  textBox: unknown,\n  options = {}\n  // TODO: yCenter as an option\n): SVGRect {\n  const mergedOptions = Object.assign(\n    {\n      handleRadius: '6',\n      centering: {\n        x: false,\n        y: true, // yCenter,\n      },\n    },\n    options\n  );\n\n  // Draw the text box\n  const canvasBoundingBox = drawTextBox(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    textLines,\n    textBoxPosition,\n    mergedOptions\n  );\n  // if (textBox.hasMoved) {\n  //   // Draw dashed link line between tool and text\n  drawLink(\n    svgDrawingHelper,\n    annotationUID,\n    textBoxUID,\n    annotationAnchorPoints, // annotationAnchorPoints\n    textBoxPosition, // refPoint (text)\n    canvasBoundingBox, // textBoxBoundingBox\n    mergedOptions\n  );\n  // }\n\n  // const { top, left, width, height } = canvasBoundingBox\n\n  // textBox.worldBoundingBox = {\n  //   topLeft: canvasToWorld([left, top]),\n  //   topRight: canvasToWorld([left + width, top]),\n  //   bottomLeft: canvasToWorld([left, top + height]),\n  //   bottomRight: canvasToWorld([left + width, top + height]),\n  // }\n\n  return canvasBoundingBox;\n}\n\nexport default drawLinkedTextBox;\n","import type { Types } from '@cornerstonejs/core';\n\nimport _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport { SVGDrawingHelper } from '../types';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRect(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  rectangleUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {},\n  dataId = ''\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'transparent',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    if (dataId !== '') {\n      svgRectElement.setAttribute('data-id', dataId);\n    }\n\n    setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { SVGDrawingHelper } from '../types';\nimport drawLine from './drawLine';\n\nexport default function drawArrow(\n  svgDrawingHelper: SVGDrawingHelper,\n  annotationUID: string,\n  arrowUID: string,\n  start: Types.Point2,\n  end: Types.Point2,\n  options = {}\n): void {\n  // if length is NaN return\n  if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n    return;\n  }\n\n  const { color, width, lineWidth, lineDash } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // The line itself\n  drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n    color,\n    width,\n    lineWidth,\n    lineDash,\n  });\n\n  // Drawing the head arrow with two lines\n  // Variables to be used when creating the arrow\n  const headLength = 10;\n  const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n\n  const firstLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle - Math.PI / 7),\n      end[1] - headLength * Math.sin(angle - Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  const secondLine = {\n    start: [\n      end[0] - headLength * Math.cos(angle + Math.PI / 7),\n      end[1] - headLength * Math.sin(angle + Math.PI / 7),\n    ] as Types.Point2,\n    end: end,\n  };\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '2',\n    firstLine.start,\n    firstLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n\n  drawLine(\n    svgDrawingHelper,\n    annotationUID,\n    '3',\n    secondLine.start,\n    secondLine.end,\n    {\n      color,\n      width,\n      lineWidth,\n    }\n  );\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\n\n// <rect x=\"120\" y=\"100\" width=\"100\" height=\"100\" />\nexport default function drawRedactionRect(\n  svgDrawingHelper: any,\n  annotationUID: string,\n  rectangleUID: string,\n  start: any,\n  end: any,\n  options = {}\n): void {\n  const {\n    color,\n    width: _width,\n    lineWidth,\n    lineDash,\n  } = Object.assign(\n    {\n      color: 'dodgerblue',\n      width: '2',\n      lineWidth: undefined,\n      lineDash: undefined,\n    },\n    options\n  );\n\n  // for supporting both lineWidth and width options\n  const strokeWidth = lineWidth || _width;\n\n  const svgns = 'http://www.w3.org/2000/svg';\n  const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n  const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n\n  const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n  const width = Math.abs(start[0] - end[0]);\n  const height = Math.abs(start[1] - end[1]);\n\n  const attributes = {\n    x: `${tlhc[0]}`,\n    y: `${tlhc[1]}`,\n    width: `${width}`,\n    height: `${height}`,\n    stroke: color,\n    fill: 'black',\n    'stroke-width': strokeWidth,\n    'stroke-dasharray': lineDash,\n  };\n\n  if (existingRect) {\n    _setAttributesIfNecessary(attributes, existingRect);\n\n    svgDrawingHelper.setNodeTouched(svgNodeHash);\n  } else {\n    const svgRectElement = document.createElementNS(svgns, 'rect');\n\n    _setNewAttributesIfValid(attributes, svgRectElement);\n\n    svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n  }\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool, BaseTool } from '../tools';\nimport { Annotation } from '../types';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\n\n/**\n * Get the annotation that is close to the provided canvas point, it will return\n * the first annotation that is found.\n *\n * @param element - The element to search for an annotation on.\n * @param canvasPoint - The canvasPoint on the page where the user clicked.\n * @param proximity - The distance from the canvasPoint to the annotation.\n * @returns The annotation for the element\n */\nfunction getAnnotationNearPoint(\n  element: HTMLDivElement,\n  canvasPoint: Types.Point2,\n  proximity = 5\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    throw new Error('getAnnotationNearPoint: enabledElement not found');\n  }\n\n  return getAnnotationNearPointOnEnabledElement(\n    enabledElement,\n    canvasPoint,\n    proximity\n  );\n}\n\n/**\n * \"Find the annotation near the point on the enabled element.\" it will return the\n * first annotation that is found.\n *\n * @param enabledElement - The element that is currently active.\n * @param point - The point to search near.\n * @param proximity - The distance from the point that the annotation must\n * be within.\n * @returns A Annotation object.\n */\nfunction getAnnotationNearPointOnEnabledElement(\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function should return closest annotation, BUT, we are not using\n  // the function anywhere.\n  const { renderingEngineId, viewportId } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (!toolGroup) {\n    return null;\n  }\n\n  const { _toolInstances: tools } = toolGroup;\n  for (const name in tools) {\n    const found = findAnnotationNearPointByTool(\n      tools[name],\n      enabledElement,\n      point,\n      proximity\n    );\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\n/**\n * For the provided toolClass, it will find the annotation that is near the point,\n * it will return the first annotation that is found.\n *\n * @param tool - AnnotationTool\n * @param enabledElement - The element that is currently active.\n * @param point - The point in the image where the user clicked.\n * @param proximity - The distance from the point that the tool must be\n * within to be considered \"near\" the point.\n * @returns The annotation object that is being returned is the annotation object that\n * is being used in the tool.\n */\nfunction findAnnotationNearPointByTool(\n  tool: AnnotationTool,\n  enabledElement: Types.IEnabledElement,\n  point: Types.Point2,\n  proximity: number\n): Annotation | null {\n  // Todo: this function does not return closest annotation. It just returns\n  // the first annotation that is found in the proximity. BUT, we are not using\n  // the function anywhere.\n  const { viewport } = enabledElement;\n\n  const annotations = getAnnotations(\n    (tool.constructor as typeof BaseTool).toolName,\n    viewport?.element\n  );\n  const currentId = viewport?.getCurrentImageId?.();\n  if (annotations?.length) {\n    const { element } = enabledElement.viewport;\n    for (const annotation of annotations) {\n      const referencedImageId = annotation.metadata?.referencedImageId;\n      if (\n        (currentId && referencedImageId && currentId !== referencedImageId) ||\n        !tool.isPointNearTool\n      ) {\n        continue;\n      }\n\n      if (\n        tool.isPointNearTool(element, annotation, point, proximity, '') ||\n        tool.getHandleNearImagePoint(element, annotation, point, proximity)\n      ) {\n        return annotation;\n      }\n    }\n  }\n  return null;\n}\n\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @since 0.1.0\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * isObject({})\n * // => true\n *\n * isObject([1, 2, 3])\n * // => true\n *\n * isObject(Function)\n * // => true\n *\n * isObject(null)\n * // => false\n */\nfunction isObject(value) {\n  const type = typeof value;\n\n  return value !== null && (type === 'object' || type === 'function');\n}\n\nexport default isObject;\n","import isObject from './isObject';\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn. The debounced function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * debounced function. Subsequent calls to the debounced function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', debounce(calculateLayout, 150))\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }))\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = debounce(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * jQuery(source).on('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nfunction debounce(func, wait, options) {\n  let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n\n  let lastInvokeTime = 0;\n  let leading = false;\n  let maxing = false;\n  let trailing = true;\n\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF =\n    !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  wait = Number(wait) || 0;\n  if (isObject(options)) {\n    leading = Boolean(options.leading);\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  function invokeFunc(time) {\n    const args = lastArgs;\n    const thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n\n    return result;\n  }\n\n  function startTimer(pendingFunc, wait) {\n    if (useRAF) {\n      return window.requestAnimationFrame(pendingFunc);\n    }\n\n    return setTimeout(pendingFunc, wait);\n  }\n\n  function cancelTimer(id) {\n    if (useRAF) {\n      return window.cancelAnimationFrame(id);\n    }\n    clearTimeout(id);\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = startTimer(timerExpired, wait);\n\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n    const timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    const timeSinceLastCall = time - lastCallTime;\n    const timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (\n      lastCallTime === undefined ||\n      timeSinceLastCall >= wait ||\n      timeSinceLastCall < 0 ||\n      (maxing && timeSinceLastInvoke >= maxWait)\n    );\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = startTimer(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      cancelTimer(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(Date.now());\n  }\n\n  function pending() {\n    return timerId !== undefined;\n  }\n\n  function debounced(...args) {\n    const time = Date.now();\n    const isInvoking = shouldInvoke(time);\n\n    lastArgs = args;\n    lastThis = this; // eslint-disable-line consistent-this\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = startTimer(timerExpired, wait);\n\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = startTimer(timerExpired, wait);\n    }\n\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  debounced.pending = pending;\n\n  return debounced;\n}\n\nexport default debounce;\n","import debounce from './debounce';\nimport isObject from './isObject';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame). The throttled function\n * comes with a `cancel` method to cancel delayed `func` invocations and a\n * `flush` method to immediately invoke them. Provide `options` to indicate\n * whether `func` should be invoked on the leading and/or trailing edge of the\n * `wait` timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', throttle(updatePosition, 100))\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = throttle(renewToken, 300000, { 'trailing': false })\n * jQuery(element).on('click', throttled)\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel)\n */\nfunction throttle(func, wait, options) {\n  let leading = true;\n  let trailing = true;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? Boolean(options.leading) : leading;\n    trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n  }\n\n  return debounce(func, wait, {\n    leading,\n    trailing,\n    maxWait: wait,\n  });\n}\n\nexport default throttle;\n","import { utilities, Enums } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\n\n/**\n * It adds the provided spacing to the Cornerstone internal calibratedPixelSpacing\n * metadata provider, then it invalidates all the tools that have the imageId as\n * their reference imageIds. Finally, it triggers a re-render for invalidated annotations.\n * @param imageId - ImageId for the calibrated image\n * @param rowPixelSpacing - Spacing in row direction\n * @param calibrationOrScale - either the calibration object or a scale value\n */\nexport default function calibrateImageSpacing(\n  imageId: string,\n  renderingEngine: Types.IRenderingEngine,\n  calibrationOrScale: Types.IImageCalibration | number\n): void {\n  // Handle simple parameter version\n  if (typeof calibrationOrScale === 'number') {\n    calibrationOrScale = {\n      type: Enums.CalibrationTypes.USER,\n      scale: calibrationOrScale,\n    };\n  }\n  // 1. Add the calibratedPixelSpacing metadata to the metadata\n  calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n\n  // 2. Update the actor for stackViewports\n  const viewports = renderingEngine.getStackViewports();\n\n  // 2.1 If imageId is already being used in a stackViewport -> update actor\n  viewports.forEach((viewport) => {\n    const imageIds = viewport.getImageIds();\n    if (imageIds.includes(imageId)) {\n      viewport.calibrateSpacing(imageId);\n    }\n  });\n\n  // 2.2 If imageId is cached but not being displayed in a viewport, stackViewport\n  // will handle using the calibratedPixelSpacing since it has been added\n  // to the provider\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: Types.Point3;\n  pointLPS: Types.Point3;\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: Types.Point3;\n  pointLPS: Types.Point3;\n}) => void;\n\nexport type ShapeFnCriteria = (\n  pointIJK: Types.Point3,\n  pointLPS: Types.Point3\n) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n\n  const pointsInShape: Array<PointInShape> = [];\n  for (let k = kMin; k <= kMax; k++) {\n    for (let j = jMin; j <= jMax; j++) {\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n        const dI = i - iMin;\n        const dJ = j - jMin;\n        const dK = k - kMin;\n\n        const startWorld = worldPosStart;\n\n        const pointLPS: Types.Point3 = [\n          startWorld[0] +\n            dI * rowStep[0] +\n            dJ * columnStep[0] +\n            dK * scanAxisStep[0],\n          startWorld[1] +\n            dI * rowStep[1] +\n            dJ * columnStep[1] +\n            dK * scanAxisStep[1],\n          startWorld[2] +\n            dI * rowStep[2] +\n            dJ * columnStep[2] +\n            dK * scanAxisStep[2],\n        ];\n\n        if (pointInShapeFn(pointLPS, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i;\n          const value = scalarData[index];\n\n          pointsInShape.push({ value, index, pointIJK, pointLPS });\n          if (callback !== null) {\n            callback({ value, index, pointIJK, pointLPS });\n          }\n        }\n      }\n    }\n  }\n  return pointsInShape;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * With a given vertices (points) coordinates in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If dimensions are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates (IJK)\n * @param dimensions - dimensions of the image\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nfunction getBoundingBoxAroundShape(\n  points: Types.Point3[],\n  dimensions?: Types.Point3\n): [Types.Point2, Types.Point2, Types.Point2] {\n  let xMin = Infinity;\n  let xMax = 0;\n  let yMin = Infinity;\n  let yMax = 0;\n  let zMin = Infinity;\n  let zMax = 0;\n\n  points.forEach((p) => {\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n    zMin = Math.min(p[2], zMin);\n    zMax = Math.max(p[2], zMax);\n  });\n\n  xMin = Math.floor(xMin);\n  xMax = Math.floor(xMax);\n  yMin = Math.floor(yMin);\n  yMax = Math.floor(yMax);\n  zMin = Math.floor(zMin);\n  zMax = Math.floor(zMax);\n\n  if (dimensions) {\n    // clip the min, max to the provided width, height and depth\n    const [width, height, depth] = dimensions;\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(width - 1, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(height - 1, yMax);\n    zMin = Math.max(0, zMin);\n    zMax = Math.min(depth - 1, zMax);\n  }\n\n  return [\n    [xMin, xMax],\n    [yMin, yMax],\n    [zMin, zMax],\n  ];\n}\n\nexport default getBoundingBoxAroundShape;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport pointInShapeCallback, {\n  PointInShapeCallback,\n} from './pointInShapeCallback';\nimport { BoundsIJK } from '../types';\nimport { getBoundingBoxAroundShape } from './boundingBox';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * Given an imageData, and the great circle top and bottom points of a sphere,\n * this function will run the callback for each point of the imageData that is\n * within the sphere defined by the great circle points. If the viewport\n * is provided, region of interest will be an accurate approximation of the\n * sphere (using viewport camera), and the resulting performance will be\n * better.\n *\n * @privateRemarks great circle also known as orthodrome is the intersection of\n * the sphere and the plane that passes through the center of the sphere\n *\n * @param imageData - The volume imageData\n * @param circlePoints - bottom and top points of the great circle in world coordinates\n * @param callback - A callback function that will be called for each point in the shape.\n */\nexport default function pointInSurroundingSphereCallback(\n  imageData: vtkImageData,\n  circlePoints: [Types.Point3, Types.Point3],\n  callback: PointInShapeCallback,\n  viewport?: Types.IVolumeViewport\n): void {\n  // We can run the sphere equation to determine if a point is inside\n  // the sphere; however, since the imageData dimensions can be quite large, we\n  // can narrow down the search by estimating the bounds of the sphere in index\n  // space.\n  const { boundsIJK, centerWorld, radiusWorld } = _getBounds(\n    circlePoints,\n    imageData,\n    viewport\n  );\n\n  const sphereObj = {\n    center: centerWorld,\n    radius: radiusWorld,\n  };\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS) => pointInSphere(sphereObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n}\n\nfunction _getBounds(\n  circlePoints: [Types.Point3, Types.Point3],\n  imageData: vtkImageData,\n  viewport\n): {\n  boundsIJK: BoundsIJK;\n  centerWorld: Types.Point3;\n  radiusWorld: number;\n} {\n  const [bottom, top] = circlePoints;\n\n  // Sphere center in world\n  const centerWorld = vec3.fromValues(\n    (bottom[0] + top[0]) / 2,\n    (bottom[1] + top[1]) / 2,\n    (bottom[2] + top[2]) / 2\n  );\n\n  // sphere radius in world\n  const radiusWorld = vec3.distance(bottom, top) / 2;\n\n  let boundsIJK;\n\n  if (!viewport) {\n    // If no viewport is provide (no camera), we can estimate the bounding box\n    // of the sphere in index space.\n    // This is done by calculating the maximum value for radius in the index\n    // space (since the radius is in world space, we need to convert it to index, and\n    // each dimensions can have a different scale factor). Therefore, by finding\n    // the minimum spacing value in the imageData, we can calculate the maximum\n    // radius in index space and use that to calculate the bounds of the sphere\n    // This will not be accurate, but it is a good first approximation.\n    // sphere center in index\n    const centerIJK = transformWorldToIndex(\n      imageData,\n      centerWorld as Types.Point3\n    );\n\n    const spacings = imageData.getSpacing();\n    const minSpacing = Math.min(...spacings);\n\n    const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n\n    boundsIJK = [\n      [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n      [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n      [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n    ];\n\n    return {\n      boundsIJK,\n      centerWorld: centerWorld as Types.Point3,\n      radiusWorld,\n    };\n  }\n\n  boundsIJK = _computeBoundsIJKWithCamera(\n    imageData,\n    viewport,\n    circlePoints,\n    centerWorld,\n    radiusWorld\n  );\n\n  return {\n    boundsIJK,\n    centerWorld: centerWorld as Types.Point3,\n    radiusWorld,\n  };\n}\n\nfunction _computeBoundsIJKWithCamera(\n  imageData,\n  viewport,\n  circlePoints,\n  centerWorld,\n  radiusWorld\n) {\n  const [bottom, top] = circlePoints;\n\n  const dimensions = imageData.getDimensions() as Types.Point3;\n  const camera = viewport.getCamera();\n\n  // Calculate viewRight from the camera, this will get used in order to\n  // calculate circles topLeft and bottomRight on different planes of intersection\n  // between sphere and viewPlane\n  const viewUp = vec3.fromValues(\n    camera.viewUp[0],\n    camera.viewUp[1],\n    camera.viewUp[2]\n  );\n  const viewPlaneNormal = vec3.fromValues(\n    camera.viewPlaneNormal[0],\n    camera.viewPlaneNormal[1],\n    camera.viewPlaneNormal[2]\n  );\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n  // we need to find the bounding box of the sphere in the image, e.g., the\n  // topLeftWorld and bottomRightWorld points of the bounding box.\n  // We go from the sphereCenter in the normal direction of amount radius, and\n  // we go left to find the topLeftWorld point of the bounding box. Next we go\n  // in the opposite direction and go right to find the bottomRightWorld point\n  // of the bounding box.\n  const topLeftWorld = vec3.create();\n  const bottomRightWorld = vec3.create();\n\n  vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n\n  // go in the direction of viewRight with the value of radius\n  vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n  vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n\n  // convert the world coordinates to index coordinates\n\n  const sphereCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, <Types.Point3>topLeftWorld),\n    <Types.Point3>(\n      transformWorldToIndex(imageData, <Types.Point3>bottomRightWorld)\n    ),\n  ];\n\n  // get the bounding box of the sphere in the image\n  const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n\n  return boundsIJK;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\ntype Sphere = {\n  center: Types.Point3 | vec3;\n  radius: number;\n};\n\n/**\n * Checks if a point is inside a sphere. Note: this is similar to the\n * `pointInEllipse` function, but since we don't need checks for the\n * ellipse's rotation in different views, we can use a simpler equation\n * which would be faster (no if statements).\n *\n * @param sphere - Sphere object with center and radius\n * @param pointLPS - the point to check in world coordinates\n * @returns boolean\n */\nexport default function pointInSphere(\n  sphere: Sphere,\n  pointLPS: Types.Point3\n): boolean {\n  const { center, radius } = sphere;\n\n  return (\n    (pointLPS[0] - center[0]) ** 2 +\n      (pointLPS[1] - center[1]) ** 2 +\n      (pointLPS[2] - center[2]) ** 2 <=\n    radius ** 2\n  );\n}\n","/**\n * Truncates decimal points to that there is at least 1+precision significant\n * digits.\n *\n * For example, with the default precision 2 (3 significant digits)\n * * Values larger than 100 show no information after the decimal point\n * * Values between 10 and 99 show 1 decimal point\n * * Values between 1 and 9 show 2 decimal points\n *\n * @param value - to return a fixed measurement value from\n * @param precision - defining how many digits after 1..9 are desired\n */\nfunction roundNumber(value: string | number, precision = 2): string {\n  if (value === undefined || value === null || value === '') {\n    return 'NaN';\n  }\n  value = Number(value);\n  if (value < 0.0001) {\n    return `${value}`;\n  }\n  const fixedPrecision =\n    value >= 100\n      ? precision - 2\n      : value >= 10\n      ? precision - 1\n      : value >= 1\n      ? precision\n      : value >= 0.1\n      ? precision + 1\n      : value >= 0.01\n      ? precision + 2\n      : value >= 0.001\n      ? precision + 3\n      : precision + 4;\n  return value.toFixed(fixedPrecision);\n}\n\nexport default roundNumber;\n","import { Types } from '@cornerstonejs/core';\n\nfunction isWithinThreshold(\n  index: number,\n  imageVolume: Types.IImageVolume,\n  strategySpecificConfiguration: any\n) {\n  const { THRESHOLD_INSIDE_CIRCLE } = strategySpecificConfiguration;\n\n  const voxelValue = imageVolume.getScalarData()[index];\n  const { threshold } = THRESHOLD_INSIDE_CIRCLE;\n\n  return threshold[0] <= voxelValue && voxelValue <= threshold[1];\n}\n\nexport default isWithinThreshold;\n","import type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInSurroundingSphereCallback } from '../../../utilities';\nimport isWithinThreshold from './utils/isWithinThreshold';\n\ntype OperationData = {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n  volume: Types.IImageVolume;\n  imageVolume: Types.IImageVolume;\n  segmentIndex: number;\n  segmentationId: string;\n  segmentsLocked: number[];\n  viewPlaneNormal: Types.Point3;\n  viewUp: Types.Point3;\n  strategySpecificConfiguration: any;\n  constraintFn: () => boolean;\n};\n\nfunction fillSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  _inside = true,\n  threshold = false\n): void {\n  const { viewport } = enabledElement;\n  const {\n    volume: segmentation,\n    segmentsLocked,\n    segmentIndex,\n    imageVolume,\n    strategySpecificConfiguration,\n    segmentationId,\n    points,\n  } = operationData;\n\n  const { imageData, dimensions } = segmentation;\n  const scalarData = segmentation.getScalarData();\n  const scalarIndex = [];\n\n  let callback;\n\n  if (threshold) {\n    callback = ({ value, index, pointIJK }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n\n      if (\n        isWithinThreshold(index, imageVolume, strategySpecificConfiguration)\n      ) {\n        scalarData[index] = segmentIndex;\n        scalarIndex.push(index);\n      }\n    };\n  } else {\n    callback = ({ index, value }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n      scalarData[index] = segmentIndex;\n      scalarIndex.push(index);\n    };\n  }\n\n  pointInSurroundingSphereCallback(\n    imageData,\n    [points[0], points[1]],\n    callback,\n    viewport as Types.IVolumeViewport\n  );\n\n  // Since the scalar indexes start from the top left corner of the cube, the first\n  // slice that needs to be rendered can be calculated from the first mask coordinate\n  // divided by the zMultiple, as well as the last slice for the last coordinate\n  const zMultiple = dimensions[0] * dimensions[1];\n  const minSlice = Math.floor(scalarIndex[0] / zMultiple);\n  const maxSlice = Math.floor(scalarIndex[scalarIndex.length - 1] / zMultiple);\n  const sliceArray = Array.from(\n    { length: maxSlice - minSlice + 1 },\n    (v, k) => k + minSlice\n  );\n\n  triggerSegmentationDataModified(segmentationId, sliceArray);\n}\n\n/**\n * Fill inside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nexport function fillInsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillSphere(enabledElement, operationData, true);\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being filled.\n * @param operationData - EraseOperationData\n */\nexport function thresholdInsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  const { volume, imageVolume } = operationData;\n\n  if (\n    !csUtils.isEqual(volume.dimensions, imageVolume.dimensions) ||\n    !csUtils.isEqual(volume.direction, imageVolume.direction)\n  ) {\n    throw new Error(\n      'Only source data the same dimensions/size/orientation as the segmentation currently supported.'\n    );\n  }\n\n  fillSphere(enabledElement, operationData, true, true);\n}\n\n/**\n * Fill outside a sphere with the given segment index in the given operation data. The\n * operation data contains the sphere required points.\n * @param enabledElement - The element that is enabled and selected.\n * @param operationData - OperationData\n */\nexport function fillOutsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillSphere(enabledElement, operationData, false);\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { fillInsideSphere } from './fillSphere';\n\ntype OperationData = {\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n  imageVolume: Types.IImageVolume;\n  volume: Types.IImageVolume;\n  segmentIndex: number;\n  segmentationId: string;\n  segmentsLocked: number[];\n  viewPlaneNormal: Types.Point3;\n  viewUp: Types.Point3;\n  constraintFn: () => boolean;\n  strategySpecificConfiguration: any;\n};\n\nexport function eraseInsideSphere(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillInsideCircle functionality.\n  const eraseOperationData = Object.assign({}, operationData, {\n    segmentIndex: 0,\n  });\n\n  fillInsideSphere(enabledElement, eraseOperationData);\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype canvasCoordinates = [\n  Types.Point2, // bottom\n  Types.Point2, // top\n  Types.Point2, // left\n  Types.Point2 // right\n];\n\n/**\n * It takes the canvas coordinates of the ellipse corners and returns the top left and bottom right\n * corners of it\n *\n * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasEllipseCorners(\n  ellipseCanvasPoints: canvasCoordinates\n): Array<Types.Point2> {\n  const [bottom, top, left, right] = ellipseCanvasPoints;\n\n  const topLeft = <Types.Point2>[left[0], top[1]];\n  const bottomRight = <Types.Point2>[right[0], bottom[1]];\n\n  return [topLeft, bottomRight];\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Ellipse = {\n  center: Types.Point3;\n  xRadius: number;\n  yRadius: number;\n  zRadius: number;\n};\n\n/**\n * Given an ellipse and a point, return true if the point is inside the ellipse\n * @param ellipse - The ellipse object to check against.\n * @param pointLPS - The point in LPS space to test.\n * @returns A boolean value.\n */\nexport default function pointInEllipse(\n  ellipse: Ellipse,\n  pointLPS: Types.Point3\n): boolean {\n  const { center: circleCenterWorld, xRadius, yRadius, zRadius } = ellipse;\n  const [x, y, z] = pointLPS;\n  const [x0, y0, z0] = circleCenterWorld;\n\n  let inside = 0;\n  if (xRadius !== 0) {\n    inside += ((x - x0) * (x - x0)) / (xRadius * xRadius);\n  }\n\n  if (yRadius !== 0) {\n    inside += ((y - y0) * (y - y0)) / (yRadius * yRadius);\n  }\n\n  if (zRadius !== 0) {\n    inside += ((z - z0) * (z - z0)) / (zRadius * zRadius);\n  }\n\n  return inside <= 1;\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\n\nimport {\n  getCanvasEllipseCorners,\n  pointInEllipse,\n} from '../../../utilities/math/ellipse';\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInShapeCallback } from '../../../utilities';\nimport isWithinThreshold from './utils/isWithinThreshold';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype OperationData = {\n  segmentationId: string;\n  imageVolume: Types.IImageVolume;\n  points: any; // Todo:fix\n  volume: Types.IImageVolume;\n  segmentIndex: number;\n  segmentsLocked: number[];\n  viewPlaneNormal: number[];\n  viewUp: number[];\n  strategySpecificConfiguration: any;\n  constraintFn: () => boolean;\n};\n\nfunction fillCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  threshold = false\n): void {\n  const {\n    volume: segmentationVolume,\n    imageVolume,\n    points,\n    segmentsLocked,\n    segmentIndex,\n    segmentationId,\n    strategySpecificConfiguration,\n  } = operationData;\n  const { imageData, dimensions } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n  const { viewport } = enabledElement;\n\n  // Average the points to get the center of the ellipse\n  const center = vec3.fromValues(0, 0, 0);\n  points.forEach((point) => {\n    vec3.add(center, center, point);\n  });\n  vec3.scale(center, center, 1 / points.length);\n\n  const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n  // 1. From the drawn tool: Get the ellipse (circle) topLeft and bottomRight\n  // corners in canvas coordinates\n  const [topLeftCanvas, bottomRightCanvas] =\n    getCanvasEllipseCorners(canvasCoordinates);\n\n  // 2. Find the extent of the ellipse (circle) in IJK index space of the image\n  const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n  const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n\n  const ellipsoidCornersIJK = [\n    <Types.Point3>transformWorldToIndex(imageData, topLeftWorld),\n    <Types.Point3>transformWorldToIndex(imageData, bottomRightWorld),\n  ];\n\n  const boundsIJK = getBoundingBoxAroundShape(ellipsoidCornersIJK, dimensions);\n\n  // using circle as a form of ellipse\n  const ellipseObj = {\n    center: center as Types.Point3,\n    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n  };\n\n  const modifiedSlicesToUse = new Set() as Set<number>;\n\n  let callback;\n\n  if (threshold) {\n    callback = ({ value, index, pointIJK }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n\n      if (\n        isWithinThreshold(index, imageVolume, strategySpecificConfiguration)\n      ) {\n        scalarData[index] = segmentIndex;\n        //Todo: I don't think this will always be index 2 in streamingImageVolume?\n        modifiedSlicesToUse.add(pointIJK[2]);\n      }\n    };\n  } else {\n    callback = ({ value, index, pointIJK }) => {\n      if (segmentsLocked.includes(value)) {\n        return;\n      }\n      scalarData[index] = segmentIndex;\n      //Todo: I don't think this will always be index 2 in streamingImageVolume?\n      modifiedSlicesToUse.add(pointIJK[2]);\n    };\n  }\n\n  pointInShapeCallback(\n    imageData,\n    (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS),\n    callback,\n    boundsIJK\n  );\n\n  const arrayOfSlices: number[] = Array.from(modifiedSlicesToUse);\n\n  triggerSegmentationDataModified(segmentationId, arrayOfSlices);\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function fillInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillCircle(enabledElement, operationData, false);\n}\n\n/**\n * Fill inside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels inside the defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function thresholdInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  const { volume, imageVolume } = operationData;\n\n  if (\n    !csUtils.isEqual(volume.dimensions, imageVolume.dimensions) ||\n    !csUtils.isEqual(volume.direction, imageVolume.direction)\n  ) {\n    throw new Error(\n      'Only source data the same dimensions/size/orientation as the segmentation currently supported.'\n    );\n  }\n\n  fillCircle(enabledElement, operationData, true);\n}\n\n/**\n * Fill outside the circular region segment inside the segmentation defined by the operationData.\n * It fills the segmentation pixels outside the  defined circle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function fillOutsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  throw new Error('Not yet implemented');\n}\n","import type { Types } from '@cornerstonejs/core';\n\nimport { fillInsideCircle } from './fillCircle';\n\ntype OperationData = {\n  segmentationId: string;\n  imageVolume: Types.IImageVolume;\n  points: any; // Todo:fix\n  volume: Types.IImageVolume;\n  segmentIndex: number;\n  segmentsLocked: number[];\n  viewPlaneNormal: number[];\n  viewUp: number[];\n  strategySpecificConfiguration: any;\n  constraintFn: () => boolean;\n};\n\nexport function eraseInsideCircle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  // Take the arguments and set the segmentIndex to 0,\n  // Then use existing fillInsideCircle functionality.\n  const eraseOperationData = {\n    ...operationData,\n    segmentIndex: 0,\n  };\n\n  fillInsideCircle(enabledElement, eraseOperationData);\n}\n","import { ToolGroupSpecificRepresentation } from '../../types/SegmentationStateTypes';\nimport { getDefaultSegmentationStateManager } from './segmentationState';\nimport { triggerSegmentationRepresentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the active segmentation representation for the tool group with\n * the given toolGroupId.\n * @param toolGroupId - The Id of the tool group\n * @returns The active segmentation representation for the tool group.\n */\nfunction getActiveSegmentationRepresentation(\n  toolGroupId: string\n): ToolGroupSpecificRepresentation {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  const toolGroupSegmentationRepresentations =\n    segmentationStateManager.getSegmentationRepresentations(toolGroupId);\n\n  if (!toolGroupSegmentationRepresentations) {\n    return;\n  }\n\n  const activeRepresentation = toolGroupSegmentationRepresentations.find(\n    (representation) => representation.active\n  );\n\n  return activeRepresentation;\n}\n\n/**\n * Set the active segmentation for the given tool group for all its viewports\n *\n * @param toolGroupId - The Id of the tool group to set the active\n * segmentation for.\n * @param segmentationRepresentationUID - The id of the segmentation representation to set as\n * active.\n */\nfunction setActiveSegmentationRepresentation(\n  toolGroupId: string,\n  segmentationRepresentationUID: string\n): void {\n  const segmentationStateManager = getDefaultSegmentationStateManager();\n\n  segmentationStateManager.setActiveSegmentationRepresentation(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  // get\n  getActiveSegmentationRepresentation,\n  // set\n  setActiveSegmentationRepresentation,\n};\n","import { getActiveSegmentationRepresentation } from './activeSegmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Get the locked status for a segment index in a segmentation\n * @param segmentationId - The id of the segmentation that the segment\n * belongs to.\n * @param segmentIndex - The index of the segment\n * @returns A boolean value indicating whether the segment is locked or not.\n */\nfunction isSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number\n): boolean {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return segmentsLocked.has(segmentIndex);\n}\n\n/**\n * Set the locked status of a segment index in a segmentation\n * @param segmentationId - The id of the segmentation whose segment\n * index is being modified.\n * @param segmentIndex - The index of the segment to lock/unlock.\n */\nfunction setSegmentIndexLocked(\n  segmentationId: string,\n  segmentIndex: number,\n  locked = true\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n\n  if (locked) {\n    segmentsLocked.add(segmentIndex);\n  } else {\n    segmentsLocked.delete(segmentIndex);\n  }\n\n  triggerSegmentationModified(segmentationId);\n}\n\n/**\n * Get the locked segments for a segmentation\n * @param segmentationId - The id of the segmentation to get locked\n * segments for.\n * @returns An array of locked segment indices.\n */\nfunction getLockedSegments(segmentationId: string): number[] | [] {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (!segmentation) {\n    throw new Error(`No segmentation state found for ${segmentationId}`);\n  }\n\n  const { segmentsLocked } = segmentation;\n  return Array.from(segmentsLocked);\n}\n\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegments };\n","import { getSegmentation } from './segmentationState';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\n\n/**\n * Set the active segment index for a segmentation Id. It fires a global state\n * modified event.\n *\n * @triggers SEGMENTATION_MODIFIED\n * @param segmentationId - The id of the segmentation that the segment belongs to.\n * @param segmentIndex - The index of the segment to be activated.\n */\nfunction setActiveSegmentIndex(\n  segmentationId: string,\n  segmentIndex: number\n): void {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation?.activeSegmentIndex !== segmentIndex) {\n    segmentation.activeSegmentIndex = segmentIndex;\n\n    triggerSegmentationModified(segmentationId);\n  }\n}\n\n/**\n * Get the active segment index for a segmentation in the global state\n * @param segmentationId - The id of the segmentation to get the active segment index from.\n * @returns The active segment index for the given segmentation.\n */\nfunction getActiveSegmentIndex(segmentationId: string): number | undefined {\n  const segmentation = getSegmentation(segmentationId);\n\n  if (segmentation) {\n    return segmentation.activeSegmentIndex;\n  }\n}\n\nexport { getActiveSegmentIndex, setActiveSegmentIndex };\n","import { utilities } from '@cornerstonejs/core';\nimport * as SegmentationState from '../../../stateManagement/segmentation/segmentationState';\nimport { Color } from '../../../types/SegmentationStateTypes';\nimport { ColorLUT } from '../../../types/SegmentationStateTypes';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nimport { SegmentationRepresentations } from '../../../enums';\n\n/**\n * addColorLUT - Adds a new color LUT to the state at the given colorLUTIndex.\n * If no colorLUT is provided, a new color LUT is generated.\n *\n * @param colorLUTIndex - the index of the colorLUT in the state\n * @param colorLUT - An array of The colorLUT to set.\n * @returns\n */\nfunction addColorLUT(colorLUT: ColorLUT, colorLUTIndex: number): void {\n  if (!colorLUT) {\n    throw new Error('addColorLUT: colorLUT is required');\n  }\n\n  // Append the \"zero\" (no label) color to the front of the LUT, if necessary.\n  if (!utilities.isEqual(colorLUT[0], [0, 0, 0, 0])) {\n    console.warn(\n      'addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it'\n    );\n    colorLUT.unshift([0, 0, 0, 0]);\n  }\n\n  SegmentationState.addColorLUT(colorLUT, colorLUTIndex);\n}\n\n/**\n * It sets the toolGroup's segmentationRepresentation to use the provided\n * colorLUT at the given colorLUTIndex.\n * @param toolGroupId - the id of the toolGroup that renders the representation\n * @param segmentationRepresentationUID - the representationUID for the segmentation\n * @param colorLUTIndex - the index of the colorLUT to use\n */\nfunction setColorLUT(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  colorLUTIndex: number\n): void {\n  const segRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segRepresentation) {\n    throw new Error(\n      `setColorLUT: could not find segmentation representation with UID ${segmentationRepresentationUID}`\n    );\n  }\n\n  if (!SegmentationState.getColorLUT(colorLUTIndex)) {\n    throw new Error(\n      `setColorLUT: could not find colorLUT with index ${colorLUTIndex}`\n    );\n  }\n\n  segRepresentation.colorLUTIndex = colorLUTIndex;\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\n/**\n * Given a tool group UID, a segmentation representationUID, and a segment index, return the\n * color for that segment. It can be used for segmentation tools that need to\n * display the color of their annotation.\n *\n * @param toolGroupId - The Id of the tool group that owns the segmentation representation.\n * @param segmentationRepresentationUID - The uid of the segmentation representation\n * @param segmentIndex - The index of the segment in the segmentation\n * @returns A color.\n */\nfunction getColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number\n): Color {\n  const segmentationRepresentation =\n    SegmentationState.getSegmentationRepresentationByUID(\n      toolGroupId,\n      segmentationRepresentationUID\n    );\n\n  if (!segmentationRepresentation) {\n    throw new Error(\n      `segmentation representation with UID ${segmentationRepresentationUID} does not exist for tool group ${toolGroupId}`\n    );\n  }\n\n  const { colorLUTIndex } = segmentationRepresentation;\n\n  // get colorLUT\n  const colorLUT = SegmentationState.getColorLUT(colorLUTIndex);\n  return colorLUT[segmentIndex];\n}\n\nfunction setColorForSegmentIndex(\n  toolGroupId: string,\n  segmentationRepresentationUID: string,\n  segmentIndex: number,\n  color: Color\n): void {\n  // Get the reference to the color in the colorLUT.\n  const colorReference = getColorForSegmentIndex(\n    toolGroupId,\n    segmentationRepresentationUID,\n    segmentIndex\n  );\n\n  // Modify the values by reference\n  for (let i = 0; i < color.length; i++) {\n    colorReference[i] = color[i];\n  }\n\n  triggerSegmentationRepresentationModified(\n    toolGroupId,\n    segmentationRepresentationUID\n  );\n}\n\nexport {\n  getColorForSegmentIndex,\n  addColorLUT,\n  setColorLUT,\n  setColorForSegmentIndex,\n};\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport type { Types } from '@cornerstonejs/core';\nimport type {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BaseTool } from '../base';\nimport {\n  fillInsideSphere,\n  thresholdInsideSphere,\n} from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport {\n  thresholdInsideCircle,\n  fillInsideCircle,\n} from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events, ToolModes } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  state as segmentationState,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\n/**\n * @public\n */\nclass BrushTool extends BaseTool {\n  static toolName;\n  private _editData: {\n    segmentation: Types.IImageVolume;\n    imageVolume: Types.IImageVolume; //\n    segmentsLocked: number[]; //\n  } | null;\n  private _hoverData?: {\n    brushCursor: any;\n    segmentationId: string;\n    segmentIndex: number;\n    segmentationRepresentationUID: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    centerCanvas?: Array<number>;\n  };\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE_CIRCLE: fillInsideCircle,\n          ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n          FILL_INSIDE_SPHERE: fillInsideSphere,\n          ERASE_INSIDE_SPHERE: eraseInsideSphere,\n          THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n          THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n        },\n        strategySpecificConfiguration: {\n          THRESHOLD_INSIDE_CIRCLE: {\n            threshold: [-150, -70], // E.g. CT Fat // Only used during threshold strategies.\n          },\n        },\n        defaultStrategy: 'FILL_INSIDE_CIRCLE',\n        activeStrategy: 'FILL_INSIDE_CIRCLE',\n        brushSize: 25,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolPassive = () => {\n    this.disableCursor();\n  };\n\n  onSetToolEnabled = () => {\n    this.disableCursor();\n  };\n\n  onSetToolDisabled = () => {\n    this.disableCursor();\n  };\n\n  private disableCursor() {\n    this._hoverData = undefined;\n  }\n\n  preMouseDownCallback = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): boolean => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const { representationData } =\n      segmentationState.getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with this tool?\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n\n    const actors = viewport.getActors();\n\n    // Note: For tools that need the source data. Assumed to use\n    // First volume actor for now.\n    const firstVolumeActorUID = actors[0].uid;\n    const imageVolume = cache.getVolume(firstVolumeActorUID);\n\n    const viewportIdsToRender = [viewport.id];\n\n    this._editData = {\n      segmentation,\n      imageVolume,\n      segmentsLocked,\n    };\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    return true;\n  };\n\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): void => {\n    if (this.mode === ToolModes.Active) {\n      this.updateCursor(evt);\n    }\n  };\n\n  private updateCursor(evt: EventTypes.InteractionEventType) {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { currentPoints } = eventData;\n    const centerCanvas = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      console.warn(\n        'No active segmentation detected, create one before using the brush tool'\n      );\n      return;\n    }\n\n    const { segmentationRepresentationUID, segmentationId } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const viewportIdsToRender = [viewport.id];\n\n    // Center of circle in canvas Coordinates\n\n    const brushCursor = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {},\n    };\n\n    this._hoverData = {\n      brushCursor,\n      centerCanvas,\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      segmentColor,\n      viewportIdsToRender,\n    };\n\n    this._calculateCursor(element, centerCanvas);\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n  }\n\n  private _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { imageVolume, segmentation, segmentsLocked } = this._editData;\n\n    this.updateCursor(evt);\n\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n      viewportIdsToRender,\n    } = this._hoverData;\n\n    const { data } = brushCursor;\n    const { viewPlaneNormal, viewUp } = brushCursor.metadata;\n\n    triggerAnnotationRenderForViewportUIDs(\n      renderingEngine,\n      viewportIdsToRender\n    );\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation, // todo: just pass the segmentationId instead\n      imageVolume,\n      segmentIndex,\n      segmentsLocked,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  private _calculateCursor(element, centerCanvas) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n    const camera = viewport.getCamera();\n    const { brushSize } = this.configuration;\n\n    const viewUp = vec3.fromValues(\n      camera.viewUp[0],\n      camera.viewUp[1],\n      camera.viewUp[2]\n    );\n    const viewPlaneNormal = vec3.fromValues(\n      camera.viewPlaneNormal[0],\n      camera.viewPlaneNormal[1],\n      camera.viewPlaneNormal[2]\n    );\n    const viewRight = vec3.create();\n\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n\n    // in the world coordinate system, the brushSize is the radius of the circle\n    // in mm\n    const centerCursorInWorld: Types.Point3 = canvasToWorld([\n      centerCanvas[0],\n      centerCanvas[1],\n    ]);\n\n    const bottomCursorInWorld = vec3.create();\n    const topCursorInWorld = vec3.create();\n    const leftCursorInWorld = vec3.create();\n    const rightCursorInWorld = vec3.create();\n\n    // Calculate the bottom and top points of the circle in world coordinates\n    for (let i = 0; i <= 2; i++) {\n      bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n      topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n      leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n      rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n    }\n\n    const { brushCursor } = this._hoverData;\n    const { data } = brushCursor;\n\n    if (data.handles === undefined) {\n      data.handles = {};\n    }\n\n    data.handles.points = [\n      bottomCursorInWorld,\n      topCursorInWorld,\n      leftCursorInWorld,\n      rightCursorInWorld,\n    ];\n\n    data.invalidated = false;\n  }\n\n  private _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { imageVolume, segmentation, segmentsLocked } = this._editData;\n    const {\n      segmentIndex,\n      segmentationId,\n      segmentationRepresentationUID,\n      brushCursor,\n    } = this._hoverData;\n\n    const { data } = brushCursor;\n    const { viewPlaneNormal, viewUp } = brushCursor.metadata;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this._editData = null;\n    this.updateCursor(evt);\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation,\n      imageVolume,\n      segmentIndex,\n      segmentsLocked,\n      viewPlaneNormal,\n      toolGroupId: this.toolGroupId,\n      segmentationId,\n      segmentationRepresentationUID,\n      viewUp,\n      strategySpecificConfiguration:\n        this.configuration.strategySpecificConfiguration,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  private _activateDraw = (element: HTMLDivElement): void => {\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  private _deactivateDraw = (element: HTMLDivElement): void => {\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n  };\n\n  public invalidateBrushCursor() {\n    if (this._hoverData !== undefined) {\n      const { data } = this._hoverData.brushCursor;\n\n      data.invalidated = true;\n    }\n  }\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): void {\n    if (!this._hoverData) {\n      return;\n    }\n\n    const { viewport } = enabledElement;\n\n    const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return;\n    }\n\n    const brushCursor = this._hoverData.brushCursor;\n\n    if (brushCursor.data.invalidated === true) {\n      const { centerCanvas } = this._hoverData;\n      const { element } = viewport;\n\n      // This can be set true when changing the brush size programmatically\n      // whilst the cursor is being rendered.\n      this._calculateCursor(element, centerCanvas);\n    }\n\n    const toolMetadata = brushCursor.metadata;\n    const annotationUID = toolMetadata.brushCursorUID;\n\n    const data = brushCursor.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n  }\n}\n\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { Types } from '@cornerstonejs/core';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport getBoundingBoxAroundShape from '../boundingBox/getBoundingBoxAroundShape';\n\nexport type ThresholdInformation = {\n  volume: Types.IImageVolume;\n  lower: number;\n  upper: number;\n};\n\nexport default function getBrushToolInstances(\n  toolGroupId: string,\n  toolName?: string\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  if (toolName && toolInstances[toolName]) {\n    return [toolInstances[toolName]];\n  }\n\n  // For each tool that has BrushTool as base class, set the brush size.\n  const brushBasedToolInstances = Object.values(toolInstances).filter(\n    (toolInstance) => toolInstance instanceof BrushTool\n  ) as BrushTool[];\n\n  return brushBasedToolInstances;\n}\n\nconst equalsCheck = (a, b) => {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\n/**\n * Given the center of a voxel in world coordinates, calculate the voxel\n * corners in world coords to calculate the voxel overlap in another volume\n */\nexport function getVoxelOverlap(\n  imageData,\n  dimensions,\n  voxelSpacing,\n  voxelCenter\n) {\n  const voxelCornersWorld = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 2; k++) {\n        const point = [...voxelCenter]; // Create a new point from voxelCenter\n        point[0] = point[0] + ((i * 2 - 1) * voxelSpacing[0]) / 2;\n        point[1] = point[1] + ((j * 2 - 1) * voxelSpacing[1]) / 2;\n        point[2] = point[2] + ((k * 2 - 1) * voxelSpacing[2]) / 2;\n        voxelCornersWorld.push(point);\n      }\n    }\n  }\n  const voxelCornersIJK = voxelCornersWorld.map(\n    (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n  );\n  const overlapBounds = getBoundingBoxAroundShape(voxelCornersIJK, dimensions);\n\n  return overlapBounds;\n}\n\n/**\n * Prepare a list of volume information objects for callback functions\n */\nexport function processVolumes(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[]\n) {\n  const { spacing: segmentationSpacing } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const volumeInfoList = [];\n  let baseVolumeIdx = 0;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    const { imageData, spacing, dimensions } =\n      thresholdVolumeInformation[i].volume;\n\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    // discover the index of the volume the segmentation data is based on\n    if (\n      volumeSize === scalarData.length &&\n      equalsCheck(spacing, segmentationSpacing)\n    ) {\n      baseVolumeIdx = i;\n    }\n\n    // prepare information used in callback functions\n    const referenceValues = imageData.getPointData().getScalars().getData();\n    const lower = thresholdVolumeInformation[i].lower;\n    const upper = thresholdVolumeInformation[i].upper;\n\n    volumeInfoList.push({\n      imageData,\n      referenceValues,\n      lower,\n      upper,\n      spacing,\n      dimensions,\n      volumeSize,\n    });\n  }\n\n  return {\n    volumeInfoList,\n    baseVolumeIdx,\n  };\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { BoundsIJK } from '../../types';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\nexport type ThresholdRangeOptions = {\n  overwrite: boolean;\n  boundsIJK: BoundsIJK;\n  overlapType?: number;\n};\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param options - the options for thresholding\n * As there is a chance the volumes might have different dimensions and spacing,\n * could be the case of no 1 to 1 mapping. So we need to work with the idea of\n * voxel overlaps (1 to many mappings). We consider all intersections valid, to\n * avoid the complexity to calculate a minimum voxel intersection percentage.\n * This function, given a voxel center and spacing, calculates the overlap of\n * the voxel with another volume and range check the voxels in the overlap.\n * Three situations can occur: all voxels pass the range check, some voxels pass\n * or none voxels pass. The overlapType parameter indicates if the user requires\n * all voxels pass (overlapType = 1) or any voxel pass (overlapType = 0)\n *\n * @returns segmented volume\n */\nfunction thresholdVolumeByRange(\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdRangeOptions\n): Types.IImageVolume {\n  const { imageData: segmentationImageData } = segmentationVolume;\n  const scalarData = segmentationVolume.getScalarData();\n\n  const { overwrite, boundsIJK } = options;\n  const overlapType = options?.overlapType || 0;\n\n  // set the segmentation to all zeros\n  if (overwrite) {\n    for (let i = 0; i < scalarData.length; i++) {\n      scalarData[i] = 0;\n    }\n  }\n\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  // global variables used in callbackOverlap function\n  let overlaps, total, range;\n\n  const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n    /**\n     * This callback function will test all overlaps between a voxel in base\n     * volume (the reference for segmentation volume creation) and voxels in other\n     * volumes.\n     */\n    const callbackOverlap = ({ value }) => {\n      total = total + 1;\n      if (value >= range.lower && value <= range.upper) {\n        overlaps = overlaps + 1;\n      }\n    };\n\n    const { imageData, dimensions, lower, upper } = volumeInfo;\n\n    const overlapBounds = getVoxelOverlap(\n      imageData,\n      dimensions,\n      voxelSpacing,\n      voxelCenter\n    );\n\n    // reset global variables and setting the range check\n    total = 0;\n    overlaps = 0;\n    range = { lower, upper };\n\n    let overlapTest = false;\n\n    // check all voxel overlaps\n    pointInShapeCallback(imageData, () => true, callbackOverlap, overlapBounds);\n\n    if (overlapType === 0) {\n      overlapTest = overlaps > 0; // any voxel overlap is accepted\n    } else if (overlapType == 1) {\n      overlapTest = overlaps === total; // require all voxel overlaps\n    }\n    return overlapTest;\n  };\n\n  // range checks a voxel in a volume with same dimension as the segmentation\n  const testRange = (volumeInfo, pointIJK) => {\n    const { imageData, referenceValues, lower, upper } = volumeInfo;\n    const offset = imageData.computeOffsetIndex(pointIJK);\n\n    const value = referenceValues[offset];\n    if (value <= lower || value >= upper) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  /**\n   * This callback function will test all overlaps between a voxel in base\n   * volume (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   */\n  const callback = ({ index, pointIJK, pointLPS }) => {\n    let insert = volumeInfoList.length > 0;\n    for (let i = 0; i < volumeInfoList.length; i++) {\n      // if volume has the same size as segmentation volume, just range check\n      if (volumeInfoList[i].volumeSize === scalarData.length) {\n        insert = testRange(volumeInfoList[i], pointIJK);\n      } else {\n        // if not, need to calculate overlaps\n        insert = testOverlapRange(\n          volumeInfoList[i],\n          volumeInfoList[baseVolumeIdx].spacing,\n          pointLPS\n        );\n      }\n      if (!insert) {\n        break;\n      }\n    }\n\n    // Todo: make the segmentIndex a parameter\n    if (insert) {\n      scalarData[index] = 1;\n    }\n  };\n\n  pointInShapeCallback(segmentationImageData, () => true, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nexport default thresholdVolumeByRange;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Given an array of viewports, returns a list of viewports that are viewing a\n * world space with the given `FrameOfReferenceUID`.\n *\n * @param viewports - An array of viewports.\n * @param FrameOfReferenceUID - The UID defining a particular world space/Frame Of Reference.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithFrameOfReferenceUID(\n  viewports: Array<Types.IViewport>,\n  FrameOfReferenceUID: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n  const viewportsWithFrameOfReferenceUID = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n      viewportsWithFrameOfReferenceUID.push(viewport);\n    }\n  }\n\n  return viewportsWithFrameOfReferenceUID;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport type { IToolGroup } from '../../types';\nimport { ToolGroupManager } from '../../store';\nimport { ToolModes } from '../../enums';\n\nconst { Active, Passive, Enabled } = ToolModes;\n\n/**\n * Given an array of viewports, returns a list of viewports that have the the specified tool enabled.\n *\n * @param viewports - An array of viewports.\n * @param toolName - The name of the tool to filter on.\n *\n * @returns A filtered array of viewports.\n */\nexport default function filterViewportsWithToolEnabled(\n  viewports: Array<Types.IViewport>,\n  toolName: string\n): Array<Types.IStackViewport | Types.IVolumeViewport> {\n  const numViewports = viewports.length;\n\n  const viewportsWithToolEnabled = [];\n\n  for (let vp = 0; vp < numViewports; vp++) {\n    const viewport = viewports[vp];\n\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(\n      viewport.id,\n      viewport.renderingEngineId\n    );\n\n    if (!toolGroup) {\n      continue;\n    }\n\n    const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(\n      toolGroup,\n      toolName\n    );\n\n    if (hasTool) {\n      viewportsWithToolEnabled.push(viewport);\n    }\n  }\n\n  return viewportsWithToolEnabled;\n}\n\n/**\n * Given a toolGroup, return true if it contains the tool with the given `toolName` and it is\n * active, passive or enabled.\n *\n * @param toolGroup - The `toolGroup` to check.\n * @param toolName - The name of the tool.\n *\n * @returns True if the tool is enabled, passive or active in the `toolGroup`.\n */\nfunction _toolGroupHasActiveEnabledOrPassiveTool(\n  toolGroup: IToolGroup,\n  toolName: string\n) {\n  const { toolOptions } = toolGroup;\n  const tool = toolOptions[toolName];\n\n  if (!tool) {\n    return false;\n  }\n\n  const toolMode = tool.mode;\n\n  return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * It filters the viewports that are looking in the same view as the camera\n * It basically checks if the viewPlaneNormal is parallel to the camera viewPlaneNormal\n * @param viewports - Array of viewports to filter\n * @param camera - Camera to compare against\n * @returns - Array of viewports with the same view\n */\nexport function filterViewportsWithParallelNormals(\n  viewports,\n  camera,\n  EPS = 0.999\n) {\n  return viewports.filter((viewport) => {\n    const vpCamera = viewport.getCamera();\n\n    const isParallel =\n      Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n      EPS;\n\n    return isParallel;\n  });\n}\n\nexport default filterViewportsWithParallelNormals;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\n\n/**\n * Given a cornerstone3D enabled `element`, and a `toolName`, find all viewportIds\n * looking at the same Frame Of Reference that have the tool with the given `toolName`\n * active, passive or enabled.\n *\n * @param element - The target cornerstone3D enabled element.\n * @param toolName - The string toolName.\n * @param requireParallelNormals - If true, only return viewports that have parallel normals.\n *\n * @returns An array of viewportIds.\n */\nexport default function getViewportIdsWithToolToRender(\n  element: HTMLDivElement,\n  toolName: string,\n  requireParallelNormals = true\n): string[] {\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n\n  let viewports = renderingEngine.getViewports();\n\n  viewports = filterViewportsWithFrameOfReferenceUID(\n    viewports,\n    FrameOfReferenceUID\n  );\n  viewports = filterViewportsWithToolEnabled(viewports, toolName);\n\n  const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n\n  if (requireParallelNormals) {\n    viewports = filterViewportsWithParallelNormals(\n      viewports,\n      viewport.getCamera()\n    );\n  }\n\n  const viewportIds = viewports.map((vp) => vp.id);\n\n  return viewportIds;\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { Annotations, Annotation } from '../../types';\nimport { debug } from 'console';\n\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n\n/**\n * given some `Annotations`, and the slice defined by the camera's normal\n * direction and the spacing in the normal, filter the `Annotations` which\n * is within the slice.\n *\n * @param annotations - Annotations\n * @param camera - The camera\n * @param spacingInNormalDirection - The spacing in the normal direction\n * @returns The filtered `Annotations`.\n */\nexport default function filterAnnotationsWithinSlice(\n  annotations: Annotations,\n  camera: Types.ICamera,\n  spacingInNormalDirection: number\n): Annotations {\n  const { viewPlaneNormal } = camera;\n\n  // The reason we use parallel normals instead of actual orientation is that\n  // flipped action is done through camera API, so we can't rely on the\n  // orientation (viewplaneNormal and viewUp) since even the same image and\n  // same slice if flipped will have different orientation, but still rendering\n  // the same slice. Instead, we choose to use the parallel normals to filter\n  // the annotations and later we fine tune it with the annotation within slice\n  // logic down below.\n  const annotationsWithParallelNormals = annotations.filter(\n    (td: Annotation) => {\n      let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n      if (!annotationViewPlaneNormal) {\n        // This code is run to set the annotation view plane normal\n        // for historical data which was saved without the normal.\n        const { referencedImageId } = td.metadata;\n        const { imageOrientationPatient } = metaData.get(\n          'imagePlaneModule',\n          referencedImageId\n        );\n        const rowCosineVec = vec3.fromValues(\n          imageOrientationPatient[0],\n          imageOrientationPatient[1],\n          imageOrientationPatient[2]\n        );\n\n        const colCosineVec = vec3.fromValues(\n          imageOrientationPatient[3],\n          imageOrientationPatient[4],\n          imageOrientationPatient[5]\n        );\n\n        annotationViewPlaneNormal = vec3.create() as Types.Point3;\n\n        vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n        td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n      }\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      return annotationViewPlaneNormal && isParallel;\n    }\n  );\n\n  // No in plane annotations.\n  if (!annotationsWithParallelNormals.length) {\n    return [];\n  }\n\n  // Annotation should be within the slice, which means that it should be between\n  // camera's focalPoint +/- spacingInNormalDirection.\n\n  const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n  const { focalPoint } = camera;\n\n  const annotationsWithinSlice = [];\n\n  for (const annotation of annotationsWithParallelNormals) {\n    const data = annotation.data;\n    const point = data.handles.points[0];\n\n    if (!annotation.isVisible) {\n      continue;\n    }\n    // A = point\n    // B = focal point\n    // P = normal\n\n    // B-A dot P  => Distance in the view direction.\n    // this should be less than half the slice distance.\n\n    const dir = vec3.create();\n\n    vec3.sub(dir, focalPoint, point);\n\n    const dot = vec3.dot(dir, viewPlaneNormal);\n\n    if (Math.abs(dot) < halfSpacingInNormalDirection) {\n      annotationsWithinSlice.push(annotation);\n    }\n  }\n\n  return annotationsWithinSlice;\n}\n","import {\n  StackViewport,\n  VolumeViewport,\n  VideoViewport,\n  Types,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\n\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport { Annotations } from '../../types';\n\n/**\n * Given the viewport and the annotations, it filters the annotations array and only\n * return those annotation that should be displayed on the viewport\n * @param annotations - Annotations\n * @returns A filtered version of the annotations.\n */\nexport default function filterAnnotationsForDisplay(\n  viewport: Types.IViewport,\n  annotations: Annotations\n): Annotations {\n  if (viewport instanceof StackViewport) {\n    // 1. Get the currently displayed imageId from the StackViewport\n    const imageId = viewport.getCurrentImageId();\n\n    // 2. remove the dataLoader scheme since it might be an annotation that was\n    // created on the volumeViewport initially and has the volumeLoader scheme\n    // but shares the same imageId\n    const colonIndex = imageId.indexOf(':');\n    const imageURI = imageId.substring(colonIndex + 1);\n\n    // 3. Filter annotation in the frame of reference by the referenced image ID property\n    // Note: With the current implementation drawing on the stack (PT stack) will not\n    // show the annotation on a volume that does not share the same imageURIs (CT Volume),\n    // and we don't have a proper way to check distance either since a stack can be\n    // composed of multiple unrelated images\n    return annotations.filter((annotation) => {\n      if (!annotation.isVisible) {\n        return false;\n      }\n\n      const imageId = annotation.metadata.referencedImageId;\n\n      if (imageId === undefined) {\n        // This annotation was not drawn on a non-coplanar reformat, and such does\n        // note have a referenced imageId.\n        return false;\n      }\n\n      const colonIndex = imageId.indexOf(':');\n      const referenceImageURI = imageId.substring(colonIndex + 1);\n      return referenceImageURI === imageURI;\n    });\n  } else if (viewport instanceof VideoViewport) {\n    const frameOfReferenceUID: string = viewport.getFrameOfReferenceUID();\n\n    return annotations.filter((toolData) => {\n      return toolData.metadata.FrameOfReferenceUID === frameOfReferenceUID;\n    });\n  } else if (viewport instanceof VolumeViewport) {\n    const camera = viewport.getCamera();\n\n    const { spacingInNormalDirection } =\n      csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n    // Get data with same normal and within the same slice\n    return filterAnnotationsWithinSlice(\n      annotations,\n      camera,\n      spacingInNormalDirection\n    );\n  } else {\n    throw new Error(`Viewport Type ${viewport.type} not supported`);\n  }\n}\n","import { Annotation } from '../../../types';\nimport { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\n\n/**\n * Given a Annotation object, return the annotationStyle State that it\n * should be in based on its data\n * @param annotation - The annotation that we want to style.\n * @returns The state of the annotation whether it is Default, Highlighted, Locked, or Selected.\n */\nfunction getState(annotation?: Annotation): AnnotationStyleStates {\n  if (annotation) {\n    if (annotation.data && annotation.highlighted) {\n      return AnnotationStyleStates.Highlighted;\n    }\n    if (isAnnotationSelected(annotation.annotationUID)) {\n      return AnnotationStyleStates.Selected;\n    }\n\n    // Todo: make annotation lock api not to rely on the annotation itself\n    if (isAnnotationLocked(annotation)) {\n      return AnnotationStyleStates.Locked;\n    }\n  }\n\n  return AnnotationStyleStates.Default;\n}\n\nexport default getState;\n","import {\n  utilities,\n  getEnabledElement,\n  StackViewport,\n  cache,\n  VideoViewport,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport { Annotation, Annotations, SVGDrawingHelper } from '../../types';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationDisplayTool extends BaseTool {\n  static toolName;\n\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  /**\n   * @abstract renderAnnotation it used to draw the tool's annotation in each\n   * request animation frame\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  abstract renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  );\n\n  /**\n   * @virtual Given the element and annotations which is an array of annotation, it\n   * filters the annotations array to only include the annotation based on the viewportType.\n   * If the viewport is StackViewport, it filters based on the current imageId of the viewport,\n   * if the viewport is volumeViewport, it only returns those that are within the\n   * same slice as the current rendered slice in the volume viewport.\n   * imageId as the enabledElement.\n   * @param element - The HTML element\n   * @param annotations - The annotations to filter (array of annotation)\n   * @returns The filtered annotations\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    return filterAnnotationsForDisplay(viewport, annotations);\n  }\n\n  /**\n   * On Image Calibration, take all the annotation from the AnnotationState manager,\n   * and invalidate them to force them to be re-rendered and their stats to be recalculated.\n   * Then use the old and new imageData (non-calibrated and calibrated) to calculate the\n   * new position for the annotations in the space of the new imageData.\n   *\n   * @param evt - The calibration event\n   *\n   */\n  public onImageSpacingCalibrated = (\n    evt: Types.EventTypes.ImageSpacingCalibratedEvent\n  ) => {\n    const { element, imageId } = evt.detail;\n\n    const imageURI = utilities.imageIdToURI(imageId);\n    const annotationManager = getAnnotationManager();\n    const framesOfReference = annotationManager.getFramesOfReference();\n\n    // For each frame Of Reference\n    framesOfReference.forEach((frameOfReference) => {\n      const frameOfReferenceSpecificAnnotations =\n        annotationManager.getAnnotations(frameOfReference);\n\n      const toolSpecificAnnotations =\n        frameOfReferenceSpecificAnnotations[this.getToolName()];\n\n      if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n        return;\n      }\n\n      // for this specific tool\n      toolSpecificAnnotations.forEach((annotation) => {\n        if (!annotation.metadata?.referencedImageId) {\n          return;\n        }\n\n        // if the annotation is drawn on the same imageId\n        const referencedImageURI = utilities.imageIdToURI(\n          annotation.metadata.referencedImageId\n        );\n\n        if (referencedImageURI === imageURI) {\n          // make them invalid since the image has been calibrated so that\n          // we can update the cachedStats and also rendering\n          annotation.invalidated = true;\n          annotation.data.cachedStats = {};\n        }\n      });\n      triggerAnnotationRender(element);\n    });\n  };\n\n  protected getReferencedImageId(\n    viewport: Types.IViewport,\n    worldPos: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (\n      viewport instanceof StackViewport ||\n      viewport instanceof VideoViewport\n    ) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      const volumeId = targetId.split('volumeId:')[1];\n      const imageVolume = cache.getVolume(volumeId);\n\n      referencedImageId = utilities.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    return referencedImageId;\n  }\n\n  /**\n   * It takes the property (color, lineDash, etc.) and based on the state of the\n   * annotation (selected, highlighted etc.) it returns the appropriate value\n   * based on the central toolStyle settings for each level of specification.\n   * @param property - The name of the style property to get.\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns The value of the property.\n   */\n  public getStyle(\n    property: string,\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): unknown {\n    return getStyleProperty(\n      property,\n      specifications,\n      getState(annotation),\n      this.mode\n    );\n  }\n}\n\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import {\n  BaseVolumeViewport,\n  StackViewport,\n  cache,\n  getEnabledElement,\n  metaData,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec2 } from 'gl-matrix';\n\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  InteractionTypes,\n  ToolProps,\n  PublicToolProps,\n} from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**-q\n * Abstract class for tools which create and display annotations on the\n * cornerstone3D canvas. In addition, it provides a base class for segmentation\n * tools that require drawing an annotation before running the segmentation strategy\n * for instance threshold segmentation based on an area and a threshold.\n * Annotation tools make use of drawing utilities to draw SVG elements on the viewport.\n *\n * To create a new annotation tool, derive from this class and implement the\n * abstract methods.\n */\nabstract class AnnotationTool extends AnnotationDisplayTool {\n  static toolName;\n  // ===================================================================\n  // Abstract Methods - Must be implemented.\n  // ===================================================================\n\n  constructor(toolProps: PublicToolProps, defaultToolProps: ToolProps) {\n    super(toolProps, defaultToolProps);\n\n    if (toolProps.configuration?.getTextLines) {\n      this.configuration.getTextLines = toolProps.configuration.getTextLines;\n    }\n\n    if (toolProps.configuration?.statsCalculator) {\n      this.configuration.statsCalculator =\n        toolProps.configuration.statsCalculator;\n    }\n  }\n\n  /**\n   * @abstract addNewAnnotation Creates a new annotation based on the clicked mouse position\n   *\n   * @param evt - The normalized mouse event\n   * @param interactionType -  The interaction type used to add the annotation.\n   */\n  abstract addNewAnnotation(\n    evt: EventTypes.InteractionEventType,\n    interactionType: InteractionTypes\n  ): Annotation;\n\n  /**\n   * @abstract cancel Used to cancel the ongoing tool drawing and manipulation\n   *\n   */\n  abstract cancel(element: HTMLDivElement);\n\n  /**\n   * handleSelectedCallback Custom callback for when a handle is selected.\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The annotation selected.\n   * @param handle - The selected handle (either Types.Point3 in space for annotations, or TextBoxHandle object for text boxes).\n   * @param interactionType - The interaction type the handle was selected with.\n   */\n  abstract handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    handle: ToolHandle,\n    interactionType: InteractionTypes\n  ): void;\n\n  /**\n   * Custom callback for when an annotation is selected\n   *\n   * @param evt - The normalized mouse event\n   * @param annotation - The `Annotation` to check.\n   * @param interactionType - The interaction type used to select the tool.\n   */\n  abstract toolSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes,\n    canvasCoords?: Types.Point2\n  ): void;\n\n  /**\n   * Returns true if the provided canvas coordinate tool is near the annotation\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinate to check\n   * @param proximity - The minimum proximity to consider the point near\n   * @param interactionType - The interaction type used to select the tool.\n   *\n   * @returns boolean if the point is near.\n   */\n  abstract isPointNearTool(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number,\n    interactionType: string\n  ): boolean;\n\n  /**\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  public mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredAnnotations?: Annotations\n  ): boolean => {\n    if (!filteredAnnotations) {\n      return false;\n    }\n\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let annotationsNeedToBeRedrawn = false;\n\n    for (const annotation of filteredAnnotations) {\n      // Do not do anything if the annotation is locked or hidden.\n      if (\n        isAnnotationLocked(annotation) ||\n        !isAnnotationVisible(annotation.annotationUID)\n      ) {\n        continue;\n      }\n\n      const { data } = annotation;\n      const activateHandleIndex = data.handles\n        ? data.handles.activeHandleIndex\n        : undefined;\n\n      // Perform tool specific imagePointNearToolOrHandle to determine if the mouse\n      // is near the tool or its handles or its textBox.\n      const near = this._imagePointNearToolOrHandle(\n        element,\n        annotation,\n        canvasCoords,\n        6 // Todo: This should come from the state\n      );\n\n      const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n      const notNearToolAndMarkedActive = !near && annotation.highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !annotation.highlighted;\n        annotationsNeedToBeRedrawn = true;\n      } else if (\n        data.handles &&\n        data.handles.activeHandleIndex !== activateHandleIndex\n      ) {\n        // Active handle index has changed, re-render.\n        annotationsNeedToBeRedrawn = true;\n      }\n    }\n\n    return annotationsNeedToBeRedrawn;\n  };\n\n  /**\n   * It checks if the mouse click is near TextBoxHandle or AnnotationHandle itself, and\n   * return either it. It prioritize TextBoxHandle over AnnotationHandle. If\n   * the mouse click is not near any of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points, textBox } = data.handles;\n\n    if (textBox) {\n      const { worldBoundingBox } = textBox;\n      if (worldBoundingBox) {\n        const canvasBoundingBox = {\n          topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n          topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n          bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n          bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n        };\n\n        if (\n          canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n          canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n          canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n          canvasCoords[1] <= canvasBoundingBox.bottomRight[1]\n        ) {\n          data.handles.activeHandleIndex = null;\n          return textBox as ToolHandle;\n        }\n      }\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  }\n\n  /**\n   * It returns the style for the text box\n   * @param styleSpecifier - An object containing the specifications such as viewportId,\n   * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n   * met (hierarchy is checked from most specific to least specific which is\n   * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n   * @param annotation - The annotation for the tool that is\n   * currently active.\n   * @returns An object of the style settings for the text box.\n   */\n  public getLinkedTextBoxStyle(\n    specifications: StyleSpecifier,\n    annotation?: Annotation\n  ): Record<string, unknown> {\n    // Todo: this function can be used to set different styles for different toolMode\n    // for the textBox.\n\n    return {\n      visibility: this.getStyle(\n        'textBoxVisibility',\n        specifications,\n        annotation\n      ),\n      fontFamily: this.getStyle(\n        'textBoxFontFamily',\n        specifications,\n        annotation\n      ),\n      fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n      color: this.getStyle('textBoxColor', specifications, annotation),\n      shadow: this.getStyle('textBoxShadow', specifications, annotation),\n      background: this.getStyle(\n        'textBoxBackground',\n        specifications,\n        annotation\n      ),\n      lineWidth: this.getStyle(\n        'textBoxLinkLineWidth',\n        specifications,\n        annotation\n      ),\n      lineDash: this.getStyle(\n        'textBoxLinkLineDash',\n        specifications,\n        annotation\n      ),\n    };\n  }\n\n  /**\n   * Returns true if the viewport is scaled to SUV units\n   * @param viewport - The viewport\n   * @param targetId - The annotation targetId\n   * @param imageId - The annotation imageId\n   * @returns\n   */\n  isSuvScaled(\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    targetId: string,\n    imageId?: string\n  ): boolean {\n    if (viewport instanceof BaseVolumeViewport) {\n      const volumeId = targetId.split('volumeId:')[1];\n      const volume = cache.getVolume(volumeId);\n      return volume.scaling?.PT !== undefined;\n    } else if (viewport instanceof StackViewport) {\n      const scalingModule: Types.ScalingParameters | undefined =\n        imageId && metaData.get('scalingModule', imageId);\n      return typeof scalingModule?.suvbw === 'number';\n    } else {\n      throw new Error('Viewport is not a valid type');\n    }\n  }\n\n  /**\n   * Returns true if the `canvasCoords` are near a handle or selectable part of the tool\n   *\n   * @param element - The HTML element\n   * @param annotation - The annotation to check\n   * @param canvasCoords - The canvas coordinates to check\n   * @param proximity - The proximity to consider\n   *\n   * @returns If the point is near.\n   */\n  private _imagePointNearToolOrHandle(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean {\n    // Based on the tool instance type, check if the point is near the tool handles\n    const handleNearImagePoint = this.getHandleNearImagePoint(\n      element,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (handleNearImagePoint) {\n      return true;\n    }\n\n    // If the point is not near the handles, check if the point is near the tool\n    const toolNewImagePoint = this.isPointNearTool(\n      element,\n      annotation,\n      canvasCoords,\n      proximity,\n      'mouse'\n    );\n\n    if (toolNewImagePoint) {\n      return true;\n    }\n  }\n}\n\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { Enums } from '@cornerstonejs/core';\n\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\n\n/**\n * Extracts the length units and the type of calibration for those units\n * into the response.  The length units will typically be either mm or px\n * while the calibration type can be any of a number of different calibraiton types.\n *\n * Volumetric images have no calibration type, so are just the raw mm.\n *\n * TODO: Handle region calibration\n *\n * @param handles - used to detect if the spacing information is different\n *   between various points (eg angled ERMF or US Region).\n *   Currently unused, but needed for correct US Region handling\n * @param image - to extract the calibration from\n *        image.calibration - calibration value to extract units form\n * @returns String containing the units and type of calibration\n */\nconst getCalibratedLengthUnits = (handles, image): string => {\n  const { calibration, hasPixelSpacing } = image;\n  // Anachronistic - moving to using calibration consistently, but not completed yet\n  const units = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n  if (!calibration || !calibration.type) {\n    return units;\n  }\n  if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n    return PIXEL_UNITS;\n  }\n  // TODO - handle US regions properly\n  if (calibration.SequenceOfUltrasoundRegions) {\n    return 'US Region';\n  }\n  return `${units} ${calibration.type}`;\n};\n\nconst SQUARE = '\\xb2';\n/**\n *  Extracts the area units, including the squared sign plus calibration type.\n */\nconst getCalibratedAreaUnits = (handles, image): string => {\n  const { calibration, hasPixelSpacing } = image;\n  const units = (hasPixelSpacing ? 'mm' : PIXEL_UNITS) + SQUARE;\n  if (!calibration || !calibration.type) {\n    return units;\n  }\n  if (calibration.SequenceOfUltrasoundRegions) {\n    return 'US Region';\n  }\n  return `${units} ${calibration.type}`;\n};\n\n/**\n * Gets the scale divisor for converting from internal spacing to\n * image spacing for calibrated images.\n */\nconst getCalibratedScale = (image) => image.calibration?.scale || 1;\n\n/** Gets the aspect ratio of the screen display relative to the image\n * display in order to square up measurement values.\n * That is, suppose the spacing on the image is 1, 0.5 (x,y spacing)\n * This is displayed at 1, 1 spacing on screen, then the\n * aspect value will be 1/0.5 = 2\n */\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\n\nexport default getCalibratedLengthUnits;\n\nexport {\n  getCalibratedAreaUnits,\n  getCalibratedLengthUnits,\n  getCalibratedScale,\n  getCalibratedAspect,\n};\n","import { Types } from '@cornerstonejs/core';\n\nfunction dist2(p1: Types.Point2, p2: Types.Point2): number {\n  return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\n}\n\n/**\n * Calculates the distance-squared of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance-squared\n */\nexport default function distanceToPointSquared(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  const d2 = dist2(lineStart, lineEnd);\n\n  if (d2 === 0) {\n    return dist2(point, lineStart);\n  }\n\n  const t =\n    ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n      (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n    d2;\n\n  if (t < 0) {\n    return dist2(point, lineStart);\n  }\n  if (t > 1) {\n    return dist2(point, lineEnd);\n  }\n\n  const pt: Types.Point2 = [\n    lineStart[0] + t * (lineEnd[0] - lineStart[0]),\n    lineStart[1] + t * (lineEnd[1] - lineStart[1]),\n  ];\n\n  return dist2(point, pt);\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the distance of a point to a line\n *\n * @param lineStart - x,y coordinates of the start of the line\n * @param lineEnd - x,y coordinates of the end of the line\n * @param point - x,y of the point\n * @returns distance\n */\nexport default function distanceToPoint(\n  lineStart: Types.Point2,\n  lineEnd: Types.Point2,\n  point: Types.Point2\n): number {\n  if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n    throw Error(\n      'lineStart, lineEnd, and point should have 2 elements of [x, y]'\n    );\n  }\n\n  return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","import type { Types } from '@cornerstonejs/core';\nimport * as lineSegment from '../line';\n\ntype rectLineSegments = {\n  top: Types.Point2[];\n  right: Types.Point2[];\n  bottom: Types.Point2[];\n  left: Types.Point2[];\n};\n\n/**\n * Given a rectangle left, top, width and height, return an object containing the\n * line segments that make up the rectangle's four sides\n * @param left - The x-coordinate of the left edge of the rectangle.\n * @param top - The y-coordinate of the top edge of the rectangle.\n * @param width - The width of the rectangle.\n * @param height - The height of the rectangle.\n * @returns An object with four keys, each of which contains an array of two\n * points.\n */\nfunction rectToLineSegments(\n  left: number,\n  top: number,\n  width: number,\n  height: number\n): rectLineSegments {\n  const topLineStart: Types.Point2 = [left, top];\n  const topLineEnd: Types.Point2 = [left + width, top];\n\n  const rightLineStart: Types.Point2 = [left + width, top];\n  const rightLineEnd: Types.Point2 = [left + width, top + height];\n\n  const bottomLineStart: Types.Point2 = [left + width, top + height];\n  const bottomLineEnd: Types.Point2 = [left, top + height];\n\n  const leftLineStart: Types.Point2 = [left, top + height];\n  const leftLineEnd: Types.Point2 = [left, top];\n\n  const lineSegments = {\n    top: [topLineStart, topLineEnd],\n    right: [rightLineStart, rightLineEnd],\n    bottom: [bottomLineStart, bottomLineEnd],\n    left: [leftLineStart, leftLineEnd],\n  };\n\n  return lineSegments;\n}\n\n/**\n * Calculates distance of the point to the rectangle. It calculates the minimum\n * distance between the point and each line segment of the rectangle.\n *\n * @param rect - coordinates of the rectangle [left, top, width, height]\n * @param point - [x,y] coordinates of a point\n * @returns\n */\nexport default function distanceToPoint(\n  rect: number[],\n  point: Types.Point2\n): number {\n  if (rect.length !== 4 || point.length !== 2) {\n    throw Error(\n      'rectangle:[left, top, width, height] or point: [x,y] not defined correctly'\n    );\n  }\n\n  const [left, top, width, height] = rect;\n\n  let minDistance = 655535;\n  const lineSegments = rectToLineSegments(left, top, width, height);\n\n  Object.keys(lineSegments).forEach((segment) => {\n    const [lineStart, lineEnd] = lineSegments[segment];\n    const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  });\n\n  return minDistance;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Determine the coordinates that will place the textbox to the right of the\n * annotation.\n *\n * @param annotationCanvasPoints - The canvas points of the annotation's handles.\n * @returns - The coordinates for default placement of the textbox.\n */\nexport default function getTextBoxCoordsCanvas(\n  annotationCanvasPoints: Array<Types.Point2>\n): Types.Point2 {\n  const corners = _determineCorners(annotationCanvasPoints);\n  const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n  const textBoxCanvas = <Types.Point2>[corners.right[0], centerY];\n\n  return textBoxCanvas;\n}\n\n/**\n * Determine the handles that have the min/max x and y values.\n *\n * @param canvasPoints - The canvas points of the annotation's handles.\n * @returns - The top, left, bottom, and right handles.\n */\nfunction _determineCorners(canvasPoints: Array<Types.Point2>) {\n  const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n  const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n  const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n  const top = handlesTopToBottom[0];\n  const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n\n  return {\n    top,\n    bottom,\n    right,\n  };\n\n  function _compareX(a, b) {\n    return a[0] < b[0] ? -1 : 1;\n  }\n  function _compareY(a, b) {\n    return a[1] < b[1] ? -1 : 1;\n  }\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined\n * by a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates\n * of the rectangle defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param topLeftWorld - The first world position.\n * @param bottomRightWorld - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromCorners(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  topLeftWorld: Types.Point3,\n  bottomRightWorld: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...topLeftWorld);\n  const pos2 = vec3.fromValues(...bottomRightWorld);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import { metaData } from '@cornerstonejs/core';\n\ntype ModalityUnitOptions = {\n  isPreScaled: boolean;\n  isSuvScaled: boolean;\n};\n\nfunction getModalityUnit(\n  modality: string,\n  imageId: string,\n  options: ModalityUnitOptions\n): string {\n  if (modality === 'CT') {\n    return 'HU';\n  } else if (modality === 'PT') {\n    return _handlePTModality(imageId, options);\n  } else {\n    return '';\n  }\n}\n\nfunction _handlePTModality(imageId: string, options: ModalityUnitOptions) {\n  if (!options.isPreScaled) {\n    return 'raw';\n  }\n\n  if (options.isSuvScaled) {\n    return 'SUV';\n  }\n\n  const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n\n  // it might be possible that the referenceImageId is not the one\n  // that is being displayed. So we need to get the modality from imageId again\n  if (generalSeriesModule?.modality === 'PT') {\n    const petSeriesModule = metaData.get('petSeriesModule', imageId);\n    return petSeriesModule?.units || 'unitless';\n  }\n}\n\nexport { getModalityUnit, ModalityUnitOptions };\n","import {\n  cache,\n  StackViewport,\n  Types,\n  BaseVolumeViewport,\n} from '@cornerstonejs/core';\n\nfunction isViewportPreScaled(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  targetId: string\n): boolean {\n  if (viewport instanceof BaseVolumeViewport) {\n    const targetIdTokens = targetId.split('volumeId:');\n    const volumeId =\n      targetIdTokens.length > 1 ? targetIdTokens[1] : targetIdTokens[0];\n    const volume = cache.getVolume(volumeId);\n    return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n  } else if (viewport instanceof StackViewport) {\n    const { preScale } = viewport.getImageData() || {};\n    return !!preScale?.scaled;\n  } else {\n    throw new Error('Viewport is not a valid type');\n  }\n}\n\nexport { isViewportPreScaled };\n","import { Statistics } from '../../../types';\n\nabstract class Calculator {\n  static run: ({ value }) => void;\n  static getStatistics: () => Statistics[];\n}\n\nexport default Calculator;\n","import { Statistics } from '../../../types';\nimport Calculator from './Calculator';\n\nexport default class BasicStatsCalculator extends Calculator {\n  private static max = -Infinity;\n  private static currentMax = 0;\n  private static sum = 0;\n  private static sumSquares = 0;\n  private static squaredDiffSum = 0;\n  private static count = 0;\n\n  /**\n   * This callback is used when we verify if the point is in the annotion drawn so we can get every point\n   * in the shape to calculate the statistics\n   * @param value of the point in the shape of the annotation\n   */\n  static statsCallback = ({ value: newValue }): void => {\n    if (newValue > this.max) {\n      this.max = newValue;\n      this.currentMax = newValue;\n    }\n\n    this.count += 1;\n\n    this.sum += newValue;\n    this.sumSquares += newValue ** 2;\n    this.squaredDiffSum += Math.pow(newValue - this.sum / this.count, 2);\n  };\n\n  /**\n   * Basic function that calculates statictics for a given array of points.\n   * @param points\n   * @returns An object that contains :\n   * max : The maximum value of the array\n   * mean : mean of the array\n   * stdDev : standard deviation of the array\n   * stdDevWithSumSquare : standard deviation of the array using sum²\n   */\n\n  static getStatistics = (): Statistics[] => {\n    const mean = this.sum / this.count;\n    const stdDev = Math.sqrt(this.squaredDiffSum / this.count);\n    const stdDevWithSumSquare = Math.sqrt(\n      this.sumSquares / this.count - mean ** 2\n    );\n\n    this.max = -Infinity;\n    this.sum = 0;\n    this.sumSquares = 0;\n    this.squaredDiffSum = 0;\n    this.count = 0;\n\n    return [\n      { name: 'max', value: this.currentMax, unit: null },\n      { name: 'mean', value: mean, unit: null },\n      { name: 'stdDev', value: stdDev, unit: null },\n      { name: 'stdDevWithSumSquare', value: stdDevWithSumSquare, unit: null },\n    ];\n  };\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  ToolProps,\n  PublicToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { getModalityUnit } from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * RectangleROIAnnotation let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of a Rectangular region of interest.\n * You can use RectangleROIAnnotation in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. RectangleROI tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(RectangleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(RectangleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(RectangleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass RectangleROITool extends AnnotationTool {\n  static toolName;\n\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a RectangleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): RectangleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: RectangleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]];\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point as Types.Point2\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: RectangleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - Move the text boxes world position\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventDetail;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewPlaneNormal,\n          viewUp,\n          renderingEngine,\n          enabledElement\n        );\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-rect`;\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param data - The annotation tool-specific data.\n   * @param viewPlaneNormal - The normal vector of the camera.\n   * @param viewUp - The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const scale = getCalibratedScale(image);\n\n        const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          () => true,\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          stdDev: stats[2]?.value,\n          max: stats[0]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\n/**\n * _getTextLines - Returns the Area, mean and std deviation of the area of the\n * target volume enclosed by the rectangle.\n *\n * @param data - The annotation tool-specific data.\n * @param targetId - The volumeId of the volume to display the stats for.\n */\nfunction defaultGetTextLines(data, targetId: string): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n\n  if (mean === undefined) {\n    return;\n  }\n\n  const textLines: string[] = [];\n\n  textLines.push(`Area: ${roundNumber(area)} ${areaUnit}`);\n  textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nRectangleROITool.toolName = 'RectangleROI';\nexport default RectangleROITool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { Events } from '../../enums';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\n/**\n * This tool is exactly the RectangleROITool but only draws a rectangle on the image,\n * and by using utility functions such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. This tool, however, does not calculate the statistics\n * as RectangleROITool does.\n */\nclass RectangleROIThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const targetId = this.getTargetId(viewport);\n    let referencedImageId, volumeId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    } else {\n      volumeId = targetId.split('volumeId:')[1];\n      const imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n    // Todo: how not to store enabledElement on the annotation, segmentationModule needs the element to\n    // decide on the active segmentIndex, active segmentationIndex etc.\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n      },\n      data: {\n        label: '',\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        segmentationId: null,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * it is used to draw the RectangleROI Threshold annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngineId } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as RectangleROIThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      // Todo: This is not correct way to add the event trigger,\n      // this will trigger on all mouse hover too. Problem is that we don't\n      // have a cached stats mechanism for this tool yet?\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId: viewport.id,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n}\n\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import {\n  getEnabledElement,\n  cache,\n  StackViewport,\n  metaData,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRect as drawRectSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport { AnnotationModifiedEventDetail } from '../../types/EventTypes';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { RectangleROIStartEndThresholdAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * This tool is similar to the RectangleROIThresholdTool which\n * only draws a rectangle on the image, and by using utility functions\n * such as thresholdByRange and thresholdByROIStat it can be used to\n * create a segmentation. The only difference is that it only acts on the\n * acquisition plane and not the 3D volume, and accepts a start and end\n * slice, and renders a dashed rectangle on the image between the start and end\n * but a solid rectangle on start and end slice. Utility functions should be used\n * to modify the start and end slice.\n * // Todo: right now only the first slice has grabbable handles, need to make\n * // it so that the handles are grabbable on all slices.\n */\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        numSlicesToPropagate: 10,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStatsTool,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement it creates\n   * the edit data for the tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    let referencedImageId, imageVolume, volumeId;\n    if (viewport instanceof StackViewport) {\n      throw new Error('Stack Viewport Not implemented');\n    } else {\n      const targetId = this.getTargetId(viewport);\n      volumeId = targetId.split('volumeId:')[1];\n      imageVolume = cache.getVolume(volumeId);\n      referencedImageId = csUtils.getClosestImageId(\n        imageVolume,\n        worldPos,\n        viewPlaneNormal\n      );\n    }\n\n    if (!referencedImageId) {\n      throw new Error('This tool does not work on non-acquisition planes');\n    }\n\n    const startIndex = viewport.getCurrentImageIdIndex();\n    const spacingInNormal = csUtils.getSpacingInNormalDirection(\n      imageVolume,\n      viewPlaneNormal\n    );\n\n    // We cannot simply add numSlicesToPropagate to startIndex because\n    // the order of imageIds can be from top to bottom or bottom to top and\n    // we want to make sure it is always propagated in the direction of the\n    // view and also to make sure we don't go out of bounds.\n    const endIndex = this._getEndSliceIndex(\n      imageVolume,\n      worldPos,\n      spacingInNormal,\n      viewPlaneNormal\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        enabledElement,\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n        volumeId,\n        spacingInNormal,\n      },\n      data: {\n        label: '',\n        startSlice: startIndex,\n        endSlice: endIndex,\n        cachedStats: {\n          projectionPoints: [],\n          projectionPointsImageIds: [referencedImageId],\n        },\n        handles: {\n          // No need a textBox\n          textBox: {\n            hasMoved: false,\n            worldPosition: null,\n            worldBoundingBox: null,\n          },\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        labelmapUID: null,\n      },\n    };\n\n    // update the projection points in 3D space, since we are projecting\n    // the points to the slice plane, we need to make sure the points are\n    // computed for later export\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  // Todo: make it work for planes other than acquisition planes\n  _computeProjectionPoints(\n    annotation: RectangleROIStartEndThresholdAnnotation,\n    imageVolume: Types.IImageVolume\n  ): void {\n    const { data, metadata } = annotation;\n    const { viewPlaneNormal, spacingInNormal } = metadata;\n    const { imageData } = imageVolume;\n    const { startSlice, endSlice } = data;\n    const { points } = data.handles;\n\n    const startIJK = transformWorldToIndex(imageData, points[0]);\n\n    if (startIJK[2] !== startSlice) {\n      throw new Error('Start slice does not match');\n    }\n\n    // substitute the end slice index 2 with startIJK index 2\n    const endIJK = vec3.fromValues(startIJK[0], startIJK[1], endSlice);\n\n    const startWorld = vec3.create();\n    imageData.indexToWorldVec3(startIJK, startWorld);\n\n    const endWorld = vec3.create();\n    imageData.indexToWorldVec3(endIJK, endWorld);\n\n    // distance between start and end slice in the world coordinate\n    const distance = vec3.distance(startWorld, endWorld);\n\n    // for each point inside points, navigate in the direction of the viewPlaneNormal\n    // with amount of spacingInNormal, and calculate the next slice until we reach the distance\n    const newProjectionPoints = [];\n    for (let dist = 0; dist < distance; dist += spacingInNormal) {\n      newProjectionPoints.push(\n        points.map((point) => {\n          const newPoint = vec3.create();\n          vec3.scaleAndAdd(newPoint, point, viewPlaneNormal, dist);\n          return Array.from(newPoint);\n        })\n      );\n    }\n\n    data.cachedStats.projectionPoints = newProjectionPoints;\n\n    // Find the imageIds for the projection points\n    const projectionPointsImageIds = [];\n    for (const RectanglePoints of newProjectionPoints) {\n      const imageId = csUtils.getClosestImageId(\n        imageVolume,\n        RectanglePoints[0],\n        viewPlaneNormal\n      );\n      projectionPointsImageIds.push(imageId);\n    }\n\n    data.cachedStats.projectionPointsImageIds = projectionPointsImageIds;\n  }\n\n  _calculateCachedStatsTool(annotation, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const { cachedStats } = data;\n    const volumeId = this.getTargetId(viewport);\n    const imageVolume = cache.getVolume(volumeId.split('volumeId:')[1]);\n\n    // Todo: this shouldn't be here, this is a performance issue\n    // Since we are extending the RectangleROI class, we need to\n    // bring the logic for handle to some cachedStats calculation\n    this._computeProjectionPoints(annotation, imageVolume);\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  /**\n   * it is used to draw the rectangleROIStartEnd annotation in each\n   * request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const sliceIndex = viewport.getCurrentImageIdIndex();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[\n        i\n      ] as RectangleROIStartEndThresholdAnnotation;\n      const { annotationUID, data } = annotation;\n      const { startSlice, endSlice } = data;\n      const { points, activeHandleIndex } = data.handles;\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // range of slices to render based on the start and end slice, like\n      // np.arange\n\n      // if indexIJK is outside the start/end slice, we don't render\n      if (\n        sliceIndex < Math.min(startSlice, endSlice) ||\n        sliceIndex > Math.max(startSlice, endSlice)\n      ) {\n        continue;\n      }\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n\n      if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(annotation, enabledElement);\n      }\n\n      // if it is inside the start/end slice, but not exactly the first or\n      // last slice, we render the line in dash, but not the handles\n      let firstOrLastSlice = false;\n      if (sliceIndex === startSlice || sliceIndex === endSlice) {\n        firstOrLastSlice = true;\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null &&\n        firstOrLastSlice\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      let lineDashToUse = lineDash;\n\n      if (!firstOrLastSlice) {\n        lineDashToUse = 2;\n      }\n\n      const rectangleUID = '0';\n      drawRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash: lineDashToUse,\n          lineWidth,\n        }\n      );\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  _getEndSliceIndex(\n    imageVolume: Types.IImageVolume,\n    worldPos: Types.Point3,\n    spacingInNormal: number,\n    viewPlaneNormal: Types.Point3\n  ): number | undefined {\n    const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n\n    // get end position by moving from worldPos in the direction of viewplaneNormal\n    // with amount of numSlicesToPropagate * spacingInNormal\n    const endPos = vec3.create();\n    vec3.scaleAndAdd(\n      endPos,\n      worldPos,\n      viewPlaneNormal,\n      numSlicesToPropagate * spacingInNormal\n    );\n\n    const halfSpacingInNormalDirection = spacingInNormal / 2;\n    // Loop through imageIds of the imageVolume and find the one that is closest to endPos\n    const { imageIds } = imageVolume;\n    let imageIdIndex;\n    for (let i = 0; i < imageIds.length; i++) {\n      const imageId = imageIds[i];\n\n      const { imagePositionPatient } = metaData.get(\n        'imagePlaneModule',\n        imageId\n      );\n\n      const dir = vec3.create();\n      vec3.sub(dir, endPos, imagePositionPatient);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        imageIdIndex = i;\n      }\n    }\n\n    return imageIdIndex;\n  }\n}\n\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Uses the current bounds of the 2D rectangle and extends it in the view axis by numSlices\n * It compares min and max of each IJK to find the view axis (for axial, zMin === zMax) and\n * then calculates the extended range. It will assume the slice is relative to the\n * current slice and will add the given slices to the current max of the boundingBox.\n * @param boundsIJK - [[iMin, iMax], [jMin, jMax], [kMin, kMax]]\n * @param slices - number of slices to project before and after\n * @returns extended bounds\n */\nfunction extend2DBoundingBoxInViewAxis(\n  boundsIJK: [Types.Point2, Types.Point2, Types.Point2],\n  numSlicesToProject: number\n): [Types.Point2, Types.Point2, Types.Point2] {\n  // find which index in boundsIJK has the same first and last value\n  const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n\n  if (sliceNormalIndex === -1) {\n    throw new Error('3D bounding boxes not supported in an oblique plane');\n  }\n\n  // get the index and subtract slices from the min and add to the max\n  boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n  boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n  return boundsIJK;\n}\n\nexport default extend2DBoundingBoxInViewAxis;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport getBoundingBoxAroundShape from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\n\ntype Options = {\n  numSlicesToProject?: number;\n};\n\nfunction getBoundsIJKFromRectangleAnnotations(\n  annotations,\n  referenceVolume,\n  options = {} as Options\n) {\n  const AllBoundsIJK = [];\n  annotations.forEach((annotation) => {\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const { imageData, dimensions } = referenceVolume;\n\n    let pointsToUse = points;\n    // If the tool is a 2D tool but has projection points, use them\n    if (data.cachedStats?.projectionPoints) {\n      const { projectionPoints } = data.cachedStats;\n      pointsToUse = [].concat(...projectionPoints); // cannot use flat() because of typescript compiler right now\n    }\n\n    const rectangleCornersIJK = pointsToUse.map(\n      (world) => csUtils.transformWorldToIndex(imageData, world) as Types.Point3\n    );\n    let boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n\n    // If the tool is 2D but it is configured to project to X amount of slices\n    // Don't project the slices if projectionPoints have been used to define the extents\n    if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n      boundsIJK = extend2DBoundingBoxInViewAxis(\n        boundsIJK,\n        options.numSlicesToProject\n      );\n    }\n\n    AllBoundsIJK.push(boundsIJK);\n  });\n\n  if (AllBoundsIJK.length === 1) {\n    return AllBoundsIJK[0];\n  }\n\n  // Get the intersection of all the bounding boxes\n  // This is the bounding box that contains all the ROIs\n  const boundsIJK = AllBoundsIJK.reduce(\n    (accumulator, currentValue) => {\n      return {\n        iMin: Math.min(accumulator.iMin, currentValue.iMin),\n        jMin: Math.min(accumulator.jMin, currentValue.jMin),\n        kMin: Math.min(accumulator.kMin, currentValue.kMin),\n        iMax: Math.max(accumulator.iMax, currentValue.iMax),\n        jMax: Math.max(accumulator.jMax, currentValue.jMax),\n        kMax: Math.max(accumulator.kMax, currentValue.kMax),\n      };\n    },\n    {\n      iMin: Infinity,\n      jMin: Infinity,\n      kMin: Infinity,\n      iMax: -Infinity,\n      jMax: -Infinity,\n      kMax: -Infinity,\n    }\n  );\n\n  return boundsIJK;\n}\n\nexport default getBoundsIJKFromRectangleAnnotations;\n","import type { Types } from '@cornerstonejs/core';\nimport { state } from '../../stateManagement/annotation';\nimport {\n  RectangleROIStartEndThresholdTool,\n  RectangleROIThresholdTool,\n} from '../../tools';\n\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nimport { ThresholdInformation } from './utilities';\n\nexport type ThresholdOptions = {\n  numSlicesToProject?: number; // number of slices to project before and after current slice\n  overwrite: boolean;\n  overlapType?: number; // type of the voxel overlap\n};\n\nexport type AnnotationForThresholding = {\n  data: {\n    handles: {\n      points: Types.Point3[];\n    };\n    cachedStats?: {\n      projectionPoints?: Types.Point3[][];\n    };\n  };\n};\n\n/**\n * It uses the provided rectangleROI annotations (either RectangleROIThreshold, or\n * RectangleROIStartEndThreshold) to compute an ROI that is the intersection of\n * all the annotations. Then it uses the rectangleROIThreshold utility to threshold\n * the volume.\n * @param annotationUIDs - rectangleROI annotationsUIDs to use for ROI\n * @param segmentationVolume - the segmentation volume\n * @param thresholdVolumeInformation - object array containing the volume data and range threshold values\n * @param options - options for thresholding\n * @returns\n */\nfunction rectangleROIThresholdVolumeByRange(\n  annotationUIDs: string[],\n  segmentationVolume: Types.IImageVolume,\n  thresholdVolumeInformation: ThresholdInformation[],\n  options: ThresholdOptions\n): Types.IImageVolume {\n  const annotations = annotationUIDs.map((annotationUID) => {\n    return state.getAnnotation(annotationUID);\n  });\n\n  _validateAnnotations(annotations);\n\n  let boundsIJK;\n  for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n    // make sure that the boundsIJK are generated by the correct volume\n    const volumeSize =\n      thresholdVolumeInformation[i].volume.getScalarData().length;\n    if (volumeSize === segmentationVolume.getScalarData().length || i === 0) {\n      boundsIJK = getBoundsIJKFromRectangleAnnotations(\n        annotations,\n        thresholdVolumeInformation[i].volume,\n        options\n      );\n    }\n  }\n\n  const outputSegmentationVolume = thresholdVolumeByRange(\n    segmentationVolume,\n    thresholdVolumeInformation,\n    { ...options, boundsIJK }\n  );\n\n  return outputSegmentationVolume;\n}\n\nfunction _validateAnnotations(annotations) {\n  const validToolNames = [\n    RectangleROIThresholdTool.toolName,\n    RectangleROIStartEndThresholdTool.toolName,\n  ];\n\n  for (const annotation of annotations) {\n    const name = annotation.metadata.toolName;\n    if (!validToolNames.includes(name)) {\n      throw new Error(\n        'rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations'\n      );\n    }\n  }\n}\n\nexport default rectangleROIThresholdVolumeByRange;\n","import { Types } from '@cornerstonejs/core';\nimport { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\n\n/**\n * Given a list of labelmaps (with the possibility of overlapping regions), and\n * a segmentIndex it creates a new labelmap with the same dimensions as the input labelmaps,\n * but merges them into a single labelmap for the segmentIndex. It wipes out\n * all other segment Indices. This is useful for calculating statistics regarding\n * a specific segment when there are overlapping regions between labelmap (e.g. TMTV)\n *\n * @param labelmaps - Array of labelmaps\n * @param segmentIndex - The segment index to merge\n * @returns Merged labelmap\n */\nfunction createMergedLabelmapForIndex(\n  labelmaps: Array<Types.IImageVolume>,\n  segmentIndex = 1,\n  volumeId = 'mergedLabelmap'\n): Types.IImageVolume {\n  labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n    if (\n      !csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n      !csUtils.isEqual(direction, labelmaps[0].direction) ||\n      !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n      !csUtils.isEqual(origin, labelmaps[0].origin)\n    ) {\n      throw new Error('labelmaps must have the same size and shape');\n    }\n  });\n\n  const labelmap = labelmaps[0];\n\n  const arrayType = (labelmap.getScalarData() as any).constructor;\n  const outputData = new arrayType(labelmap.getScalarData().length);\n\n  labelmaps.forEach((labelmap) => {\n    const scalarData = labelmap.getScalarData();\n    for (let i = 0; i < scalarData.length; i++) {\n      if (scalarData[i] === segmentIndex) {\n        outputData[i] = segmentIndex;\n      }\n    }\n  });\n\n  const options = {\n    scalarData: outputData,\n    metadata: labelmap.metadata,\n    spacing: labelmap.spacing,\n    origin: labelmap.origin,\n    direction: labelmap.direction,\n    dimensions: labelmap.dimensions,\n  };\n\n  const preventCache = true;\n  // Todo: following should be async\n  const mergedVolume = volumeLoader.createLocalVolume(\n    options,\n    volumeId,\n    preventCache\n  );\n\n  return mergedVolume;\n}\n\nexport default createMergedLabelmapForIndex;\n","import { isValidLabelmapConfig } from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { RepresentationConfig } from '../../types/SegmentationStateTypes';\n\n/**\n * Given a representation type and a configuration, return true if the\n * configuration is valid for that representation type\n * @param representationType - The type of segmentation representation\n * @param config - RepresentationConfig\n * @returns A boolean value.\n */\nexport default function isValidRepresentationConfig(\n  representationType: string,\n  config: RepresentationConfig\n): boolean {\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return isValidLabelmapConfig(config);\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport SegmentationRepresentation from '../../enums/SegmentationRepresentations';\nimport { Segmentation } from '../../types/SegmentationStateTypes';\n\n/**\n * It returns a configuration object for the given representation type.\n * @param representationType - The type of segmentation representation\n * @returns A representation configuration object.\n */\nexport default function getDefaultRepresentationConfig(\n  segmentation: Segmentation\n) {\n  const { type: representationType } = segmentation;\n  switch (representationType) {\n    case SegmentationRepresentation.Labelmap:\n      return getDefaultLabelmapConfig();\n    default:\n      throw new Error(`Unknown representation type: ${representationType}`);\n  }\n}\n","import { _cloneDeep } from 'lodash.clonedeep';\nimport {\n  getEnabledElementByIds,\n  volumeLoader,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Create a new 3D segmentation volume from the default imageData presented in\n * the first actor of the viewport. It looks at the metadata of the imageData\n * to determine the volume dimensions and spacing if particular options are not provided.\n *\n * @param viewportId - The Id of the viewport from which to derive the volume from.\n * @param renderingEngineId - The Id of the rendering engine the viewport belongs to.\n * @param [segmentationId] - The Id to name the generated segmentation. Autogenerated if not given.\n * @param [options] - LabelmapOptions\n * @returns A promise that resolves to the Id of the new labelmap volume.\n */\nexport default async function createLabelmapVolumeForViewport(input: {\n  viewportId: string;\n  renderingEngineId: string;\n  segmentationId?: string;\n  options?: {\n    volumeId?: string;\n    scalarData?: Float32Array | Uint8Array | Uint16Array | Int16Array;\n    targetBuffer?: {\n      type: 'Float32Array' | 'Uint8Array' | 'Uint16Array' | 'Int8Array';\n    };\n    metadata?: any;\n    dimensions?: Types.Point3;\n    spacing?: Types.Point3;\n    origin?: Types.Point3;\n    direction?: Float32Array;\n  };\n}): Promise<string> {\n  const { viewportId, renderingEngineId, options } = input;\n  let { segmentationId } = input;\n  const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n\n  if (!enabledElement) {\n    throw new Error('element disabled');\n  }\n\n  const { viewport } = enabledElement;\n  if (!(viewport instanceof VolumeViewport)) {\n    throw new Error('Segmentation only supports VolumeViewport');\n  }\n\n  const { uid } = viewport.getDefaultActor();\n\n  if (segmentationId === undefined) {\n    // Name the segmentation volume with the viewport Id\n    segmentationId = `${uid}-based-segmentation-${\n      options?.volumeId ?? csUtils.uuidv4().slice(0, 8)\n    }`;\n  }\n\n  if (options) {\n    // create a new labelmap with its own properties\n    // This allows creation of a higher resolution labelmap vs reference volume\n    const properties = _cloneDeep(options);\n    await volumeLoader.createLocalVolume(properties, segmentationId);\n  } else {\n    // create a labelmap from a reference volume\n    const { uid: volumeId } = viewport.getDefaultActor();\n    await volumeLoader.createAndCacheDerivedVolume(volumeId, {\n      volumeId: segmentationId,\n    });\n  }\n\n  return segmentationId;\n}\n","import type {\n  FloodFillResult,\n  FloodFillGetter,\n  FloodFillOptions,\n} from '../../types';\nimport { Types } from '@cornerstonejs/core';\n\n/**\n * floodFill.js - Taken from MIT OSS lib - https://github.com/tuzz/n-dimensional-flood-fill\n * Refactored to ES6.\n *\n * @param {function} getter The getter to the elements of your data structure,\n *                          e.g. getter(x,y) for a 2D interprettation of your structure.\n * @param {number[]} seed The seed for your fill. The dimensionality is infered\n *                        by the number of dimensions of the seed.\n * @param {function} [options.onFlood] An optional callback to execute when each pixel is flooded.\n *                             e.g. onFlood(x,y).\n * @param {function} [options.onBoundary] An optional callback to execute whenever a boundary is reached.\n *                                a boundary could be another segmentIndex, or the edge of your\n *                                data structure (i.e. when your getter returns undefined).\n * @param {function} [options.equals] An optional equality method for your datastructure.\n *                            Default is simply value1 = value2.\n * @param {boolean} [options.diagonals] Whether you allow flooding through diagonals. Defaults to false.\n *\n * @returns {Object}\n */\nfunction floodFill(\n  getter: FloodFillGetter,\n  seed: Types.Point2 | Types.Point3,\n  options: FloodFillOptions = {}\n): FloodFillResult {\n  const onFlood = options.onFlood;\n  const onBoundary = options.onBoundary;\n  const equals = options.equals || defaultEquals;\n  const diagonals = options.diagonals || false;\n  const startNode = get(seed);\n  const permutations = prunedPermutations();\n  const stack = [];\n  const flooded = [];\n  const visits = {};\n  const bounds = {};\n\n  stack.push({ currentArgs: seed });\n\n  while (stack.length > 0) {\n    flood(stack.pop());\n  }\n\n  return {\n    flooded,\n    boundaries: boundaries(),\n  };\n\n  function flood(job) {\n    const getArgs = job.currentArgs;\n    const prevArgs = job.previousArgs;\n\n    if (visited(getArgs)) {\n      return;\n    }\n    markAsVisited(getArgs);\n\n    if (member(getArgs)) {\n      markAsFlooded(getArgs);\n      pushAdjacent(getArgs);\n    } else {\n      markAsBoundary(prevArgs);\n    }\n  }\n\n  function visited(key) {\n    return visits[key] === true;\n  }\n\n  function markAsVisited(key) {\n    visits[key] = true;\n  }\n\n  function member(getArgs) {\n    const node = safely(get, [getArgs]);\n\n    return safely(equals, [node, startNode]);\n  }\n\n  function markAsFlooded(getArgs) {\n    flooded.push(getArgs);\n    if (onFlood) {\n      //@ts-ignore\n      onFlood(...getArgs);\n    }\n  }\n\n  function markAsBoundary(prevArgs) {\n    bounds[prevArgs] = prevArgs;\n    if (onBoundary) {\n      //@ts-ignore\n      onBoundary(...prevArgs);\n    }\n  }\n\n  function pushAdjacent(getArgs) {\n    for (let i = 0; i < permutations.length; i += 1) {\n      const perm = permutations[i];\n      const nextArgs = getArgs.slice(0);\n\n      for (let j = 0; j < getArgs.length; j += 1) {\n        nextArgs[j] += perm[j];\n      }\n\n      stack.push({\n        currentArgs: nextArgs,\n        previousArgs: getArgs,\n      });\n    }\n  }\n\n  function get(getArgs) {\n    //@ts-ignore\n    return getter(...getArgs);\n  }\n\n  function safely(f, args) {\n    try {\n      return f(...args);\n    } catch (error) {\n      return;\n    }\n  }\n\n  function prunedPermutations() {\n    const permutations = permute(seed.length);\n\n    return permutations.filter(function (perm) {\n      const count = countNonZeroes(perm);\n\n      return count !== 0 && (count === 1 || diagonals);\n    });\n  }\n\n  function permute(length) {\n    const perms = [];\n\n    const permutation = function (string) {\n      return string.split('').map(function (c) {\n        return parseInt(c, 10) - 1;\n      });\n    };\n\n    for (let i = 0; i < Math.pow(3, length); i += 1) {\n      const string = lpad(i.toString(3), '0', length);\n\n      perms.push(permutation(string));\n    }\n\n    return perms;\n  }\n\n  function boundaries() {\n    const array = [];\n\n    for (const key in bounds) {\n      if (bounds[key] !== undefined) {\n        array.unshift(bounds[key]);\n      }\n    }\n\n    return array;\n  }\n}\n\nfunction defaultEquals(a, b) {\n  return a === b;\n}\n\nfunction countNonZeroes(array) {\n  let count = 0;\n\n  for (let i = 0; i < array.length; i += 1) {\n    if (array[i] !== 0) {\n      count += 1;\n    }\n  }\n\n  return count;\n}\n\nfunction lpad(string, character, length) {\n  const array = new Array(length + 1);\n  const pad = array.join(character);\n\n  return (pad + string).slice(-length);\n}\n\nexport default floodFill;\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\n/**\n * Sets the brush size for all brush-based tools in a given tool group.\n * @param toolGroupId - The ID of the tool group to set the brush size for.\n * @param brushSize - The new brush size to set.\n * @param toolName - The name of the specific tool to set the brush size for (optional)\n * If not provided, all brush-based tools in the tool group will be affected.\n */\nexport function setBrushSizeForToolGroup(\n  toolGroupId: string,\n  brushSize: number,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  brushBasedToolInstances.forEach((tool: BrushTool) => {\n    tool.configuration.brushSize = brushSize;\n\n    // Invalidate the brush being rendered so it can update.\n    tool.invalidateBrushCursor();\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  const viewportsInfoArray = Object.keys(viewportsInfo).map(\n    (key) => viewportsInfo[key]\n  );\n\n  if (!viewportsInfoArray.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfoArray[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\n/**\n * Gets the brush size for the first brush-based tool instance in a given tool group.\n * @param toolGroupId - The ID of the tool group to get the brush size for.\n * @param toolName - The name of the specific tool to get the brush size for (Optional)\n * If not provided, the first brush-based tool instance in the tool group will be used.\n * @returns The brush size of the selected tool instance, or undefined if no brush-based tool instance is found.\n */\nexport function getBrushSizeForToolGroup(\n  toolGroupId: string,\n  toolName?: string\n): void {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n\n  // one is enough as they share the same brush size\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the brush sizes are the same and set via these helpers.\n  return brushToolInstance.configuration.brushSize;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport getBrushToolInstances from './utilities';\n\nexport function setBrushThresholdForToolGroup(\n  toolGroupId: string,\n  threshold: Types.Point2\n) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n\n  brushBasedToolInstances.forEach((tool) => {\n    tool.configuration.strategySpecificConfiguration.THRESHOLD_INSIDE_CIRCLE.threshold =\n      threshold;\n  });\n\n  // Trigger an annotation render for any viewports on the toolgroup\n  const viewportsInfo = toolGroup.getViewportsInfo();\n\n  if (!viewportsInfo.length) {\n    return;\n  }\n\n  const { renderingEngineId } = viewportsInfo[0];\n\n  // Use helper to get array of viewportIds, or we just end up doing this mapping\n  // ourselves here.\n  const viewportIds = toolGroup.getViewportIds();\n\n  const renderingEngine = getRenderingEngine(renderingEngineId);\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIds);\n}\n\nexport function getBrushThresholdForToolGroup(toolGroupId: string) {\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (toolGroup === undefined) {\n    return;\n  }\n\n  const toolInstances = toolGroup._toolInstances;\n\n  if (!Object.keys(toolInstances).length) {\n    return;\n  }\n\n  const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n  const brushToolInstance = brushBasedToolInstances[0];\n\n  if (!brushToolInstance) {\n    return;\n  }\n\n  // TODO -> Assumes the\n  return brushToolInstance.configuration.strategySpecificConfiguration\n    .THRESHOLD_INSIDE_CIRCLE.threshold;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { pointInShapeCallback } from '../../utilities';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  getVoxelOverlap,\n  processVolumes,\n  ThresholdInformation,\n} from './utilities';\n\n/**\n * It thresholds a segmentation volume based on a set of threshold values with\n * respect to a list of volumes and respective threshold ranges.\n * @param segmentationVolume - the segmentation volume to be modified\n * @param segmentationIndex - the index of the segmentation to modify\n * @param thresholdVolumeInformation - array of objects containing volume data\n * and a range (lower and upper values) to threshold\n * @param overlapType - indicates if the user requires all voxels pass\n * (overlapType = 1) or any voxel pass (overlapType = 0)\n * @returns\n */\nfunction thresholdSegmentationByRange(\n  segmentationVolume: Types.IImageVolume,\n  segmentationIndex: number,\n  thresholdVolumeInformation: ThresholdInformation[],\n  overlapType: number\n): Types.IImageVolume {\n  const scalarData = segmentationVolume.getScalarData();\n\n  // prepare a list of volume information objects for callback functions\n  const { baseVolumeIdx, volumeInfoList } = processVolumes(\n    segmentationVolume,\n    thresholdVolumeInformation\n  );\n\n  /**\n   * This function will test all overlaps between a voxel in base volume\n   * (the reference for segmentation volume creation) and voxels in other\n   * volumes.\n   * If the segmentation volume and the image volume are the same size,\n   * checks if the scalar data at each point is within the threshold values.\n   * If the segmentation volume and the image volume are different sizes,\n   * checks the voxel overlap\n   */\n  volumeInfoList.forEach((volumeInfo) => {\n    const { volumeSize } = volumeInfo;\n\n    if (volumeSize === scalarData.length) {\n      _handleSameSizeVolume(scalarData, segmentationIndex, volumeInfo);\n    } else {\n      _handleDifferentSizeVolume(\n        scalarData,\n        segmentationIndex,\n        volumeInfo,\n        volumeInfoList,\n        baseVolumeIdx,\n        overlapType\n      );\n    }\n  });\n\n  triggerSegmentationDataModified(segmentationVolume.volumeId);\n\n  return segmentationVolume;\n}\n\nfunction _handleDifferentSizeVolume(\n  scalarData: Types.VolumeScalarData,\n  segmentationIndex: number,\n  volumeInfo: any,\n  volumeInfoList: any,\n  baseVolumeIdx: number,\n  overlapType: number\n) {\n  const { imageData, lower, upper, dimensions } = volumeInfo;\n\n  let total, overlaps, range;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const overlapBounds = getVoxelOverlap(\n        imageData,\n        dimensions,\n        volumeInfoList[baseVolumeIdx].spacing,\n        volumeInfoList[baseVolumeIdx].imageData.getPoint(i)\n      );\n\n      const callbackOverlap = ({ value }) => {\n        total = total + 1;\n        if (value >= range.lower && value <= range.upper) {\n          overlaps = overlaps + 1;\n        }\n      };\n\n      total = 0;\n      overlaps = 0;\n      range = { lower, upper };\n      let overlapTest = false;\n\n      // check all voxel overlaps\n      pointInShapeCallback(\n        imageData,\n        () => true,\n        callbackOverlap,\n        overlapBounds\n      );\n\n      overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n      scalarData[i] = overlapTest ? segmentationIndex : 0;\n    }\n  }\n  return { total, range, overlaps };\n}\n\nfunction _handleSameSizeVolume(\n  scalarData: Types.VolumeScalarData,\n  segmentationIndex: number,\n  volumeInfo: any\n) {\n  const { referenceValues, lower, upper } = volumeInfo;\n\n  for (let i = 0; i < scalarData.length; i++) {\n    if (scalarData[i] === segmentationIndex) {\n      const value = referenceValues[i];\n      scalarData[i] = value >= lower && value <= upper ? segmentationIndex : 0;\n    }\n  }\n}\n\nexport default thresholdSegmentationByRange;\n","// Pulled from source: https://github.com/w8r/liang-barsky\n// MIT Licensed.\n\n/**\n * Fast, destructive implementation of Liang-Barsky line clipping algorithm.\n * It clips a 2D segment by a rectangle.\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n */\n\nconst EPSILON = 1e-6;\nconst INSIDE = 1;\nconst OUTSIDE = 0;\n\nfunction clipT(num, denom, c) {\n  const [tE, tL] = c;\n  if (Math.abs(denom) < EPSILON) {\n    return num < 0;\n  }\n  const t = num / denom;\n\n  if (denom > 0) {\n    if (t > tL) {\n      return 0;\n    }\n    if (t > tE) {\n      c[0] = t;\n    }\n  } else {\n    if (t < tE) {\n      return 0;\n    }\n    if (t < tL) {\n      c[1] = t;\n    }\n  }\n  return 1;\n}\n\n/**\n * @param  {Point} a\n * @param  {Point} b\n * @param  {BoundingBox} box [xmin, ymin, xmax, ymax]\n * @param  {Point?} [da]\n * @param  {Point?} [db]\n * @return {number}\n */\nexport default function clip(a, b, box, da?, db?) {\n  const [x1, y1] = a;\n  const [x2, y2] = b;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n\n  if (da === undefined || db === undefined) {\n    da = a;\n    db = b;\n  } else {\n    da[0] = a[0];\n    da[1] = a[1];\n    db[0] = b[0];\n    db[1] = b[1];\n  }\n\n  if (\n    Math.abs(dx) < EPSILON &&\n    Math.abs(dy) < EPSILON &&\n    x1 >= box[0] &&\n    x1 <= box[2] &&\n    y1 >= box[1] &&\n    y1 <= box[3]\n  ) {\n    return INSIDE;\n  }\n\n  const c = [0, 1];\n  if (\n    clipT(box[0] - x1, dx, c) &&\n    clipT(x1 - box[2], -dx, c) &&\n    clipT(box[1] - y1, dy, c) &&\n    clipT(y1 - box[3], -dy, c)\n  ) {\n    const [tE, tL] = c;\n    if (tL < 1) {\n      db[0] = x1 + tL * dx;\n      db[1] = y1 + tL * dy;\n    }\n    if (tE > 0) {\n      da[0] += tE * dx;\n      da[1] += tE * dy;\n    }\n    return INSIDE;\n  }\n  return OUTSIDE;\n}\n","import type { Types } from '@cornerstonejs/core';\n\n// Returns sign of number\nfunction sign(x: any) {\n  return typeof x === 'number'\n    ? x\n      ? x < 0\n        ? -1\n        : 1\n      : x === x\n      ? 0\n      : NaN\n    : NaN;\n}\n\n/**\n * Calculates the intersection point between two lines in the 2D plane\n *\n * @param line1Start - x,y coordinates of the start of the first line\n * @param line1End - x,y coordinates of the end of the first line\n * @param line2Start - x,y coordinates of the start of the second line\n * @param line2End - x,y coordinates of the end of the second line\n * @returns [x,y] - point x,y of the point\n */\n\nexport default function intersectLine(\n  line1Start: Types.Point2,\n  line1End: Types.Point2,\n  line2Start: Types.Point2,\n  line2End: Types.Point2\n): number[] {\n  const [x1, y1] = line1Start;\n  const [x2, y2] = line1End;\n  const [x3, y3] = line2Start;\n  const [x4, y4] = line2End;\n\n  // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n  const a1 = y2 - y1;\n  const b1 = x1 - x2;\n  const c1 = x2 * y1 - x1 * y2;\n\n  // Compute r3 and r4\n  const r3 = a1 * x3 + b1 * y3 + c1;\n  const r4 = a1 * x4 + b1 * y4 + c1;\n\n  /* Check signs of r3 and r4.  If both point 3 and point 4 lie on\n   * same side of line 1, the line segments do not intersect.\n   */\n\n  if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n    return;\n  }\n\n  // Compute a2, b2, c2\n  const a2 = y4 - y3;\n  const b2 = x3 - x4;\n  const c2 = x4 * y3 - x3 * y4;\n\n  // Compute r1 and r2\n  const r1 = a2 * x1 + b2 * y1 + c2;\n  const r2 = a2 * x2 + b2 * y2 + c2;\n\n  /* Check signs of r1 and r2.  If both point 1 and point 2 lie\n   * on same side of second line segment, the line segments do\n   * not intersect.\n   */\n\n  if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n    return;\n  }\n\n  /* Line segments intersect: compute intersection point.\n   */\n\n  const denom = a1 * b2 - a2 * b1;\n  let num;\n\n  /* The denom/2 is to get rounding instead of truncating.  It\n   * is added or subtracted to the numerator, depending upon the\n   * sign of the numerator.\n   */\n\n  num = b1 * c2 - b2 * c1;\n  const x = num / denom;\n\n  num = a2 * c1 - a1 * c2;\n  const y = num / denom;\n\n  const intersectionPoint = [x, y];\n\n  return intersectionPoint;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Orientation algoritm to determine if two lines cross.\n * Credit and details: geeksforgeeks.org/check-if-two-given-line-segments-intersect/\n */\n\nfunction getAllIntersectionsWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  let initialI;\n  let j;\n  const intersections: Types.Point2[] = [];\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      intersections.push([j, i]);\n    }\n\n    j = i;\n  }\n\n  return intersections;\n}\n\n/**\n * Returns all intersections points\n * between a line and a polyline\n */\nfunction getIntersectionCoordinatesWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2[] {\n  const result = [];\n  const polylineIndexes = getAllIntersectionsWithPolyline(\n    points,\n    p1,\n    q1,\n    closed\n  );\n\n  for (let i = 0; i < polylineIndexes.length; i++) {\n    const p2 = points[polylineIndexes[i][0]];\n    const q2 = points[polylineIndexes[i][1]];\n    const intersection = getIntersection(p1, q1, p2, q2);\n    result.push(intersection);\n  }\n  return result;\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the first value.\n */\nfunction getFirstIntersectionWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): Types.Point2 | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      return [j, i];\n    }\n\n    j = i;\n  }\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects any of the other lines in the\n * `points`, and returns the closest value.\n */\nfunction getClosestIntersectionWithPolyline(\n  points: Types.Point2[],\n  p1: Types.Point2,\n  q1: Types.Point2,\n  closed = true\n): { segment: Types.Point2; distance: number } | undefined {\n  let initialI;\n  let j;\n\n  if (closed) {\n    j = points.length - 1;\n    initialI = 0;\n  } else {\n    j = 0;\n    initialI = 1;\n  }\n\n  const intersections = [];\n\n  for (let i = initialI; i < points.length; i++) {\n    const p2 = points[j];\n    const q2 = points[i];\n\n    if (doesIntersect(p1, q1, p2, q2)) {\n      intersections.push([j, i]);\n    }\n\n    j = i;\n  }\n\n  if (intersections.length === 0) {\n    return;\n  }\n\n  // Find intersection closest to the start point\n  const distances = [];\n\n  intersections.forEach((intersection) => {\n    const intersectionPoints = [\n      points[intersection[0]],\n      points[intersection[1]],\n    ];\n\n    const midpoint = [\n      (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n      (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n    ];\n\n    distances.push(vec2.distance(<vec2>midpoint, p1));\n  });\n\n  const minDistance = Math.min(...distances);\n  const indexOfMinDistance = distances.indexOf(minDistance);\n\n  return {\n    segment: intersections[indexOfMinDistance],\n    distance: minDistance,\n  };\n}\n\n/**\n * Checks whether the line (`p1`,`q1`) intersects the line (`p2`,`q2`) via an orientation algorithm.\n */\nfunction doesIntersect(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): boolean {\n  let result = false;\n\n  const orient = [\n    orientation(p1, q1, p2),\n    orientation(p1, q1, q2),\n    orientation(p2, q2, p1),\n    orientation(p2, q2, q1),\n  ];\n\n  // General Case\n  if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n    return true;\n  }\n\n  // Special Cases\n  if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n    // If p1, q1 and p2 are colinear and p2 lies on segment p1q1\n    result = true;\n  } else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n    // If p1, q1 and p2 are colinear and q2 lies on segment p1q1\n    result = true;\n  } else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n    // If p2, q2 and p1 are colinear and p1 lies on segment p2q2\n    result = true;\n  } else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n    // If p2, q2 and q1 are colinear and q1 lies on segment p2q2\n    result = true;\n  }\n\n  return result;\n}\n\n/**\n * Checks the orientation of 3 points, returns a 0, 1 or 2 based on\n * the orientation of the points.\n */\nfunction orientation(\n  p: Types.Point2,\n  q: Types.Point2,\n  r: Types.Point2\n): number {\n  const orientationValue =\n    (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n\n  if (orientationValue === 0) {\n    return 0; // Colinear\n  }\n\n  return orientationValue > 0 ? 1 : 2;\n}\n\n/**\n * Checks if point `q` lies on the segment (`p`,`r`).\n */\nfunction onSegment(p: Types.Point2, q: Types.Point2, r: Types.Point2): boolean {\n  if (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Gets the intersection between the line (`p1`,`q1`) and the line (`p2`,`q2`)\n * http://jsfiddle.net/justin_c_rounds/Gd2S2/light/\n * https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n */\nfunction getIntersection(\n  p1: Types.Point2,\n  q1: Types.Point2,\n  p2: Types.Point2,\n  q2: Types.Point2\n): Types.Point2 {\n  const denominator =\n    (q2[1] - p2[1]) * (q1[0] - p1[0]) - (q2[0] - p2[0]) * (q1[1] - p1[1]);\n  if (denominator == 0) {\n    return;\n  }\n  let a = p1[1] - p2[1];\n  let b = p1[0] - p2[0];\n  const numerator1 = (q2[0] - p2[0]) * a - (q2[1] - p2[1]) * b;\n  const numerator2 = (q1[0] - p1[0]) * a - (q1[1] - p1[1]) * b;\n  a = numerator1 / denominator;\n  b = numerator2 / denominator;\n\n  const resultX = p1[0] + a * (q1[0] - p1[0]);\n  const resultY = p1[1] + a * (q1[1] - p1[1]);\n\n  return [resultX, resultY];\n}\n\nexport {\n  getAllIntersectionsWithPolyline,\n  getFirstIntersectionWithPolyline,\n  getClosestIntersectionWithPolyline,\n  getIntersectionCoordinatesWithPolyline,\n};\n","import { StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nconst EPSILON = 1e-3;\n\n/**\n * Gets the desired spacing for points in the polyline for the\n * `PlanarFreehandROITool` in the x and y canvas directions, as well as\n * returning these canvas directions in world space.\n *\n * @param viewport - The Cornerstone3D `StackViewport` or `VolumeViewport`.\n * @param subPixelResolution - The number to divide the image pixel spacing by\n * to get the sub pixel spacing. E.g. `10` will return spacings 10x smaller than\n * the native image spacing.\n * @returns The spacings of the X and Y directions, and the 3D directions of the\n * x and y directions.\n */\nconst getSubPixelSpacingAndXYDirections = (\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  subPixelResolution: number\n): { spacing: Types.Point2; xDir: Types.Point3; yDir: Types.Point3 } => {\n  let spacing;\n  let xDir;\n  let yDir;\n\n  if (viewport instanceof StackViewport) {\n    // Check XY directions\n    const imageData = viewport.getImageData();\n\n    xDir = imageData.direction.slice(0, 3);\n    yDir = imageData.direction.slice(3, 6);\n\n    spacing = imageData.spacing;\n  } else {\n    // Check volume directions\n    const imageData = viewport.getImageData();\n    const { direction, spacing: volumeSpacing } = imageData;\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    // Calculate size of spacing vector in normal direction\n    const iVector = direction.slice(0, 3) as Types.Point3;\n    const jVector = direction.slice(3, 6) as Types.Point3;\n    const kVector = direction.slice(6, 9) as Types.Point3;\n\n    const viewRight = vec3.create(); // Get the X direction of the viewport\n\n    vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n    const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n    const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n    const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n\n    // Get X spacing\n    let xSpacing;\n    if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n      xSpacing = volumeSpacing[0];\n      xDir = iVector;\n    } else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n      xSpacing = volumeSpacing[1];\n      xDir = jVector;\n    } else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n      xSpacing = volumeSpacing[2];\n      xDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n    const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n    const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n\n    // Get Y spacing\n    let ySpacing;\n    if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n      ySpacing = volumeSpacing[0];\n      yDir = iVector;\n    } else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n      ySpacing = volumeSpacing[1];\n      yDir = jVector;\n    } else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n      ySpacing = volumeSpacing[2];\n      yDir = kVector;\n    } else {\n      throw new Error('No support yet for oblique plane planar contours');\n    }\n\n    spacing = [xSpacing, ySpacing];\n  }\n\n  const subPixelSpacing: Types.Point2 = [\n    spacing[0] / subPixelResolution,\n    spacing[1] / subPixelResolution,\n  ];\n\n  return { spacing: subPixelSpacing, xDir, yDir };\n};\n\nexport default getSubPixelSpacingAndXYDirections;\n","import { vec2 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Returns true if points `p1` and `p2` are within `closeContourProximity`.\n */\nconst pointsAreWithinCloseContourProximity = (\n  p1: Types.Point2,\n  p2: Types.Point2,\n  closeContourProximity: number\n): boolean => {\n  return vec2.dist(p1, p2) < closeContourProximity;\n};\n\nexport default pointsAreWithinCloseContourProximity;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { PlanarFreehandROICommonData } from './planarFreehandROIInternalTypes';\n\n/**\n * Adds one or more points to the array at a resolution defined by the underlying image.\n */\nconst addCanvasPointsToArray = (\n  element: HTMLDivElement,\n  canvasPoints: Types.Point2[],\n  newCanvasPoint: Types.Point2,\n  commonData: PlanarFreehandROICommonData\n): number => {\n  const { xDir, yDir, spacing } = commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const lastWorldPos = viewport.canvasToWorld(\n    canvasPoints[canvasPoints.length - 1]\n  );\n  const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  const numPointsToAdd = Math.max(\n    Math.floor(xDist / spacing[0]),\n    Math.floor(yDist / spacing[0])\n  );\n\n  if (numPointsToAdd > 1) {\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n\n    const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n\n    const canvasDir = vec2.create();\n\n    vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n\n    vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n\n    const distPerPoint = canvasDist / numPointsToAdd;\n\n    for (let i = 1; i <= numPointsToAdd; i++) {\n      canvasPoints.push([\n        lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n        lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n      ]);\n    }\n  } else {\n    canvasPoints.push(newCanvasPoint);\n  }\n\n  return numPointsToAdd;\n};\n\nexport default addCanvasPointsToArray;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Returns `true` if the point `p` can project onto point (`p1`, `p2`), and if\n * this projected point is less than `proximity` units away.\n */\nconst pointCanProjectOnLine = (\n  p: Types.Point2,\n  p1: Types.Point2,\n  p2: Types.Point2,\n  proximity: number\n): boolean => {\n  // Perfom checks in order of computational complexity.\n  const p1p = [p[0] - p1[0], p[1] - p1[1]];\n  const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n\n  const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n\n  // Dot product needs to be positive to be a candidate for projection onto line segment.\n  if (dot < 0) {\n    return false;\n  }\n\n  const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n\n  if (p1p2Mag === 0) {\n    return false;\n  }\n\n  const projectionVectorMag = dot / p1p2Mag;\n  const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n  const projectionVector = [\n    p1p2UnitVector[0] * projectionVectorMag,\n    p1p2UnitVector[1] * projectionVectorMag,\n  ];\n  const projectionPoint = <Types.Point2>[\n    p1[0] + projectionVector[0],\n    p1[1] + projectionVector[1],\n  ];\n\n  const distance = vec2.distance(p, projectionPoint);\n\n  if (distance > proximity) {\n    // point is too far away.\n    return false;\n  }\n\n  // Check projects onto line segment.\n  if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default pointCanProjectOnLine;\n","import type { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the area of an array of `Point2` points using the shoelace algorithm.\n *\n * The units of the area are in the same units as the points are in. E.g. if\n * the points are in canvas, then the result is in canvas pixels ^2; If they are\n * in mm, then the result is in mm^2; etc.\n */\nexport default function calculateAreaOfPoints(points: Types.Point2[]): number {\n  // Shoelace algorithm.\n  const n = points.length;\n  let area = 0.0;\n  let j = n - 1;\n\n  for (let i = 0; i < n; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i; // j is previous vertex to i\n  }\n\n  // Return absolute value of half the sum (half as summing up traingles).\n  return Math.abs(area / 2.0);\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPoint(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n\n  return Math.sqrt(\n    Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2) + Math.pow(z1 - z2, 2)\n  );\n}\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n/**\n * Returns a point based on some criteria (e.g., minimum or maximum intensity) in\n * the line of sight (on the line between the passed worldPosition and camera position).\n * It iterated over the points with a step size on the line.\n *\n * @param viewport - Volume viewport\n * @param worldPos - World coordinates of the clicked location\n * @param targetVolumeId - target Volume ID in the viewport\n * @param criteriaFunction - A function that returns the point if it passes a certain\n * written logic, for instance, it can be a maxValue function that keeps the\n * records of all intensity values, and only return the point if its intensity\n * is greater than the maximum intensity of the points passed before.\n * @param stepsSize - Percentage of the spacing in the normal direction, default value\n * is 0.25 which means steps = 1/4 of the spacing in the normal direction.\n * @returns the World pos of the point that passes the criteriaFunction\n */\nexport default function getPointInLineOfSightWithCriteria(\n  viewport: Types.IVolumeViewport,\n  worldPos: Types.Point3,\n  targetVolumeId: string,\n  criteriaFunction: (intensity: number, point: Types.Point3) => Types.Point3,\n  stepSize = 0.25\n): Types.Point3 {\n  // 1. Getting the camera from the event details\n  const camera = viewport.getCamera();\n  const { position: cameraPosition } = camera;\n\n  // 2. Calculating the spacing in the normal direction, this will get\n  // used as the step size for iterating over the points in the line of sight\n  const { spacingInNormalDirection } =\n    csUtils.getTargetVolumeAndSpacingInNormalDir(\n      viewport,\n      camera,\n      targetVolumeId\n    );\n  // 2.1 Making sure, we are not missing any point\n  const step = spacingInNormalDirection * stepSize;\n\n  // 3. Getting the bounds of the viewports. Search for brightest point is\n  // limited to the visible bound\n  // Todo: this might be a problem since bounds will change to spatial bounds.\n  const bounds = viewport.getBounds();\n  const xMin = bounds[0];\n  const xMax = bounds[1];\n\n  // 5. Calculating the line, we use a parametric line definition\n  const vector = <Types.Point3>[0, 0, 0];\n\n  // 5.1 Point coordinate on the line\n  let point = <Types.Point3>[0, 0, 0];\n\n  // 5.2 Calculating the line direction, and storing in vector\n  vtkMath.subtract(worldPos, cameraPosition, vector);\n\n  let pickedPoint;\n\n  // 6. Iterating over the line from the lower bound to the upper bound, with the\n  // specified step size\n  for (let pointT = xMin; pointT <= xMax; pointT = pointT + step) {\n    // 6.1 Calculating the point x location\n    point = [pointT, 0, 0];\n    // 6.2 Calculating the point y,z location based on the line equation\n    const t = (pointT - cameraPosition[0]) / vector[0];\n    point[1] = t * vector[1] + cameraPosition[1];\n    point[2] = t * vector[2] + cameraPosition[2];\n\n    // 6.3 Checking if the points is inside the bounds\n    if (_inBounds(point, bounds)) {\n      // 6.4 Getting the intensity of the point\n      const intensity = viewport.getIntensityFromWorld(point);\n      // 6.5 Passing the intensity to the maximum value functions which decides\n      // whether the current point is of interest based on some criteria\n      const pointToPick = criteriaFunction(intensity, point);\n      if (pointToPick) {\n        pickedPoint = pointToPick;\n      }\n    }\n  }\n\n  return pickedPoint;\n}\n\n/**\n * Returns whether the point in the world is inside the bounds of the viewport\n * @param point - coordinates in the world\n * @returns boolean\n */\nconst _inBounds = function (\n  point: Types.Point3,\n  bounds: Array<number>\n): boolean {\n  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n  return (\n    point[0] > xMin &&\n    point[0] < xMax &&\n    point[1] > yMin &&\n    point[1] < yMax &&\n    point[2] > zMin &&\n    point[2] < zMax\n  );\n};\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getPointInLineOfSightWithCriteria from './getPointInLineOfSightWithCriteria';\n\nexport default {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n};\n\nexport {\n  filterAnnotationsWithinSlice,\n  getWorldWidthAndHeightFromCorners,\n  filterAnnotationsForDisplay,\n  getPointInLineOfSightWithCriteria,\n};\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Returns the orientation of the vector in the patient coordinate system.\n * @public\n *\n * @param vector - Input array\n * @returns The orientation in the patient coordinate system.\n */\nexport default function getOrientationStringLPS(vector: Types.Point3): string {\n  // Thanks to David Clunie\n  // https://sites.google.com/site/dicomnotes/\n\n  let orientation = '';\n  const orientationX = vector[0] < 0 ? 'R' : 'L';\n  const orientationY = vector[1] < 0 ? 'A' : 'P';\n  const orientationZ = vector[2] < 0 ? 'F' : 'H';\n\n  // Should probably make this a function vector3.abs\n  const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n\n  const MIN = 0.0001;\n\n  for (let i = 0; i < 3; i++) {\n    if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n      orientation += orientationX;\n      abs[0] = 0;\n    } else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n      orientation += orientationY;\n      abs[1] = 0;\n    } else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n      orientation += orientationZ;\n      abs[2] = 0;\n    } else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n      orientation += orientationX + orientationY;\n      abs[0] = 0;\n      abs[1] = 0;\n    } else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n      orientation += orientationX + orientationZ;\n      abs[0] = 0;\n      abs[2] = 0;\n    } else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n      orientation += orientationY + orientationZ;\n      abs[1] = 0;\n      abs[2] = 0;\n    } else {\n      break;\n    }\n  }\n\n  return orientation;\n}\n","/**\n * Inverts an orientation string.\n * @public\n *\n * @param orientationString - The orientation.\n * @returns The inverted orientationString.\n */\nexport default function invertOrientationStringLPS(\n  orientationString: string\n): string {\n  let inverted = orientationString.replace('H', 'f');\n\n  inverted = inverted.replace('F', 'h');\n  inverted = inverted.replace('R', 'l');\n  inverted = inverted.replace('L', 'r');\n  inverted = inverted.replace('A', 'p');\n  inverted = inverted.replace('P', 'a');\n  inverted = inverted.toUpperCase();\n\n  return inverted;\n}\n","/**\n * CINE Tool Events\n */\nenum Events {\n  CLIP_STOPPED = 'CORNERSTONE_CINE_TOOL_STOPPED',\n  CLIP_STARTED = 'CORNERSTONE_CINE_TOOL_STARTED',\n}\n\nexport default Events;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { CINETypes } from '../../types';\n\nconst state: Record<string, CINETypes.ToolData> = {};\n\nfunction addToolState(element: HTMLDivElement, data: CINETypes.ToolData): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): CINETypes.ToolData | undefined {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport {\n  utilities as csUtils,\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  cache,\n  BaseVolumeViewport,\n  Enums,\n} from '@cornerstonejs/core';\n\nimport { Types } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState } from './state';\nimport { CINETypes } from '../../types';\nimport scroll from '../scroll';\n\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\n\nconst debounced = true;\nconst loop = true;\nconst dynamicVolumesPlayingMap = new Map();\n\n/**\n * Starts playing a clip or adjusts the frame rate of an already playing clip.  framesPerSecond is\n * optional and defaults to 30 if not specified.  A negative framesPerSecond will play the clip in reverse.\n * The element must be a stack of images\n * @param element - HTML Element\n * @param framesPerSecond - Number of frames per second\n */\nfunction playClip(\n  element: HTMLDivElement,\n  playClipOptions: CINETypes.PlayClipOptions\n): void {\n  let playClipTimeouts;\n  let playClipIsTimeVarying;\n\n  if (element === undefined) {\n    throw new Error('playClip: element must not be undefined');\n  }\n\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    throw new Error(\n      'playClip: element must be a valid Cornerstone enabled element'\n    );\n  }\n\n  // 4D Cine is enabled by default\n  playClipOptions.dynamicCineEnabled =\n    playClipOptions.dynamicCineEnabled ?? true;\n\n  const { viewport } = enabledElement;\n  const volume = _getVolumeFromViewport(viewport);\n  const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n  let playClipData = getToolState(element);\n\n  const isDynamicCinePlaying =\n    playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume();\n\n  // If user is trying to play CINE for a 4D volume it first needs\n  // to stop CINE that has may be playing for any other viewport.\n  if (isDynamicCinePlaying) {\n    _stopDynamicVolumeCine(element);\n  }\n\n  if (!playClipData) {\n    playClipData = {\n      intervalId: undefined,\n      framesPerSecond: 30,\n      lastFrameTimeStamp: undefined,\n      ignoreFrameTimeVector: false,\n      usingFrameTimeVector: false,\n      frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n      speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n      reverse: playClipOptions.reverse ?? false,\n      loop: playClipOptions.loop ?? true,\n    };\n    addToolState(element, playClipData);\n  } else {\n    // Make sure the specified clip is not running before any property update.\n    // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n    // prevent stopping a 4D CINE in case it is playing on another viewport.\n    _stopClip(element, isDynamicCinePlaying);\n  }\n\n  playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n\n  // If a framesPerSecond is specified and is valid, update the playClipData now\n  if (\n    playClipOptions.framesPerSecond < 0 ||\n    playClipOptions.framesPerSecond > 0\n  ) {\n    playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n    playClipData.reverse = playClipData.framesPerSecond < 0;\n    // If framesPerSecond is given, frameTimeVector will be ignored...\n    playClipData.ignoreFrameTimeVector = true;\n  }\n\n  // Determine if frame time vector should be used instead of a fixed frame rate...\n  if (\n    playClipData.ignoreFrameTimeVector !== true &&\n    playClipData.frameTimeVector &&\n    playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n    playClipContext.frameTimeVectorEnabled\n  ) {\n    const { timeouts, isTimeVarying } = _getPlayClipTimeouts(\n      playClipData.frameTimeVector,\n      playClipData.speed\n    );\n\n    playClipTimeouts = timeouts;\n    playClipIsTimeVarying = isTimeVarying;\n  }\n\n  // This function encapsulates the frame rendering logic...\n  const playClipAction = () => {\n    const { numScrollSteps, currentStepIndex } = playClipContext;\n    let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n    const newStepIndexOutOfRange =\n      newStepIndex < 0 || newStepIndex >= numScrollSteps;\n\n    if (!loop && newStepIndexOutOfRange) {\n      // If a 3D CINE was playing it passes isDynamicCinePlaying as FALSE to\n      // prevent stopping a 4D CINE in case it is playing on another viewport.\n      _stopClip(element, isDynamicCinePlaying);\n\n      const eventDetail = { element };\n\n      triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, eventDetail);\n      return;\n    }\n\n    // Loop around if newStepIndex is out of range\n    if (newStepIndex >= numScrollSteps) {\n      newStepIndex = 0;\n    } else if (newStepIndex < 0) {\n      newStepIndex = numScrollSteps - 1;\n    }\n\n    const delta = newStepIndex - currentStepIndex;\n\n    if (delta) {\n      playClipContext.scroll(delta);\n    }\n  };\n\n  if (isDynamicCinePlaying) {\n    dynamicVolumesPlayingMap.set(volume.volumeId, element);\n  }\n\n  // If playClipTimeouts array is available, not empty and its elements are NOT uniform ...\n  // ... (at least one timeout is different from the others), use alternate setTimeout implementation\n  if (\n    playClipTimeouts &&\n    playClipTimeouts.length > 0 &&\n    playClipIsTimeVarying\n  ) {\n    playClipData.usingFrameTimeVector = true;\n    playClipData.intervalId = window.setTimeout(\n      function playClipTimeoutHandler() {\n        playClipData.intervalId = window.setTimeout(\n          playClipTimeoutHandler,\n          playClipTimeouts[playClipContext.currentStepIndex]\n        );\n        playClipAction();\n      },\n      0\n    );\n  } else {\n    // ... otherwise user setInterval implementation which is much more efficient.\n    playClipData.usingFrameTimeVector = false;\n    playClipData.intervalId = window.setInterval(\n      playClipAction,\n      1000 / Math.abs(playClipData.framesPerSecond)\n    );\n  }\n\n  const eventDetail = {\n    element,\n  };\n\n  triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\n\n/**\n * Stops an already playing clip.\n * @param element - HTML Element\n */\nfunction stopClip(element: HTMLDivElement): void {\n  _stopClip(element, true);\n}\n\nfunction _stopClip(element: HTMLDivElement, stopDynamicCine: boolean): void {\n  const enabledElement = getEnabledElement(element);\n  if (!enabledElement) {\n    return;\n  }\n  const { viewport } = enabledElement;\n  const cineToolData = getToolState(viewport.element);\n\n  if (cineToolData) {\n    _stopClipWithData(cineToolData);\n  }\n\n  if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n    _stopDynamicVolumeCine(element);\n  }\n}\n\n/**\n * [private] Stops any CINE playing for the dynamic volume loaded on this viewport\n * @param element - HTML Element\n */\nfunction _stopDynamicVolumeCine(element) {\n  const { viewport } = getEnabledElement(element);\n  const volume = _getVolumeFromViewport(viewport);\n\n  // If the current viewport has a 4D volume loaded it may be playing\n  // if it is also loaded on another viewport and user has started CINE\n  // for that one. This guarantees the other viewport will also be stopped.\n  if (volume?.isDynamicVolume()) {\n    const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n\n    dynamicVolumesPlayingMap.delete(volume.volumeId);\n\n    if (dynamicCineElement && dynamicCineElement !== element) {\n      stopClip(<HTMLDivElement>dynamicCineElement);\n    }\n  }\n}\n\n/**\n * [private] Turns a Frame Time Vector (0018,1065) array into a normalized array of timeouts. Each element\n * ... of the resulting array represents the amount of time each frame will remain on the screen.\n * @param vector - A Frame Time Vector (0018,1065) as specified in section C.7.6.5.1.2 of DICOM standard.\n * @param speed - A speed factor which will be applied to each element of the resulting array.\n * @returns An array with timeouts for each animation frame.\n */\nfunction _getPlayClipTimeouts(vector: number[], speed: number) {\n  let i;\n  let sample;\n  let delay;\n  let sum = 0;\n  const limit = vector.length;\n  const timeouts = [];\n\n  // Initialize time varying to false\n  let isTimeVarying = false;\n\n  if (typeof speed !== 'number' || speed <= 0) {\n    speed = 1;\n  }\n\n  // First element of a frame time vector must be discarded\n  for (i = 1; i < limit; i++) {\n    // eslint-disable-next-line no-bitwise\n    delay = (Number(vector[i]) / speed) | 0; // Integral part only\n    timeouts.push(delay);\n    if (i === 1) {\n      // Use first item as a sample for comparison\n      sample = delay;\n    } else if (delay !== sample) {\n      isTimeVarying = true;\n    }\n\n    sum += delay;\n  }\n\n  if (timeouts.length > 0) {\n    if (isTimeVarying) {\n      // If it's a time varying vector, make the last item an average...\n      // eslint-disable-next-line no-bitwise\n      delay = (sum / timeouts.length) | 0;\n    } else {\n      delay = timeouts[0];\n    }\n\n    timeouts.push(delay);\n  }\n\n  return { timeouts, isTimeVarying };\n}\n\n/**\n * [private] Performs the heavy lifting of stopping an ongoing animation.\n * @param element - HTML Element\n * @param playClipData - The data from playClip that needs to be stopped.\n */\nfunction _stopClipWithData(playClipData) {\n  const id = playClipData.intervalId;\n\n  if (typeof id !== 'undefined') {\n    playClipData.intervalId = undefined;\n    if (playClipData.usingFrameTimeVector) {\n      clearTimeout(id);\n    } else {\n      clearInterval(id);\n    }\n  }\n}\n\nfunction _getVolumesFromViewport(viewport): Types.IImageVolume[] {\n  return viewport\n    .getActors()\n    .map((actor) => cache.getVolume(actor.uid))\n    .filter((volume) => !!volume);\n}\n\nfunction _getVolumeFromViewport(viewport): Types.IImageVolume {\n  const volumes = _getVolumesFromViewport(viewport);\n  const dynamicVolume = volumes.find((volume) => volume.isDynamicVolume());\n\n  return dynamicVolume ?? volumes[0];\n}\n\nfunction _createStackViewportCinePlayContext(\n  viewport: StackViewport,\n  waitForRendered: number\n): CINETypes.CinePlayContext {\n  const imageIds = viewport.getImageIds();\n\n  return {\n    get numScrollSteps(): number {\n      return imageIds.length;\n    },\n    get currentStepIndex(): number {\n      return viewport.getTargetImageIdIndex();\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // It is always in acquired orientation\n      return true;\n    },\n    waitForRenderedCount: 0,\n    scroll(delta: number): void {\n      if (\n        this.waitForRenderedCount <= waitForRendered &&\n        viewport.viewportStatus !== ViewportStatus.RENDERED\n      ) {\n        this.waitForRenderedCount++;\n        return;\n      }\n      this.waitForRenderedCount = 0;\n      scroll(viewport, { delta, debounceLoading: debounced });\n    },\n  };\n}\n\nfunction _createVolumeViewportCinePlayContext(\n  viewport: VolumeViewport,\n  volume: Types.IImageVolume\n): CINETypes.CinePlayContext {\n  const { volumeId } = volume;\n  const cachedScrollInfo = {\n    viewPlaneNormal: vec3.create(),\n    scrollInfo: null,\n  };\n\n  const getScrollInfo = () => {\n    const camera = viewport.getCamera();\n    const updateCache =\n      !cachedScrollInfo.scrollInfo ||\n      !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n\n    // Number of steps would change only after rotating the volume so it\n    // caches the result and recomputes only when necessary. Until it is\n    // rotated the current frame is updated locally\n    if (updateCache) {\n      const scrollInfo = csUtils.getVolumeViewportScrollInfo(\n        viewport,\n        volumeId\n      );\n\n      cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n      cachedScrollInfo.scrollInfo = scrollInfo;\n    }\n\n    return cachedScrollInfo.scrollInfo;\n  };\n\n  return {\n    get numScrollSteps(): number {\n      return getScrollInfo().numScrollSteps;\n    },\n    get currentStepIndex(): number {\n      return getScrollInfo().currentStepIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      const camera = viewport.getCamera();\n      const volumeViewPlaneNormal = volume.direction\n        .slice(6, 9)\n        .map((x) => -x) as Types.Point3;\n      const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n\n      // Check if the volume is in acquired orientation\n      // it may be flipped or rotated in plane\n      return glMatrix.equals(dot, 1);\n    },\n    scroll(delta: number): void {\n      getScrollInfo().currentStepIndex += delta;\n      scroll(viewport, { delta });\n    },\n  };\n}\n\nfunction _createDynamicVolumeViewportCinePlayContext(\n  volume: Types.IDynamicImageVolume\n): CINETypes.CinePlayContext {\n  return {\n    get numScrollSteps(): number {\n      return volume.numTimePoints;\n    },\n    get currentStepIndex(): number {\n      return volume.timePointIndex;\n    },\n    get frameTimeVectorEnabled(): boolean {\n      // Looping throught time does not uses frameTimeVector\n      return false;\n    },\n    scroll(delta: number): void {\n      // Updating this property (setter) makes it move to the desired time point\n      volume.timePointIndex += delta;\n    },\n  };\n}\n\nfunction _createCinePlayContext(\n  viewport,\n  playClipOptions: CINETypes.PlayClipOptions\n): CINETypes.CinePlayContext {\n  if (viewport instanceof StackViewport) {\n    return _createStackViewportCinePlayContext(\n      viewport,\n      playClipOptions.waitForRendered ?? 30\n    );\n  }\n\n  if (viewport instanceof VolumeViewport) {\n    const volume = _getVolumeFromViewport(viewport);\n\n    if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n      return _createDynamicVolumeViewportCinePlayContext(\n        <Types.IDynamicImageVolume>volume\n      );\n    }\n\n    return _createVolumeViewportCinePlayContext(viewport, volume);\n  }\n\n  throw new Error('Unknown viewport type');\n}\n\nexport { playClip, stopClip };\n","export function basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nexport default function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n","import min from \"./min.js\";\n\nexport default function transpose(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","export default function min(values, valueof) {\n  let min;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (min > value || (min === undefined && value >= value))) {\n        min = value;\n      }\n    }\n  }\n  return min;\n}\n","import { Types } from '@cornerstonejs/core';\nimport { interpolatePoints } from './algorithms/bspline';\n\n/**\n * Returns a list of uniform distributed values. This list contains the max amount of values which has at least a minimum distance between two consecutive values.\n * minDistributionDistance means the min distance between two consecutive distributed values.\n * Closed interval contains the min/max values.\n *\n * Formula for reference\n * For given {x ∈ R | x ≥ 0} and {minDis ∈ R | minDis ≥ 0}, ∃ D(x) where D(x) ≥ a and D(x) ≤ b  =>\n *         |\n * D(x)  = |                  (b - a)\n *         |  round( ------------------------ * x  )   + a\n *         |                (b - a + 1)\n *         |        round( -----------  )\n *         |                 minDis\n */\nfunction getContinuousUniformDistributionValues(\n  minDistributionDistance: number,\n  closedInterval: [number, number]\n): number[] {\n  const result = [];\n  const [intervalIni, intervalEnd] = closedInterval;\n\n  const intervalSize = intervalEnd - intervalIni + 1;\n  const intensity = Math.floor(intervalSize / minDistributionDistance);\n\n  let x = 0;\n  let continuosDistributionValue =\n    Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n\n  while (continuosDistributionValue <= intervalEnd) {\n    result.push(continuosDistributionValue);\n    x++;\n    continuosDistributionValue =\n      Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n  }\n\n  return result;\n}\n\n/**\n * Interpolates a segment of points from iniIndex until endIndex.\n * The process of interpolation considers the param knotsRatioPercentage as being the percentage of points from Segment that are likely to be considered.\n * By default it uses b-spline algorithm.\n * The result total of points is equal to original points.\n */\nexport default function interpolateSegmentPoints(\n  points: (Types.Point2 | Types.Point3)[],\n  iniIndex: number,\n  endIndex: number,\n  knotsRatioPercentage: number\n): (Types.Point2 | Types.Point3)[] {\n  const segmentSize = endIndex - iniIndex + 1;\n\n  const amountOfKnots =\n    Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n  const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n\n  if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n    return points;\n  }\n\n  // segment should be at least the double of desired minKnot distance. This will ensure at there will enough knots to interpolate.\n  if (segmentSize / minKnotDistance < 2) {\n    return points;\n  }\n\n  const interpolationIniIndex = Math.max(0, iniIndex);\n  const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n  const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n\n  const segmentPointsUnchangedEnd = points.slice(\n    interpolationEndIndex + 1,\n    points.length\n  );\n\n  const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n    interpolationIniIndex,\n    interpolationEndIndex,\n  ]);\n\n  const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n\n  return [\n    ...segmentPointsUnchangedBeg,\n    ...interpolatedPoints,\n    ...segmentPointsUnchangedEnd,\n  ];\n}\n","import {\n  interpolateBasis as d3InterpolateBasis,\n  quantize as d3Quantize,\n} from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nimport { Types } from '@cornerstonejs/core';\n\nfunction isPoints3D(\n  points: (Types.Point2 | Types.Point3)[]\n): points is Types.Point3[] {\n  return (points as Types.Point3[])[0]?.length === 3;\n}\n\n/**\n * Returns an array of the originalPoints length containing the interpolated data.\n * It interpolates a set of points indexed by knotsIndexes.\n * That is, it DISCARDS all points except those in knotsIndexes. Then, a new set of points is created by using a b-spline on the remaining points, in order to re-create a new set of points.\n */\nexport function interpolatePoints(\n  originalPoints: (Types.Point2 | Types.Point3)[],\n  knotsIndexes: number[]\n): (Types.Point2 | Types.Point3)[] {\n  if (\n    !knotsIndexes ||\n    knotsIndexes.length === 0 ||\n    knotsIndexes.length === originalPoints.length\n  ) {\n    return originalPoints;\n  }\n\n  const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n  const xInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][0])\n  );\n  const yInterpolator = d3InterpolateBasis(\n    knotsIndexes.map((k) => originalPoints[k][1])\n  );\n\n  if (isPoints3D(originalPoints)) {\n    const zInterpolator = d3InterpolateBasis(\n      knotsIndexes.map((k) => originalPoints[k][2])\n    );\n    return <Types.Point3[]>(\n      d3Zip(\n        d3Quantize(xInterpolator, n),\n        d3Quantize(yInterpolator, n),\n        d3Quantize(zInterpolator, n)\n      )\n    );\n  } else {\n    return <Types.Point2[]>(\n      d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n))\n    );\n  }\n}\n","import { Types } from '@cornerstonejs/core';\nimport { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nexport function shouldInterpolate(configuration: Record<any, any>): boolean {\n  return (\n    configuration?.interpolation?.interpolateOnAdd === true ||\n    configuration?.interpolation?.interpolateOnEdit === true\n  );\n}\n\n/**\n * Tells whether two points are equal by proximity or not as far as interpolation goes.\n */\nfunction isEqualByProximity(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) < 0.001;\n}\n\n/**\n * Tells whether two points are strictly equal or not as far as interpolation goes.\n */\nfunction isEqual(pointA, pointB) {\n  return point.distanceToPoint(pointA, pointB) === 0;\n}\n\n/**\n * Finds the indexes of points list and otherPoints list that points are identical.\n */\nfunction findMatchIndexes(\n  points: Types.Point2[],\n  otherPoints: Types.Point2[]\n): [number, number] | undefined {\n  for (let i = 0; i < points.length; i++) {\n    for (let j = 0; j < otherPoints.length; j++) {\n      if (isEqual(points[i], otherPoints[j])) {\n        return [i, j];\n      }\n    }\n  }\n}\n/**\n * Returns the following index value (on circular basis) of index param on the given direction.\n */\nfunction followingIndex(\n  index: number,\n  size: number,\n  direction: number\n): number {\n  return (index + size + direction) % size;\n}\n/**\n * Array of params to be used on circular find next index.\n * The values respresent start index, indexDelimiter, list of points\n */\ntype ListParamsType = [number, number, Types.Point2[]];\n\n/**\n * Circular finding that returns the next index for two list where the criteria is met.\n *\n * It can compare two lists out of sync considering it does a circular iteration over them.\n *\n * @example\n *\n * ```\n * const pointsA = [[0, 1], [1, 3], [1, 5], [1,2]];\n * const pointsB = [[1, 2], [1, 5], [1, 3], [0,0]];\n * let firstParam = [0, 0, pointsA]\n * let secondParam = [1, 1, pointsB]\n * const criteria = (pointA, pointB) => areSamePosition(pointA, pointB)\n * const direction = 1;\n * let result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * console.log(result);\n * // prints [1, 2]\n * // use this result and find again\n * firstParam = [result[0]+1, result[0], pointsA]\n * secondParam = [result[1]+1, result[1], pointsB]\n * result = circularFindNextIndexBy(firstParam, secondParam, criteria,direction);\n * * // prints [3, 0]\n *\n */\nfunction circularFindNextIndexBy(\n  listParams: ListParamsType,\n  otherListParams: ListParamsType,\n  criteria: (pointA: Types.Point2, pointB: Types.Point2) => boolean,\n  direction: number\n): [number | undefined, number | undefined] {\n  const [, indexDelimiter, points] = listParams;\n  const [, otherIndexDelimiter, otherPoints] = otherListParams;\n\n  const pointsLength = points.length;\n  const otherPointsLength = otherPoints.length;\n\n  let startIndex = listParams[0];\n  let otherStartIndex = otherListParams[0];\n\n  if (\n    !points[startIndex] ||\n    !otherPoints[otherStartIndex] ||\n    !points[indexDelimiter] ||\n    !otherPoints[otherIndexDelimiter]\n  ) {\n    return [undefined, undefined];\n  }\n\n  while (\n    startIndex !== indexDelimiter &&\n    otherStartIndex !== otherIndexDelimiter\n  ) {\n    if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n      return [startIndex, otherStartIndex];\n    }\n\n    startIndex = followingIndex(startIndex, pointsLength, direction);\n    otherStartIndex = followingIndex(\n      otherStartIndex,\n      otherPointsLength,\n      direction\n    );\n  }\n\n  return [undefined, undefined];\n}\n\n/**\n * Given two list it will find the first and last index of segment from points that diverges from previousPoints\n */\nfunction findChangedSegment(\n  points: Types.Point2[],\n  previousPoints: Types.Point2[]\n): [number, number] {\n  const [firstMatchIndex, previousFirstMatchIndex] =\n    findMatchIndexes(points, previousPoints) || [];\n\n  const toBeNotEqualCriteria = (pointA, pointB) =>\n    isEqualByProximity(pointA, pointB) === false;\n\n  const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy(\n    [\n      followingIndex(firstMatchIndex, points.length, 1),\n      firstMatchIndex,\n      points,\n    ],\n    [\n      followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n      previousFirstMatchIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    1\n  );\n\n  const [highIndex] = circularFindNextIndexBy(\n    [followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points],\n    [\n      followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n      lowOtherDiffIndex,\n      previousPoints,\n    ],\n    toBeNotEqualCriteria,\n    -1\n  );\n\n  return [lowDiffIndex, highIndex];\n}\n\n/**\n * Interpolates the given list of points. In case there is a pointsOfReference the interpolation will occur only on segment disjoint of two list. I.e list of points from param points that are not on list of points from param pointsOfReference.\n */\nexport function getInterpolatedPoints(\n  configuration: Record<any, any>,\n  points: Types.Point2[],\n  pointsOfReference?: Types.Point2[]\n): Types.Point2[] {\n  const { interpolation } = configuration;\n\n  const result = points;\n\n  if (interpolation) {\n    const {\n      knotsRatioPercentageOnAdd,\n      knotsRatioPercentageOnEdit,\n      interpolateOnAdd = false,\n      interpolateOnEdit = false,\n    } = interpolation;\n\n    const knotsRatioPercentage = pointsOfReference\n      ? knotsRatioPercentageOnEdit\n      : knotsRatioPercentageOnAdd;\n    const isEnabled = pointsOfReference ? interpolateOnEdit : interpolateOnAdd;\n\n    if (isEnabled) {\n      // partial or total interpolation\n      const [changedIniIndex, changedEndIndex] = pointsOfReference\n        ? findChangedSegment(points, pointsOfReference)\n        : [0, points.length - 1];\n\n      // do not interpolate if there is no valid segment\n      if (!points[changedIniIndex] || !points[changedEndIndex]) {\n        return points;\n      }\n\n      return <Types.Point2[]>(\n        interpolateSegmentPoints(\n          points,\n          changedIniIndex,\n          changedEndIndex,\n          knotsRatioPercentage\n        )\n      );\n    }\n  }\n\n  return result;\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { vec2 } from 'gl-matrix';\n\n/**\n * Finds the length of the longest line from the midpoint of the line\n * that joins the start and end of the open contour, to the surface of the\n * open contour.\n */\nexport default function findOpenUShapedContourVectorToPeak(\n  canvasPoints: Types.Point2[],\n  viewport: Types.IStackViewport | Types.IVolumeViewport\n): Types.Point3[] {\n  // Find chord from first to last point.\n  const first = canvasPoints[0];\n  const last = canvasPoints[canvasPoints.length - 1];\n\n  const firstToLastUnitVector = vec2.create();\n\n  vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n  vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n\n  // Get the two possible normal vector to this vector\n  // Note: Use the identity that the perpendicular line must have a gradient of\n  // 1 / gradient of the line.\n\n  const normalVector1 = vec2.create();\n  const normalVector2 = vec2.create();\n\n  vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n  vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n\n  // Find the center of the chord.\n  const centerOfFirstToLast: Types.Point2 = [\n    (first[0] + last[0]) / 2,\n    (first[1] + last[1]) / 2,\n  ];\n\n  // Get furthest point.\n\n  const furthest = {\n    dist: 0,\n    index: null,\n  };\n\n  for (let i = 0; i < canvasPoints.length; i++) {\n    const canvasPoint = canvasPoints[i];\n\n    const distance = vec2.dist(canvasPoint, <vec2>centerOfFirstToLast);\n\n    if (distance > furthest.dist) {\n      furthest.dist = distance;\n      furthest.index = i;\n    }\n  }\n\n  const toFurthest: [Types.Point2, Types.Point2] = [\n    canvasPoints[furthest.index],\n    centerOfFirstToLast,\n  ];\n  const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n\n  return toFurthestWorld;\n}\n\nexport function findOpenUShapedContourVectorToPeakOnRender(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): Types.Point3[] {\n  const { viewport } = enabledElement;\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { Events } from '../../../enums';\nimport { EventTypes } from '../../../types';\nimport { state } from '../../../store';\nimport { vec3 } from 'gl-matrix';\nimport {\n  shouldInterpolate,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\n\nconst {\n  addCanvasPointsToArray,\n  pointsAreWithinCloseContourProximity,\n  getFirstIntersectionWithPolyline,\n  getSubPixelSpacingAndXYDirections,\n} = polyline;\n\n/**\n * Activates the contour drawing event loop.\n */\nfunction activateDraw(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.drawData = {\n    canvasPoints: [canvasPos],\n    polylineIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n/**\n * Dectivates and cleans up the contour drawing event loop.\n */\nfunction deactivateDraw(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to a set of preview canvas points of the contour being created.\n * Checks if crossing of lines means early completion and editing needs to be started.\n */\nfunction mouseDragDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const {\n    annotation,\n    viewportIdsToRender,\n    xDir,\n    yDir,\n    spacing,\n    movingTextBox,\n  } = this.commonData;\n  const { polylineIndex, canvasPoints } = this.drawData;\n\n  const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (movingTextBox) {\n    this.isDrawing = false;\n\n    // Drag mode - Move the text boxes world position\n    const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n    const worldPosDelta = deltaPoints.world;\n\n    const { textBox } = annotation.data.handles;\n    const { worldPosition } = textBox;\n\n    worldPosition[0] += worldPosDelta[0];\n    worldPosition[1] += worldPosDelta[1];\n    worldPosition[2] += worldPosDelta[2];\n\n    textBox.hasMoved = true;\n  } else {\n    const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n\n    if (crossingIndex !== undefined) {\n      // If we have crossed our drawing line, create a closed contour and then\n      // start an edit.\n      this.applyCreateOnCross(evt, crossingIndex);\n    } else {\n      const numPointsAdded = addCanvasPointsToArray(\n        element,\n        canvasPoints,\n        canvasPos,\n        this.commonData\n      );\n\n      this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n    }\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the contour on mouse up. If the `allowOpenContours` configuration\n * option is `true`, checks if we should create an open or closed contour.\n * If the `allowOpenContours` configuration option is `false`, always creates a\n * closed contour.\n */\nfunction mouseUpDrawCallback(evt: EventTypes.InteractionEventType): void {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element);\n  } else {\n    this.completeDrawClosedContour(element);\n  }\n}\n\n/**\n * Completes the contour being drawn, creating a closed contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawClosedContour(element: HTMLDivElement): boolean {\n  this.removeCrossedLinesOnCompleteDraw();\n  const { canvasPoints } = this.drawData;\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  // Convert annotation to world coordinates\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[0],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  const updatedPoints = shouldInterpolate(this.configuration)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n  const worldPoints = updatedPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = false;\n  const { textBox } = annotation.data.handles;\n\n  if (!textBox.hasMoved) {\n    this.triggerAnnotationCompleted(annotation);\n  }\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * If lines are crossed during the draw loop, remove the points drawn over the\n * crossing.\n */\nfunction removeCrossedLinesOnCompleteDraw(): void {\n  const { canvasPoints } = this.drawData;\n  const numPoints = canvasPoints.length;\n\n  const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n  const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n\n  const lineSegment = getFirstIntersectionWithPolyline(\n    canvasPointsMinusEnds,\n    endToStart[0],\n    endToStart[1],\n    false\n  );\n\n  if (lineSegment) {\n    const indexToRemoveUpTo = lineSegment[1];\n\n    this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n  }\n}\n\n/**\n * Completes the contour being drawn, creating an open contour annotation. It will return true if contour is completed or false in case contour drawing is halted.\n */\nfunction completeDrawOpenContour(element: HTMLDivElement): boolean {\n  const { canvasPoints } = this.drawData;\n\n  // check and halt if necessary the drawing process, last chance to complete drawing and fire events.\n  if (this.haltDrawing(element, canvasPoints)) {\n    return false;\n  }\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const updatedPoints = shouldInterpolate(this.configuration)\n    ? getInterpolatedPoints(this.configuration, canvasPoints)\n    : canvasPoints;\n\n  // Note: -> This is pretty expensive and may not scale well with hundreds of\n  // contours. A future optimisation if we use this for segmentation is to re-do\n  // this rendering with the GPU rather than SVG.\n  const worldPoints = updatedPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n  const { textBox } = annotation.data.handles;\n\n  // Add the first and last points to the list of handles. These means they\n  // will render handles on mouse hover.\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  // If the annotation is an open U-shaped annotation, find the annotation vector.\n  if (annotation.data.isOpenUShapeContour) {\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n  }\n\n  if (!textBox.hasMoved) {\n    this.triggerAnnotationCompleted(annotation);\n  }\n\n  this.isDrawing = false;\n  this.drawData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateDraw(element);\n\n  return true;\n}\n\n/**\n * Searches for a crossing of the contour during create. If found, returns the\n * index of the point just before the lines cross.\n */\nfunction findCrossingIndexDuringCreate(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  // Note as we super sample the added points, we need to check the whole last mouse move, not the points\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { canvasPoints } = this.drawData;\n  const pointsLessLastOne = canvasPoints.slice(0, -1);\n\n  const lineSegment = getFirstIntersectionWithPolyline(\n    pointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (lineSegment === undefined) {\n    return;\n  }\n\n  const crossingIndex = lineSegment[0];\n\n  return crossingIndex;\n}\n\n/**\n * On crossing of the draw line, create a closed contour, and then start an edit\n * since this occurs during a mouse drag.\n */\nfunction applyCreateOnCross(\n  evt: EventTypes.InteractionEventType,\n  crossingIndex: number\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const { canvasPoints } = this.drawData;\n  const { annotation, viewportIdsToRender } = this.commonData;\n\n  // Add points between the end point and crossing point\n  addCanvasPointsToArray(\n    element,\n    canvasPoints,\n    canvasPoints[crossingIndex],\n    this.commonData\n  );\n  // Remove last point which will be a duplicate now.\n  canvasPoints.pop();\n\n  // Remove points up to just before the crossing index\n  for (let i = 0; i < crossingIndex; i++) {\n    canvasPoints.shift();\n  }\n\n  if (this.completeDrawClosedContour(element)) {\n    // pos complete operation\n    this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n  }\n}\n\n/**\n * Completes the contour on a cancel method call during the draw loop.\n */\nfunction cancelDrawing(element: HTMLElement) {\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n  const firstPoint = canvasPoints[0];\n  const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n  if (\n    allowOpenContours &&\n    !pointsAreWithinCloseContourProximity(\n      firstPoint,\n      lastPoint,\n      this.configuration.closeContourProximity\n    )\n  ) {\n    this.completeDrawOpenContour(element);\n  } else {\n    this.completeDrawClosedContour(element);\n  }\n}\n\n/**\n * Tell whether a drawing should be halted or not. It will be true when canvas points is less than the minimum required.\n */\nfunction shouldHaltDrawing(\n  canvasPoints: any,\n  subPixelResolution: number\n): boolean {\n  const minPoints = Math.max(\n    /**\n     * The number of points to span 3 voxels in length, this is a realistically\n     * smallest open contour one could reasonably define (2 voxels should probably be a line).\n     */\n    subPixelResolution * 3,\n    /**\n     * Minimum 3 points, there are other annotations for one point (probe)\n     * or 2 points (line), so this comes only from a mistake in practice.\n     */\n    3\n  );\n  return canvasPoints.length < minPoints;\n}\n\n/**\n * Check and halt a drawing for a given event. It returns true in case drawing is halted, otherswise false.\n */\nfunction haltDrawing(element: HTMLDivElement, canvasPoints: any): boolean {\n  const { subPixelResolution } = this.configuration;\n\n  if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n    // Remove annotation instead of completing it.\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    removeAnnotation(annotation.annotationUID);\n\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.deactivateDraw(element);\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerDrawLoop(toolInstance): void {\n  toolInstance.activateDraw = activateDraw.bind(toolInstance);\n  toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n\n  toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n  toolInstance.findCrossingIndexDuringCreate =\n    findCrossingIndexDuringCreate.bind(toolInstance);\n  toolInstance.completeDrawOpenContour =\n    completeDrawOpenContour.bind(toolInstance);\n  toolInstance.removeCrossedLinesOnCompleteDraw =\n    removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n  toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n  toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n  toolInstance.completeDrawClosedContour =\n    completeDrawClosedContour.bind(toolInstance);\n  toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n  toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\n\nexport default registerDrawLoop;\n","import { Types } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport { EventTypes } from '../../../types';\n\nconst { addCanvasPointsToArray, getFirstIntersectionWithPolyline } = polyline;\n\n/**\n * Check if the `editCanvasPoints` have crossed the `prevCanvasPoints` during\n * an edit.\n *\n * @privateRemarks The following tricks are required to make the UX smooth and\n * the editing not very picky on exactly where you click:\n * - If we don't cross after 2 points, but projecting the line backwards the\n * proximity distance means we cross, extend the line back.\n * - If we travel the full proximity in canvas points but don't cross a line, we\n * are likely drawing along the line, which is intuitive to the user. At this point\n * snap the start of the edit to the closest place on the `prevCanvasPoints`,\n * so that the edit can be executed in-line.\n */\nfunction checkForFirstCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): void {\n  const eventDetail = evt.detail;\n  const { element, currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (crossedLineSegment) {\n    this.editData.startCrossingIndex = crossedLineSegment[0];\n\n    // On the first crossing, remove the first lines prior to the crossing\n    this.removePointsUpUntilFirstCrossing(isClosedContour);\n    // prevent continue if there are not the minimum of points for this op.\n  } else if (prevCanvasPoints.length >= 2) {\n    if (\n      editCanvasPoints.length >\n      this.configuration.checkCanvasEditFallbackProximity\n    ) {\n      // At this point, likely we are drawing along the line, we are past the proximity for grabbing.\n      // Search for nearest line segment to the start of the edit.\n      // Set the crossing index to the lower index of the segment.\n\n      const firstEditCanvasPoint = editCanvasPoints[0];\n\n      const distanceIndexPairs = [];\n\n      for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n\n        distanceIndexPairs.push({ distance, index: i });\n      }\n\n      distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n      const twoClosestDistanceIndexPairs = [\n        distanceIndexPairs[0],\n        distanceIndexPairs[1],\n      ];\n\n      const lowestIndex = Math.min(\n        twoClosestDistanceIndexPairs[0].index,\n        twoClosestDistanceIndexPairs[1].index\n      );\n\n      this.editData.startCrossingIndex = lowestIndex;\n    } else {\n      // Check if extending a line back 6 (Proximity) canvas pixels would cross a line.\n\n      // Extend point back 6 canvas pixels from first point.\n      const dir = vec2.create();\n\n      vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n      vec2.normalize(dir, dir);\n\n      const proximity = 6;\n\n      const extendedPoint: Types.Point2 = [\n        editCanvasPoints[0][0] - dir[0] * proximity,\n        editCanvasPoints[0][1] - dir[1] * proximity,\n      ];\n\n      const crossedLineSegmentFromExtendedPoint =\n        getFirstIntersectionWithPolyline(\n          prevCanvasPoints,\n          extendedPoint,\n          editCanvasPoints[0],\n          isClosedContour\n        );\n\n      if (crossedLineSegmentFromExtendedPoint) {\n        // Add points.\n        const pointsToPrepend = [extendedPoint];\n\n        addCanvasPointsToArray(\n          element,\n          pointsToPrepend,\n          editCanvasPoints[0],\n          this.commonData\n        );\n\n        editCanvasPoints.unshift(...pointsToPrepend);\n\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n\n        this.editData.editIndex = editCanvasPoints.length - 1;\n        this.editData.startCrossingIndex =\n          crossedLineSegmentFromExtendedPoint[0];\n      }\n    }\n  }\n}\n\n/**\n * Removes the points from the `editCanvasPoints` up until the first crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsUpUntilFirstCrossing(isClosedContour: boolean): void {\n  const { editCanvasPoints, prevCanvasPoints } = this.editData;\n  let numPointsToRemove = 0;\n\n  for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n    const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n\n    const didCrossLine = !!getFirstIntersectionWithPolyline(\n      prevCanvasPoints,\n      firstLine[0],\n      firstLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    numPointsToRemove++;\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n\n  // Remove the points\n  editCanvasPoints.splice(0, numPointsToRemove);\n\n  this.editData.editIndex = editCanvasPoints.length - 1;\n}\n\n/**\n * Returns `true` if the `editCanvasPoints` crosses the `prevCanvasPoints` a\n * second time.\n */\nfunction checkForSecondCrossing(\n  evt: EventTypes.InteractionEventType,\n  isClosedContour: boolean\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n  const { prevCanvasPoints } = this.editData;\n\n  // Note this method is looking for the first corssing found of\n  // *the lines given* to it. The parameters given to it are specified to search\n  // for the second crossing of the prevCanvasPoints, by checking if the last\n  // mouse drag crossed these. This class method is only called if the edit loop\n  // has already has a crossing earlier in the edit.\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    prevCanvasPoints,\n    canvasPos,\n    lastCanvasPoint,\n    isClosedContour\n  );\n\n  if (!crossedLineSegment) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Removes the points from the `editCanvasPoints` after the second crossing of\n * the `prevCanvasPoints`. This is so we can just insert this line segment\n * into the contour.\n */\nfunction removePointsAfterSecondCrossing(isClosedContour: boolean): void {\n  const { prevCanvasPoints, editCanvasPoints } = this.editData;\n\n  // Remove points after the crossing\n  for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n    const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n\n    const didCrossLine = !!getFirstIntersectionWithPolyline(\n      prevCanvasPoints,\n      lastLine[0],\n      lastLine[1],\n      isClosedContour\n    );\n\n    // Remove last element\n    editCanvasPoints.pop();\n\n    if (didCrossLine) {\n      break;\n    }\n  }\n}\n\n/**\n * During an edit, finds the index on the `prevCanvasPoints` that the\n * `editCanvasPoints` should snap to to create one continuous contour.\n *\n * Returns the index, but returns -1 if there is no index on the\n * `prevCanvasPoints` that can be snapped to with causing a crossing of the\n * `editCanvasPoints`.\n */\nfunction findSnapIndex(): number {\n  const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  if (\n    startCrossingIndex === undefined // Haven't crossed line yet\n  ) {\n    return;\n  }\n\n  const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n  const distanceIndexPairs = [];\n\n  for (let i = 0; i < prevCanvasPoints.length; i++) {\n    const prevCanvasPoint = prevCanvasPoints[i];\n    const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n\n    distanceIndexPairs.push({ distance, index: i });\n  }\n\n  distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n\n  // Search through from shortest distance and check which snap line doesn't\n  // Cross the edit line, in most cases the snap index will just be the first one.\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n\n  for (let i = 0; i < distanceIndexPairs.length; i++) {\n    const { index } = distanceIndexPairs[i];\n    const snapCanvasPosition = prevCanvasPoints[index];\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n\n    const crossedLineSegment = getFirstIntersectionWithPolyline(\n      editCanvasPointsLessLastOne,\n      snapCanvasPosition,\n      lastEditCanvasPoint,\n      false // The edit line is not a closed contour\n    );\n\n    if (!crossedLineSegment) {\n      return index;\n    }\n  }\n\n  // If all of the lines caused a crossing, this means we should start a new edit.\n  // Use -1 to signify this.\n  return -1;\n}\n\n/**\n * Checks if the `editCanvasPoints` cross themselves. If they do, remove the\n * region after the cross index, these removes isolated \"island\" loops that the\n * user can draw which make closed contours no longer simple polygons, or open\n * contours twisted.\n */\nfunction checkAndRemoveCrossesOnEditLine(\n  evt: EventTypes.InteractionEventType\n): number | undefined {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPoint = lastPoints.canvas;\n\n  const { editCanvasPoints } = this.editData;\n\n  const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n\n  const crossedLineSegment = getFirstIntersectionWithPolyline(\n    editCanvasPointsLessLastOne,\n    canvasPos,\n    lastCanvasPoint,\n    false\n  );\n\n  if (!crossedLineSegment) {\n    return;\n  }\n\n  // We have found a crossing, remove points after the crossing, cutting off\n  // the \"island\" loop drawn.\n\n  const editIndexCrossed = crossedLineSegment[0];\n  const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n\n  for (let i = 0; i < numPointsToRemove; i++) {\n    editCanvasPoints.pop();\n  }\n}\n\n/**\n * Registers the contour drawing loop to the tool instance.\n */\nfunction registerEditLoopCommon(toolInstance) {\n  toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n  toolInstance.removePointsUpUntilFirstCrossing =\n    removePointsUpUntilFirstCrossing.bind(toolInstance);\n  toolInstance.checkForSecondCrossing =\n    checkForSecondCrossing.bind(toolInstance);\n  toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n  toolInstance.removePointsAfterSecondCrossing =\n    removePointsAfterSecondCrossing.bind(toolInstance);\n  toolInstance.checkAndRemoveCrossesOnEditLine =\n    checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\n\nexport default registerEditLoopCommon;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport { EventTypes } from '../../../types';\nimport { polyline } from '../../../utilities/math';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport {\n  getInterpolatedPoints,\n  shouldInterpolate,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\n\nconst {\n  getSubPixelSpacingAndXYDirections,\n  addCanvasPointsToArray,\n  calculateAreaOfPoints,\n} = polyline;\n\n/**\n * Activates the closed contour edit event loop.\n */\nfunction activateClosedContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: PlanarFreehandROIAnnotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingClosed = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  hideElementCursor(element);\n}\n\n/**\n * Dectivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateClosedContourEdit(element: HTMLDivElement): void {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragClosedContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpClosedContourEditCallback\n  );\n\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by editing in\n * a way that requires a new edit to keep the contour a simple polygon.\n */\nfunction mouseDragClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Check that we have moved at least one voxel in each direction.\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    // If we haven't found the index of the first crossing yet,\n    // see if we can find it.\n    this.checkForFirstCrossing(evt, true);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  if (this.editData.snapIndex === -1) {\n    // No point on the prevCanvasPoints for the editCanvasPoints line to\n    // snap to. Apply edit, and start a new edit as we've gone back on ourselves.\n    this.finishEditAndStartNewEdit(evt);\n    return;\n  }\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, true)\n  ) {\n    // Crossed a second time, apply edit, and start a new edit from the crossing.\n    this.removePointsAfterSecondCrossing(true);\n    this.finishEditAndStartNewEdit(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Finish the current edit, and start a new one.\n */\nfunction finishEditAndStartNewEdit(evt: EventTypes.InteractionEventType): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = false;\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n    snapIndex: undefined,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we combine a few tricks to find the optimal\n * contour:\n * - As the contour is closed, our edit might stradle the boundary between the\n * last and 0th point of the contour, e.g. a small edit might go from e.g. index\n * 960 to index 4. We therefore calculate two possible contours, and find the\n * one with the biggest area, which will define the actual edit the user desired.\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithClosedContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  // Generate two possible contours that could be intepreted from the edit:\n  //\n  // pointSet1 => 0 -> low -> edit -> high - max.\n  // pointSet2 => low -> high -> edit\n  //\n  // Depending on the placement of the edit and the origin, either of these could be the intended edit.\n  // We'll choose the one with the largest area, as edits are considered to be changes to the original area with\n  // A relative change of much less than unity.\n\n  // Point Set 1\n  const pointSet1 = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  let inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  let reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the orignal contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Point Set 2\n  const pointSet2 = [];\n\n  for (let i = lowIndex; i < highIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  inPlaceDistance =\n    distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n\n  reverseDistance =\n    distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const areaPointSet1 = calculateAreaOfPoints(pointSet1);\n  const areaPointSet2 = calculateAreaOfPoints(pointSet2);\n\n  const pointsToRender: Types.Point2[] =\n    areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n\n  return pointsToRender;\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction mouseUpClosedContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Completes the edit of the closed contour when the mouse button is released.\n */\nfunction completeClosedContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldInterpolate(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    const worldPoints = updatedPoints.map((canvasPoint) =>\n      viewport.canvasToWorld(canvasPoint)\n    );\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = false;\n\n    annotation.invalidated = true;\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n  }\n\n  this.isEditingClosed = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateClosedContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the closed\n * contour edit loop.\n */\nfunction cancelClosedContourEdit(element: HTMLDivElement) {\n  this.completeClosedContourEdit(element);\n}\n\n/**\n * Registers the closed contour edit loop to the tool instance.\n */\nfunction registerClosedContourEditLoop(toolInstance): void {\n  toolInstance.activateClosedContourEdit =\n    activateClosedContourEdit.bind(toolInstance);\n  toolInstance.deactivateClosedContourEdit =\n    deactivateClosedContourEdit.bind(toolInstance);\n  toolInstance.mouseDragClosedContourEditCallback =\n    mouseDragClosedContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpClosedContourEditCallback =\n    mouseUpClosedContourEditCallback.bind(toolInstance);\n  toolInstance.finishEditAndStartNewEdit =\n    finishEditAndStartNewEdit.bind(toolInstance);\n  toolInstance.fuseEditPointsWithClosedContour =\n    fuseEditPointsWithClosedContour.bind(toolInstance);\n  toolInstance.cancelClosedContourEdit =\n    cancelClosedContourEdit.bind(toolInstance);\n  toolInstance.completeClosedContourEdit =\n    completeClosedContourEdit.bind(toolInstance);\n}\n\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../../cursors/elementCursor';\nimport type { EventTypes, Annotation } from '../../../types';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nimport {\n  shouldInterpolate,\n  getInterpolatedPoints,\n} from '../../../utilities/planarFreehandROITool/interpolatePoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\n\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour edit event loop.\n */\nfunction activateOpenContourEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: Annotation,\n  viewportIdsToRender: string[]\n): void {\n  this.isEditingOpen = true;\n\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const prevCanvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  this.editData = {\n    prevCanvasPoints,\n    editCanvasPoints: [canvasPos],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox: false,\n  };\n\n  state.isInteractingWithTool = true;\n\n  element.addEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.addEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.addEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  hideElementCursor(element);\n}\n\n/**\n * Deactivates and cleans up the closed contour edit event loop.\n */\nfunction deactivateOpenContourEdit(element: HTMLDivElement) {\n  state.isInteractingWithTool = false;\n\n  element.removeEventListener(\n    Events.MOUSE_UP,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.MOUSE_CLICK,\n    this.mouseUpOpenContourEditCallback\n  );\n\n  element.removeEventListener(\n    Events.TOUCH_END,\n    this.mouseUpOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_DRAG,\n    this.mouseDragOpenContourEditCallback\n  );\n  element.removeEventListener(\n    Events.TOUCH_TAP,\n    this.mouseUpOpenContourEditCallback\n  );\n  resetElementCursor(element);\n}\n\n/**\n * Adds points to the edit line and calculates the preview of the edit to render.\n * Checks if an edit needs to be completed by crossing of lines, or by dragging\n * the edit line past the end of the open contour.\n */\nfunction mouseDragOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, element } = eventDetail;\n  const worldPos = currentPoints.world;\n  const canvasPos = currentPoints.canvas;\n  const enabledElement = getEnabledElement(element);\n  const { renderingEngine, viewport } = enabledElement;\n\n  const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n  const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n\n  const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n  const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n\n  const worldPosDiff = vec3.create();\n\n  vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n\n  const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n  const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n\n  // Get pixel spacing in the direction.\n  // Check that we have moved at least one voxel in each direction.\n\n  if (xDist <= spacing[0] && yDist <= spacing[1]) {\n    // Haven't changed world point enough, don't render\n    return;\n  }\n\n  if (startCrossingIndex !== undefined) {\n    // Edge case: If the edit line itself crosses, remove part of that edit line so we don't\n    // Get isolated regions.\n    this.checkAndRemoveCrossesOnEditLine(evt);\n  }\n\n  const numPointsAdded = addCanvasPointsToArray(\n    element,\n    editCanvasPoints,\n    canvasPos,\n    this.commonData\n  );\n\n  const currentEditIndex = editIndex + numPointsAdded;\n\n  this.editData.editIndex = currentEditIndex;\n\n  if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n    this.checkForFirstCrossing(evt, false);\n  }\n\n  this.editData.snapIndex = this.findSnapIndex();\n\n  this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n\n  if (\n    startCrossingIndex !== undefined &&\n    this.checkForSecondCrossing(evt, false)\n  ) {\n    this.removePointsAfterSecondCrossing(false);\n    this.finishEditOpenOnSecondCrossing(evt);\n  } else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n    this.openContourEditOverwriteEnd(evt);\n  }\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Overwrite the end of the contour with the edit, and then switch to the\n * open contour end edit loop.\n */\nfunction openContourEditOverwriteEnd(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n  // Note: Contours generate from fusedCanvasPoints will be in the direction\n  // with the last point being the current mouse position\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n  annotation.data.handles.activeHandleIndex = 1;\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  // Jump to a normal line edit now.\n  this.deactivateOpenContourEdit(element);\n  this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\n\n/**\n * Checks if we are moving the `editCanvasPoints` past the end of one of the\n * open contour's `prevCanvasPoint`s.\n */\nfunction checkIfShouldOverwriteAnEnd(\n  evt: EventTypes.InteractionEventType\n): boolean {\n  const eventDetail = evt.detail;\n  const { currentPoints, lastPoints } = eventDetail;\n  const canvasPos = currentPoints.canvas;\n  const lastCanvasPos = lastPoints.canvas;\n\n  const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    // Edit not started\n    return false;\n  }\n\n  // No snap index can be found, so contour is being edited away from line.\n  if (snapIndex === -1) {\n    return true;\n  }\n\n  if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n    // Not snapping to final index\n    return false;\n  }\n\n  // Work out the angle between the last mouse move and\n  // And the current point to the snapped point.\n  const p1 = canvasPos;\n  const p2 = lastCanvasPos;\n  const p3 = prevCanvasPoints[snapIndex];\n\n  const a = vec2.create();\n  const b = vec2.create();\n\n  vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n  vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n\n  const aDotb = vec2.dot(a, b);\n  const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n  const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n\n  const theta = Math.acos(aDotb / (magA * magB));\n\n  if (theta < Math.PI / 2) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a single contour ready for\n * end editing.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsForOpenContourEndEdit(): Types.Point2[] {\n  const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } =\n    this.editData;\n\n  const newCanvasPoints = [];\n\n  // Note: Generated contours will both be in the direction with the\n  // last point being the current mouse position\n\n  if (snapIndex === 0) {\n    // end -> crossingpoint -> edit\n    // Add points from the end of the previous contour, to the crossing point.\n    for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // start -> crossingpoint -> edit\n    // Add points from the orignal contour origin up to the low index.\n    for (let i = 0; i < startCrossingIndex; i++) {\n      const canvasPoint = prevCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[0]\n  );\n\n  const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(\n    prevCanvasPoints[startCrossingIndex],\n    editCanvasPoints[editCanvasPoints.length - 1]\n  );\n\n  if (\n    distanceBetweenCrossingIndexAndFirstPoint <\n    distanceBetweenCrossingIndexAndLastPoint\n  ) {\n    // In order\n    for (let i = 0; i < editCanvasPoints.length; i++) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    // reverse\n    for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = editCanvasPoints[i];\n\n      newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  return newCanvasPoints;\n}\n\n/**\n * This method combines the contour before editing (prevCanvasPoints) with\n * the current edit (editCanvasPoints), to produce a renderable preview of the\n * edit. Upon finishing the contour, the preview generated here is written back\n * into the contour state.\n *\n * @privateRemarks In this method we use the following trick to find the\n * optimal contour:\n * - As the contour and the edit can be drawn with different chiralities, we find if\n * the edit line aligns better with the intended cross points in its current order\n * or reversed. We do this by minimising the distance between its ends and the\n * intended crossing points.\n */\nfunction fuseEditPointsWithOpenContour(\n  evt: EventTypes.InteractionEventType\n): Types.Point2[] {\n  const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } =\n    this.editData;\n\n  if (startCrossingIndex === undefined || snapIndex === undefined) {\n    return undefined;\n  }\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  // Augment the editCanvasPoints array, between the end of edit and the snap index.\n  const augmentedEditCanvasPoints = [...editCanvasPoints];\n\n  addCanvasPointsToArray(\n    element,\n    augmentedEditCanvasPoints,\n    prevCanvasPoints[snapIndex],\n    this.commonData\n  );\n\n  if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n    // If any points added, remove the last point, which will be a clone of the snapIndex\n    augmentedEditCanvasPoints.pop();\n  }\n\n  // Calculate the distances between the first and last edit points and the origin of the\n  // Contour with the snap point. These will be used to see which way around the edit array should be\n  // Placed within the preview.\n\n  let lowIndex;\n  let highIndex;\n\n  if (startCrossingIndex > snapIndex) {\n    lowIndex = snapIndex;\n    highIndex = startCrossingIndex;\n  } else {\n    lowIndex = startCrossingIndex;\n    highIndex = snapIndex;\n  }\n\n  const distanceBetweenLowAndFirstPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenLowAndLastPoint = vec2.distance(\n    prevCanvasPoints[lowIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const distanceBetweenHighAndFirstPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[0]\n  );\n\n  const distanceBetweenHighAndLastPoint = vec2.distance(\n    prevCanvasPoints[highIndex],\n    augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]\n  );\n\n  const pointsToRender = [];\n\n  // Add points from the orignal contour origin up to the low index.\n  for (let i = 0; i < lowIndex; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  // Check which orientation of the edit line minimizes the distance between the\n  // origial contour low/high points and the start/end nodes of the edit line.\n\n  const inPlaceDistance =\n    distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n\n  const reverseDistance =\n    distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n\n  if (inPlaceDistance < reverseDistance) {\n    for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  } else {\n    for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n      const canvasPoint = augmentedEditCanvasPoints[i];\n\n      pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n  }\n\n  // Add points from the original contour's high index up to to its end point.\n  for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n    const canvasPoint = prevCanvasPoints[i];\n\n    pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n  }\n\n  return pointsToRender;\n}\n\n/**\n * On a second crossing, apply edit, and start a new edit from the crossing.\n */\nfunction finishEditOpenOnSecondCrossing(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n\n  const worldPoints = fusedCanvasPoints.map((canvasPoint) =>\n    viewport.canvasToWorld(canvasPoint)\n  );\n\n  annotation.data.polyline = worldPoints;\n  annotation.data.isOpenContour = true;\n  annotation.data.handles.points = [\n    worldPoints[0],\n    worldPoints[worldPoints.length - 1],\n  ];\n\n  this.triggerAnnotationModified(annotation, enabledElement);\n\n  const lastEditCanvasPoint = editCanvasPoints.pop();\n\n  this.editData = {\n    prevCanvasPoints: fusedCanvasPoints,\n    editCanvasPoints: [lastEditCanvasPoint],\n    startCrossingIndex: undefined,\n    editIndex: 0,\n  };\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n}\n\n/**\n * Completes the edit of the open contour when the mouse button is released.\n */\nfunction mouseUpOpenContourEditCallback(\n  evt: EventTypes.InteractionEventType\n): void {\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Completes the edit of the open contour.\n */\nfunction completeOpenContourEdit(element: HTMLDivElement) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport, renderingEngine } = enabledElement;\n\n  const { annotation, viewportIdsToRender } = this.commonData;\n  const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints) {\n    const updatedPoints = shouldInterpolate(this.configuration)\n      ? getInterpolatedPoints(\n          this.configuration,\n          fusedCanvasPoints,\n          prevCanvasPoints\n        )\n      : fusedCanvasPoints;\n\n    const worldPoints = updatedPoints.map((canvasPoint) =>\n      viewport.canvasToWorld(canvasPoint)\n    );\n    annotation.data.polyline = worldPoints;\n    annotation.data.isOpenContour = true;\n    annotation.data.handles.points = [\n      worldPoints[0],\n      worldPoints[worldPoints.length - 1],\n    ];\n\n    // If the annotation is an open U-shaped annotation, find the annotation vector.\n    if (annotation.data.isOpenUShapeContour) {\n      annotation.data.openUShapeContourVectorToPeak =\n        findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n    }\n\n    annotation.invalidated = true;\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n  }\n\n  this.isEditingOpen = false;\n  this.editData = undefined;\n  this.commonData = undefined;\n\n  triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n  this.deactivateOpenContourEdit(element);\n}\n\n/**\n * Completes the edit on a cancel method call during the open\n * contour edit loop.\n */\nfunction cancelOpenContourEdit(element: HTMLDivElement) {\n  this.completeOpenContourEdit(element);\n}\n\n/**\n * Registers the open contour edit loop to the tool instance.\n */\nfunction registerOpenContourEditLoop(toolInstance) {\n  toolInstance.activateOpenContourEdit =\n    activateOpenContourEdit.bind(toolInstance);\n  toolInstance.deactivateOpenContourEdit =\n    deactivateOpenContourEdit.bind(toolInstance);\n  toolInstance.mouseDragOpenContourEditCallback =\n    mouseDragOpenContourEditCallback.bind(toolInstance);\n  toolInstance.mouseUpOpenContourEditCallback =\n    mouseUpOpenContourEditCallback.bind(toolInstance);\n  toolInstance.fuseEditPointsWithOpenContour =\n    fuseEditPointsWithOpenContour.bind(toolInstance);\n  toolInstance.finishEditOpenOnSecondCrossing =\n    finishEditOpenOnSecondCrossing.bind(toolInstance);\n  toolInstance.checkIfShouldOverwriteAnEnd =\n    checkIfShouldOverwriteAnEnd.bind(toolInstance);\n  toolInstance.fuseEditPointsForOpenContourEndEdit =\n    fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n  toolInstance.openContourEditOverwriteEnd =\n    openContourEditOverwriteEnd.bind(toolInstance);\n  toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n  toolInstance.completeOpenContourEdit =\n    completeOpenContourEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport type {\n  EventTypes,\n  Annotation,\n  ToolHandle,\n  TextBoxHandle,\n} from '../../../types';\nimport { polyline } from '../../../utilities/math';\n\nconst { getSubPixelSpacingAndXYDirections } = polyline;\n\n/**\n * Activates the open contour end edit. This actually just sets up the state so\n * that the tool thinks we are mid draw, and then jumps into the drawing loop.\n */\nfunction activateOpenContourEndEdit(\n  evt: EventTypes.InteractionEventType,\n  annotation: Annotation,\n  viewportIdsToRender: string[],\n  handle: ToolHandle | null\n): void {\n  this.isDrawing = true;\n\n  const eventDetail = evt.detail;\n  const { element } = eventDetail;\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(\n    viewport,\n    this.configuration.subPixelResolution\n  );\n\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n  const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n\n  // If 0, invert point direction, if 1, keep point direction the same.\n  // This is so we can just jump as into the state as if the annotation was just being drawn.\n  if (handleIndexGrabbed === 0) {\n    canvasPoints.reverse();\n  }\n\n  let movingTextBox = false;\n  if ((handle as TextBoxHandle).worldPosition) {\n    movingTextBox = true;\n  }\n\n  this.drawData = {\n    canvasPoints: canvasPoints,\n    polylineIndex: canvasPoints.length - 1,\n  };\n\n  this.commonData = {\n    annotation,\n    viewportIdsToRender,\n    spacing,\n    xDir,\n    yDir,\n    movingTextBox,\n  };\n\n  state.isInteractingWithTool = true;\n\n  // Jump into drawing loop.\n  element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n  element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n  element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n  element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n\n  hideElementCursor(element);\n}\n\n/**\n * Registers the open contour end edit loop to the tool instance.\n */\nfunction registerOpenContourEndEditLoop(toolInstance): void {\n  toolInstance.activateOpenContourEndEdit =\n    activateOpenContourEndEdit.bind(toolInstance);\n}\n\nexport default registerOpenContourEndEditLoop;\n","import type { Types } from '@cornerstonejs/core';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawPolyline as drawPolylineSvg,\n} from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport { PlanarFreehandROIAnnotation } from '../../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\nimport { SVGDrawingHelper } from '../../../types';\n\nconst { pointsAreWithinCloseContourProximity } = polyline;\n\ntype PlanarFreehandROIRenderOptions = {\n  color?: string;\n  width?: number;\n  connectFirstToLast?: boolean;\n};\n\nfunction _getRenderingOptions(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): PlanarFreehandROIRenderOptions {\n  const styleSpecifier: StyleSpecifier = {\n    toolGroupId: this.toolGroupId,\n    toolName: this.getToolName(),\n    viewportId: enabledElement.viewport.id,\n    annotationUID: annotation.annotationUID,\n  };\n\n  const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n  const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n  const color = this.getStyle('color', styleSpecifier, annotation);\n\n  const isOpenContour = annotation.data.isOpenContour;\n\n  const options = {\n    color: color === undefined ? undefined : <string>color,\n    width: lineWidth === undefined ? undefined : <number>lineWidth,\n    lineDash: lineDash === undefined ? undefined : <number[]>lineDash,\n    connectLastToFirst: !isOpenContour,\n  };\n\n  return options;\n}\n\n/**\n * Renders a `PlanarFreehandROIAnnotation` that is not currently being drawn or edited.\n */\nfunction renderContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  // prevent drawing or further calculation in case viewport data is not ready yet\n  if (!enabledElement?.viewport?.getImageData()) {\n    return;\n  }\n  // Check if the contour is an open contour\n  if (annotation.data.isOpenContour) {\n    // If its an open contour, check i its a U-shaped contour\n    if (annotation.data.isOpenUShapeContour) {\n      calculateUShapeContourVectorToPeakIfNotPresent(\n        enabledElement,\n        annotation\n      );\n\n      this.renderOpenUShapedContour(\n        enabledElement,\n        svgDrawingHelper,\n        annotation\n      );\n    } else {\n      // If not a U-shaped contour, render standard open contour.\n      this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    }\n  } else {\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n  }\n}\n\n/**\n * If the open U-shaped contour does not have a peak.\n */\nfunction calculateUShapeContourVectorToPeakIfNotPresent(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  if (!annotation.data.openUShapeContourVectorToPeak) {\n    // Annotation just been set to be an open U-shaped contour.\n    // calculate its peak vector here.\n    annotation.data.openUShapeContourVectorToPeak =\n      findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n  }\n}\n\n/**\n * Renders an closed `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderClosedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Its unfortunate that we have to do this for each annotation,\n  // Even if its unchanged. In the future we could cache the canvas points per\n  // element on the tool? That feels very weird also as we'd need to manage\n  // it/clean them up. Its a pre-optimisation for now and we can tackle it if it\n  // becomes a problem.\n  const canvasPoints = annotation.data.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` annotation.\n */\nfunction renderOpenContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const canvasPoints = annotation.data.polyline.map((worldPos) =>\n    viewport.worldToCanvas(worldPos)\n  );\n\n  const polylineUID = '1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUID,\n    canvasPoints,\n    options\n  );\n\n  const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n\n  if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n    const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n\n    // Draw highlighted points\n    const handleGroupUID = '0';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const handlePoints = [\n      canvasPoints[0],\n      canvasPoints[canvasPoints.length - 1],\n    ];\n\n    // Don't render a hovered handle, as this will be rendered larger in\n    // the next block.\n    if (activeHandleIndex === 0) {\n      handlePoints.shift();\n    } else if (activeHandleIndex === 1) {\n      handlePoints.pop();\n    }\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      handlePoints,\n      {\n        color: options.color,\n        handleRadius: radius,\n      }\n    );\n  }\n\n  if (activeHandleIndex !== null) {\n    // Draw highlighted points\n    const handleGroupUID = '1';\n\n    // We already mapped all the points, so don't do the mapping again.\n    // The activeHandleIndex can only be one of two points.\n    const indexOfCanvasPoints =\n      activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n\n    const handlePoint = canvasPoints[indexOfCanvasPoints];\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotation.annotationUID,\n      handleGroupUID,\n      [handlePoint],\n      { color: options.color }\n    );\n  }\n}\n\nfunction renderOpenUShapedContour(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { viewport } = enabledElement;\n  const { polyline, openUShapeContourVectorToPeak } = annotation.data;\n\n  this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n  // prevent rendering u shape in case openUShapeContourVectorToPeak is not set yet\n  if (!openUShapeContourVectorToPeak) {\n    return;\n  }\n\n  const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n  const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n\n  const openUShapeContourVectorToPeakCanvas = [\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n    viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n  ];\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  // Join first and last points\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'first-to-last',\n    [firstCanvasPoint, lastCanvasPoint],\n    {\n      color: options.color,\n      width: options.width,\n      connectLastToFirst: false,\n      lineDash: '2,2',\n    }\n  );\n\n  // Render midpoint to open contour surface line\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    'midpoint-to-open-contour',\n    [\n      openUShapeContourVectorToPeakCanvas[0],\n      openUShapeContourVectorToPeakCanvas[1],\n    ],\n    {\n      color: options.color,\n      width: options.width,\n      connectLastToFirst: false,\n      lineDash: '2,2',\n    }\n  );\n}\n\n/**\n * Renders a new `PlanarFreehandROIAnnotation` annotation during\n * creation/drawing.\n */\nfunction renderContourBeingDrawn(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const { allowOpenContours } = this.configuration;\n  const { canvasPoints } = this.drawData;\n\n  // Override rendering whilst drawing the contour, we don't know if its open\n  // or closed yet\n  options.connectLastToFirst = false;\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    '1',\n    canvasPoints,\n    options\n  );\n\n  if (allowOpenContours) {\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n\n    // Check if start and end are within close proximity\n    if (\n      pointsAreWithinCloseContourProximity(\n        firstPoint,\n        lastPoint,\n        this.configuration.closeContourProximity\n      )\n    ) {\n      // Preview join last points\n      drawPolylineSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        '2',\n        [lastPoint, firstPoint],\n        options\n      );\n    } else {\n      // Draw start point\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotation.annotationUID,\n        handleGroupUID,\n        [firstPoint],\n        { color: options.color, handleRadius: 2 }\n      );\n    }\n  }\n}\n\n/**\n * Renders a closed `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderClosedContourBeingEdited(\n  enabledElement,\n  svgDrawingHelper,\n  annotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Renders an open `PlanarFreehandROIAnnotation` being edited.\n */\nfunction renderOpenContourBeingEdited(\n  enabledElement: Types.IEnabledElement,\n  svgDrawingHelper: SVGDrawingHelper,\n  annotation: PlanarFreehandROIAnnotation\n): void {\n  const { fusedCanvasPoints } = this.editData;\n\n  if (fusedCanvasPoints === undefined) {\n    // No edit to render yet, render closed contour.\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n\n    return;\n  }\n\n  const options = this._getRenderingOptions(enabledElement, annotation);\n\n  const polylineUIDToRender = 'preview-1';\n\n  drawPolylineSvg(\n    svgDrawingHelper,\n    annotation.annotationUID,\n    polylineUIDToRender,\n    fusedCanvasPoints,\n    options\n  );\n}\n\n/**\n * Registers the render methods of various contour states to the tool instance.\n */\nfunction registerRenderMethods(toolInstance) {\n  toolInstance.renderContour = renderContour.bind(toolInstance);\n  toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n  toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n  toolInstance.renderOpenUShapedContour =\n    renderOpenUShapedContour.bind(toolInstance);\n\n  toolInstance.renderContourBeingDrawn =\n    renderContourBeingDrawn.bind(toolInstance);\n\n  toolInstance.renderClosedContourBeingEdited =\n    renderClosedContourBeingEdited.bind(toolInstance);\n  toolInstance.renderOpenContourBeingEdited =\n    renderOpenContourBeingEdited.bind(toolInstance);\n  toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\n\nexport default registerRenderMethods;\n","import {\n  CONSTANTS,\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  StackViewport,\n  VolumeViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport { Events } from '../../enums';\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../../stateManagement/annotation/annotationState';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport {\n  EventTypes,\n  ToolHandle,\n  Annotation,\n  Annotations,\n  AnnotationStyle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { PlanarFreehandROICommonData } from '../../utilities/math/polyline/planarFreehandROIInternalTypes';\n\nimport { getIntersectionCoordinatesWithPolyline } from '../../utilities/math/polyline/getIntersectionWithPolyline';\nimport pointInShapeCallback from '../../utilities/pointInShapeCallback';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\n\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\n/**\n * PlanarFreehandROITool lets you draw annotations that define an arbitrarily drawn region.\n * You can use the PlanarFreehandROITool in all perpendicular views (axial, sagittal, coronal),\n * support for oblique views is possible, but not yet supported, due to the implementation of\n * `getSubPixelSpacingAndXYDirections`.\n *\n * The resulting annotation's data and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * PlanarFreehandROITool annotation can be smoothed on drawing completion. This is a configured based approach.\n * The interpolation process uses b-spline algorithm and consider 4 configurations properties:\n * - interpolation.interpolateOnAdd: to tell whether it should be interpolated or not (for editing it is considered the property interpolateOnEdit) (default: false)\n * - interpolation.interpolateOnEdit: to tell whether it should be interpolated or not when editing (default: false)\n * - interpolation.knotsRatioPercentageOnAdd: percentage of points from Segment that are likely to be considered knots during interpolation (for editing it is considered the property knotsRatioPercentageOnEdit) ( default: 40)\n * - interpolation.knotsRatioPercentageOnEdit: same as knotsRatioPercentageOnAdd but applicable only when editing the tool (default: 40)\n *\n * So, with that said the interpolation might occur when:\n * - drawing is done (i.e mouse is released) and interpolation.interpolateOnAdd is true. Interpolation algorithm uses knotsRatioPercentageOnAdd\n * - edit drawing is done (i.e mouse is released) and interpolation.interpolateOnEdit is true. Interpolation algorithm uses knotsRatioPercentageOnEdit and its only applied to changed segment\n * Interpolation does not occur when:\n * - interpolation.interpolateOnAdd is false and drawing is completed\n * - interpolation.interpolateOnEdit is false and edit is completed\n * - drawing still happening (editing or not)\n *\n * The result of interpolation will be a smoother set of segments.\n * Changing tool configuration (see below) you can fine-tune the interpolation process by changing knotsRatioPercentageOnAdd and knotsRatioPercentageOnEdit value, which smaller values produces a more agressive interpolation.\n * A smaller value of knotsRatioPercentageOnAdd/knotsRatioPercentageOnEdit produces a more agressive interpolation.\n *\n * ```js\n * cornerstoneTools.addTool(PlanarFreehandROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(PlanarFreehandROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(PlanarFreehandROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // set interpolation agressiveness while adding new annotation (ps: this does not change if interpolation is ON or OFF)\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   interpolation: { knotsRatioPercentageOnAdd: 30 },\n * });\n *\n * // set interpolation to be ON while editing only\n * toolGroup.setToolConfiguration(PlanarFreehandROITool.toolName, {\n *   interpolation: { interpolateOnAdd: false, interpolateOnEdit: true  },\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass PlanarFreehandROITool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  private commonData?: PlanarFreehandROICommonData;\n  isDrawing = false;\n  isEditingClosed = false;\n  isEditingOpen = false;\n\n  private activateDraw: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateClosedContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[]\n  ) => void;\n  private activateOpenContourEndEdit: (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    viewportIdsToRender: string[],\n    handle: ToolHandle | null\n  ) => void;\n  private cancelDrawing: (element: HTMLDivElement) => void;\n  private cancelClosedContourEdit: (element: HTMLDivElement) => void;\n  private cancelOpenContourEdit: (element: HTMLDivElement) => void;\n\n  private renderContour: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderContourBeingDrawn: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderClosedContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n  private renderOpenContourBeingEdited: (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper,\n    annotation: PlanarFreehandROIAnnotation\n  ) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        alwaysRenderOpenContourHandles: {\n          // When true, always render end points when you have an open contour, rather\n          // than just rendering a line.\n          enabled: false,\n          // When enabled, use this radius to draw the endpoints whilst not hovering.\n          radius: 2,\n        },\n        allowOpenContours: true,\n        // Proximity in canvas coordinates used to join contours.\n        closeContourProximity: 10,\n        // The proximity at which we fallback to the simplest grabbing logic for\n        // determining what index of the contour to start editing.\n        checkCanvasEditFallbackProximity: 6,\n        // The relative distance that points should be dropped along the polyline\n        // in units of the image pixel spacing. A value of 1 means that nodes must\n        // be placed no closed than the image spacing apart. A value of 4 means that 4\n        // nodes should be placed within the space of one image pixel size. A higher\n        // value gives more finese to the tool/smoother lines, but the value cannot\n        // be infinite as the lines become very computationally expensive to draw.\n        subPixelResolution: 4,\n        interpolation: {\n          interpolateOnAdd: false,\n          interpolateOnEdit: false, // used for edit only\n          knotsRatioPercentageOnAdd: 40,\n          knotsRatioPercentageOnEdit: 40,\n        },\n        calculateStats: false,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // Register event loops and rendering logic, which are stored in different\n    // Files due to their complexity/size.\n    registerDrawLoop(this);\n    registerEditLoopCommon(this);\n    registerClosedContourEditLoop(this);\n    registerOpenContourEditLoop(this);\n    registerOpenContourEndEditLoop(this);\n    registerRenderMethods(this);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current image, creates\n   * a `PlanarFreehandROIAnnotation` and stores it in the annotationManager.\n   *\n   * @param evt - `EventTypes.NormalizedMouseEventType`\n   * @returns The `PlanarFreehandROIAnnotation` object.\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): PlanarFreehandROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: PlanarFreehandROIAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          points: [], // Handle points for open contours\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        polyline: [<Types.Point3>[...worldPos]], // Polyline coordinates\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    this.activateDraw(evt, annotation, viewportIdsToRender);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * Begins an edit of an open contour, when the mouse has selected a handle\n   * (end) of the open contour.\n   *\n   * @param evt - `EventTypes.MouseDownEventType`\n   * @param annotation - `PlanarFreehandROIAnnotation` annotation.\n   * @param handle - The handle index, 0 for the start and 1 for the end.\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.activateOpenContourEndEdit(\n      evt,\n      annotation,\n      viewportIdsToRender,\n      handle\n    );\n  };\n\n  /**\n   * Edits the open or closed contour when the line is grabbed and dragged.\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    if (annotation.data.isOpenContour) {\n      this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n    } else {\n      this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n  };\n\n  /**\n   * Returns if the canvas point is near the line of the given annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - The `PlanarFreehandROIAnnotation`.\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: PlanarFreehandROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const points = annotation.data.polyline;\n\n    // NOTE: It is implemented this way so that we do not double calculate\n    // points when number crunching adjacent line segments.\n    let previousPoint = viewport.worldToCanvas(points[0]);\n\n    for (let i = 1; i < points.length; i++) {\n      const p1 = previousPoint;\n      const p2 = viewport.worldToCanvas(points[i]);\n\n      const distance = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n\n      if (distance === true) {\n        return true;\n      }\n\n      previousPoint = p2;\n    }\n\n    if (annotation.data.isOpenContour) {\n      // Contour is open, don't check last point to first point.\n      return false;\n    }\n\n    // check last point to first point\n    const pStart = viewport.worldToCanvas(points[0]);\n    const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n\n    const distance = pointCanProjectOnLine(\n      canvasCoords,\n      pStart,\n      pEnd,\n      proximity\n    );\n\n    if (distance === true) {\n      return true;\n    }\n\n    return false;\n  };\n\n  cancel = (element: HTMLDivElement): void => {\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (isDrawing) {\n      this.cancelDrawing(element);\n    } else if (isEditingOpen) {\n      this.cancelOpenContourEdit(element);\n    } else if (isEditingClosed) {\n      this.cancelClosedContourEdit(element);\n    }\n  };\n\n  /**\n   * Triggers an annotation modified event.\n   */\n  triggerAnnotationModified = (\n    annotation: PlanarFreehandROIAnnotation,\n    enabledElement: Types.IEnabledElement\n  ): void => {\n    const { viewportId, renderingEngineId } = enabledElement;\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * Triggers an annotation completed event.\n   */\n  triggerAnnotationCompleted = (\n    annotation: PlanarFreehandROIAnnotation\n  ): void => {\n    const eventType = Events.ANNOTATION_COMPLETED;\n\n    const eventDetail: AnnotationCompletedEventDetail = {\n      annotation,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n  };\n\n  /**\n   * @override We need to override this method as the tool doesn't always have\n   * `handles`, which means `filterAnnotationsForDisplay` fails inside\n   * `filterAnnotationsWithinSlice`.\n   */\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations | undefined {\n    if (!annotations || !annotations.length) {\n      return;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let annotationsToDisplay;\n\n    if (viewport instanceof StackViewport) {\n      // Use the default `filterAnnotationsForDisplay` utility, as the stack\n      // path doesn't require handles.\n      annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n    } else if (viewport instanceof VolumeViewport) {\n      const camera = viewport.getCamera();\n\n      const { spacingInNormalDirection } =\n        csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n\n      // Get data with same normal and within the same slice\n      annotationsToDisplay = this.filterAnnotationsWithinSlice(\n        annotations,\n        camera,\n        spacingInNormalDirection\n      );\n    } else {\n      throw new Error(`Viewport Type ${viewport.type} not supported`);\n    }\n\n    return annotationsToDisplay;\n  }\n\n  /**\n   * Altered version of the `utilities.planar.filterAnnotationsWithinSlice`,\n   * which uses the polyline position rather than the handle. As the polyline is\n   * always present.\n   */\n  private filterAnnotationsWithinSlice(\n    annotations: Annotations,\n    camera: Types.ICamera,\n    spacingInNormalDirection: number\n  ): Annotations {\n    const { viewPlaneNormal } = camera;\n\n    const annotationsWithParallelNormals = annotations.filter(\n      (td: Annotation) => {\n        const annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n\n        const isParallel =\n          Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n          PARALLEL_THRESHOLD;\n\n        return annotationViewPlaneNormal && isParallel;\n      }\n    );\n\n    // No in plane annotations.\n    if (!annotationsWithParallelNormals.length) {\n      return [];\n    }\n\n    // Annotation should be within the slice, which means that it should be between\n    // camera's focalPoint +/- spacingInNormalDirection.\n\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n\n    const annotationsWithinSlice = [];\n\n    for (const annotation of annotationsWithParallelNormals) {\n      const data = annotation.data;\n      const point = data.polyline[0];\n\n      if (!annotation.isVisible) {\n        continue;\n      }\n\n      // A = point\n      // B = focal point\n      // P = normal\n\n      // B-A dot P  => Distance in the view direction.\n      // this should be less than half the slice distance.\n\n      const dir = vec3.create();\n\n      vec3.sub(dir, focalPoint, point);\n\n      const dot = vec3.dot(dir, viewPlaneNormal);\n\n      if (Math.abs(dot) < halfSpacingInNormalDirection) {\n        annotationsWithinSlice.push(annotation);\n      }\n    }\n\n    return annotationsWithinSlice;\n  }\n\n  /**\n   * Draws the `PlanarFreehandROIAnnotation`s at each request animation frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n\n    const targetId = this.getTargetId(viewport);\n\n    let annotations = <PlanarFreehandROIAnnotation[]>(\n      getAnnotations(this.getToolName(), element)\n    );\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as PlanarFreehandROIAnnotation[];\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const isDrawing = this.isDrawing;\n    const isEditingOpen = this.isEditingOpen;\n    const isEditingClosed = this.isEditingClosed;\n\n    if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n      // No annotations are currently being modified, so we can just use the\n      // render contour method to render all of them\n      annotations.forEach((annotation) => {\n        this.renderContour(enabledElement, svgDrawingHelper, annotation);\n      });\n    } else {\n      // One of the annotations will need special rendering treatment, render all\n      // other annotations not being interacted with using the standard renderContour\n      // rendering path.\n      const activeAnnotationUID = this.commonData.annotation.annotationUID;\n\n      annotations.forEach((annotation) => {\n        if (annotation.annotationUID === activeAnnotationUID) {\n          if (isDrawing) {\n            this.renderContourBeingDrawn(\n              enabledElement,\n              svgDrawingHelper,\n              annotation\n            );\n          } else if (isEditingClosed) {\n            this.renderClosedContourBeingEdited(\n              enabledElement,\n              svgDrawingHelper,\n              annotation\n            );\n          } else if (isEditingOpen) {\n            this.renderOpenContourBeingEdited(\n              enabledElement,\n              svgDrawingHelper,\n              annotation\n            );\n          } else {\n            throw new Error(\n              `Unknown ${this.getToolName()} annotation rendering state`\n            );\n          }\n        } else {\n          this.renderContour(enabledElement, svgDrawingHelper, annotation);\n        }\n      });\n\n      // Todo: return boolean flag for each rendering route in the planar tool.\n      renderStatus = true;\n    }\n\n    if (!this.configuration.calculateStats) {\n      return;\n    }\n\n    annotations.forEach((annotation) => {\n      const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n      if (\n        annotation.annotationUID === activeAnnotationUID &&\n        !this.commonData?.movingTextBox\n      ) {\n        return;\n      }\n\n      if (!this.commonData?.movingTextBox) {\n        const { data } = annotation;\n        if (\n          !data.cachedStats[targetId] ||\n          data.cachedStats[targetId].areaUnit == null\n        ) {\n          data.cachedStats[targetId] = {\n            Modality: null,\n            area: null,\n            max: null,\n            mean: null,\n            stdDev: null,\n            areaUnit: null,\n          };\n\n          this._calculateCachedStats(\n            annotation,\n            viewport,\n            renderingEngine,\n            enabledElement\n          );\n        } else if (annotation.invalidated) {\n          this._throttledCalculateCachedStats(\n            annotation,\n            viewport,\n            renderingEngine,\n            enabledElement\n          );\n        }\n      }\n\n      this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n    });\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { cachedStats, polyline: points } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, metadata } = image;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // Using an arbitrary start point (canvasPoint), calculate the\n      // mm spacing for the canvas in the X and Y directions.\n      const canvasPoint = canvasCoordinates[0];\n      const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n      const deltaXPoint = viewport.canvasToWorld([\n        canvasPoint[0] + 1,\n        canvasPoint[1],\n      ]);\n      const deltaYPoint = viewport.canvasToWorld([\n        canvasPoint[0],\n        canvasPoint[1] + 1,\n      ]);\n\n      const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n      const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n\n      const scale = getCalibratedScale(image);\n      let area =\n        polyline.calculateAreaOfPoints(canvasCoordinates) / scale / scale;\n      // Convert from canvas_pixels ^2 to mm^2\n      area *= deltaInX * deltaInY;\n\n      const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n      worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n      worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n      worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n\n      let iMin = worldPosIndex[0];\n      let iMax = worldPosIndex[0];\n\n      let jMin = worldPosIndex[1];\n      let jMax = worldPosIndex[1];\n\n      let kMin = worldPosIndex[2];\n      let kMax = worldPosIndex[2];\n\n      for (let j = 1; j < points.length; j++) {\n        const worldPosIndex = csUtils.transformWorldToIndex(\n          imageData,\n          points[j]\n        );\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        iMin = Math.min(iMin, worldPosIndex[0]);\n        iMax = Math.max(iMax, worldPosIndex[0]);\n\n        jMin = Math.min(jMin, worldPosIndex[1]);\n        jMax = Math.max(jMax, worldPosIndex[1]);\n\n        kMin = Math.min(kMin, worldPosIndex[2]);\n        kMax = Math.max(kMax, worldPosIndex[2]);\n      }\n\n      // Expand bounding box\n      const iDelta = 0.01 * (iMax - iMin);\n      const jDelta = 0.01 * (jMax - jMin);\n      const kDelta = 0.01 * (kMax - kMin);\n\n      iMin = Math.floor(iMin - iDelta);\n      iMax = Math.ceil(iMax + iDelta);\n      jMin = Math.floor(jMin - jDelta);\n      jMax = Math.ceil(jMax + jDelta);\n      kMin = Math.floor(kMin - kDelta);\n      kMax = Math.ceil(kMax + kDelta);\n\n      const boundsIJK = [\n        [iMin, iMax],\n        [jMin, jMax],\n        [kMin, kMax],\n      ] as [Types.Point2, Types.Point2, Types.Point2];\n\n      const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n      const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n\n      let curRow = 0;\n      let intersections = [];\n      let intersectionCounter = 0;\n      const pointsInShape = pointInShapeCallback(\n        imageData,\n        (pointLPS, pointIJK) => {\n          let result = true;\n          const point = viewport.worldToCanvas(pointLPS);\n          if (point[1] != curRow) {\n            intersectionCounter = 0;\n            curRow = point[1];\n            intersections = getIntersectionCoordinatesWithPolyline(\n              canvasCoordinates,\n              point,\n              [canvasPosEnd[0], point[1]]\n            );\n            intersections.sort(\n              (function (index) {\n                return function (a, b) {\n                  return a[index] === b[index]\n                    ? 0\n                    : a[index] < b[index]\n                    ? -1\n                    : 1;\n                };\n              })(0)\n            );\n          }\n          if (intersections.length && point[0] > intersections[0][0]) {\n            intersections.shift();\n            intersectionCounter++;\n          }\n          if (intersectionCounter % 2 === 0) {\n            result = false;\n          }\n          return result;\n        },\n        this.configuration.statsCalculator.statsCallback,\n        boundsIJK\n      );\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const modalityUnit = getModalityUnit(\n        metadata.Modality,\n        annotation.metadata.referencedImageId,\n        modalityUnitOptions\n      );\n\n      const stats = this.configuration.statsCalculator.getStatistics();\n\n      cachedStats[targetId] = {\n        Modality: metadata.Modality,\n        area,\n        mean: stats[1]?.value,\n        max: stats[0]?.value,\n        stdDev: stats[3]?.value,\n        statsArray: stats,\n        pointsInShape: pointsInShape,\n        areaUnit: getCalibratedAreaUnits(null, image),\n        modalityUnit,\n      };\n    }\n\n    this.triggerAnnotationModified(annotation, enabledElement);\n\n    annotation.invalidated = false;\n\n    return cachedStats;\n  };\n\n  _renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n    const data = annotation.data;\n    const targetId = this.getTargetId(viewport);\n\n    const styleSpecifier: AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n    if (!options.visibility) {\n      return;\n    }\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (!textLines || textLines.length === 0) {\n      return;\n    }\n\n    const canvasCoordinates = data.polyline.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n    if (!data.handles.textBox.hasMoved) {\n      const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n      data.handles.textBox.worldPosition =\n        viewport.canvasToWorld(canvasTextBoxCoords);\n    }\n\n    const textBoxPosition = viewport.worldToCanvas(\n      data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = '1';\n    const boundingBox = drawLinkedTextBox(\n      svgDrawingHelper,\n      annotation.annotationUID ?? '',\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      options\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nPlanarFreehandROITool.toolName = 'PlanarFreehandROI';\nexport default PlanarFreehandROITool;\n","import { Types } from '@cornerstonejs/core';\nimport { PlanarFreehandROITool } from '../../tools';\nimport { ToolGroupManager } from '../../store';\nimport { PlanarFreehandROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\n\nfunction shouldPreventInterpolation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  if (!annotation?.data?.polyline || knotsRatioPercentage <= 0) {\n    return true;\n  }\n\n  if (!enabledElement.viewport) {\n    return true;\n  }\n\n  const { renderingEngineId, viewportId, FrameOfReferenceUID } = enabledElement;\n  const toolGroup = ToolGroupManager.getToolGroupForViewport(\n    viewportId,\n    renderingEngineId\n  );\n\n  if (annotation.metadata.FrameOfReferenceUID !== FrameOfReferenceUID) {\n    return true;\n  }\n\n  if (!toolGroup) {\n    return true;\n  }\n\n  const toolInstance = toolGroup.getToolInstance(annotation.metadata.toolName);\n\n  // strategy to prevent non PlanarFreehandTool\n  if (!(toolInstance instanceof PlanarFreehandROITool)) {\n    return true;\n  }\n\n  return (\n    toolInstance.isDrawing ||\n    toolInstance.isEditingOpen ||\n    toolInstance.isEditingClosed\n  );\n}\n/**\n * Interpolates a given annotation from a given enabledElement.\n * It mutates annotation param.\n * The param knotsRatioPercentage defines the percentage of points to be considered as knots on the interpolation process.\n * Interpolation will be skipped in case: annotation is not present in enabledElement (or there is no toolGroup associated with it), related tool is being modified.\n */\nexport default function interpolateAnnotation(\n  enabledElement: Types.IEnabledElement,\n  annotation: PlanarFreehandROIAnnotation,\n  knotsRatioPercentage: number\n): boolean {\n  // prevent running while there is any tool annotation being modified\n  if (\n    shouldPreventInterpolation(enabledElement, annotation, knotsRatioPercentage)\n  ) {\n    return false;\n  }\n\n  const { viewport } = enabledElement;\n  // use only 2 dimensions on interpolation (what visually matters),\n  // otherwise a 3d interpolation might have a totally different output as it consider one more dimension.\n  const canvasPoints = annotation.data.polyline.map(viewport.worldToCanvas);\n  const interpolatedCanvasPoints = <Types.Point2[]>(\n    interpolateSegmentPoints(\n      canvasPoints,\n      0,\n      canvasPoints.length,\n      knotsRatioPercentage\n    )\n  );\n\n  if (interpolatedCanvasPoints === canvasPoints) {\n    return false;\n  }\n\n  annotation.data.polyline = interpolatedCanvasPoints.map(\n    viewport.canvasToWorld\n  );\n\n  return true;\n}\n","import interpolateAnnotation from './interpolateAnnotation';\n\nexport default {\n  interpolateAnnotation,\n};\n\nexport { interpolateAnnotation };\n","import { getEnabledElement } from '@cornerstonejs/core';\n\nconst state: Record<number, any> = {};\n\nfunction addToolState(element: HTMLDivElement, data): void {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  state[viewportId] = data;\n}\n\nfunction getToolState(element: HTMLDivElement): any {\n  const enabledElement = getEnabledElement(element);\n  const { viewportId } = enabledElement;\n  return state[viewportId];\n}\n\nexport { addToolState, getToolState };\n","import { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getToolState } from './state';\n\nexport const requestType = Enums.RequestType.Prefetch;\nexport const priority = 0;\n\nexport function range(lowEnd, highEnd) {\n  // Javascript version of Python's range function\n  // http://stackoverflow.com/questions/3895478/does-javascript-have-a-method-like-range-to-generate-an-array-based-on-suppl\n  lowEnd = Math.round(lowEnd) || 0;\n  highEnd = Math.round(highEnd) || 0;\n\n  const arr = [];\n  let c = highEnd - lowEnd + 1;\n\n  if (c <= 0) {\n    return arr;\n  }\n\n  while (c--) {\n    arr[c] = highEnd--;\n  }\n\n  return arr;\n}\n\nexport function nearestIndex(arr, x) {\n  // Return index of nearest values in array\n  // http://stackoverflow.com/questions/25854212/return-index-of-nearest-values-in-an-array\n  let low = 0;\n  let high = arr.length - 1;\n\n  arr.forEach((v, idx) => {\n    if (v < x) {\n      low = Math.max(idx, low);\n    } else if (v > x) {\n      high = Math.min(idx, high);\n    }\n  });\n\n  return { low, high };\n}\n\nexport function getStackData(element) {\n  const enabledElement = getEnabledElement(element);\n\n  if (!enabledElement) {\n    // Can be not valid if the data is changed part way through prefetch\n    return null;\n  }\n\n  const { viewport } = enabledElement;\n\n  if (!(viewport instanceof StackViewport)) {\n    throw new Error(\n      'stackPrefetch: element must be a StackViewport, VolumeViewport stackPrefetch not yet implemented'\n    );\n  }\n\n  return {\n    currentImageIdIndex: viewport.getCurrentImageIdIndex(),\n    imageIds: viewport.getImageIds(),\n  };\n}\n\nexport function getPromiseRemovedHandler(element) {\n  return function (e) {\n    const eventData = e.detail;\n\n    // When an imagePromise has been pushed out of the cache, re-add its index\n    // It to the indicesToRequest list so that it will be retrieved later if the\n    // CurrentImageIdIndex is changed to an image nearby\n    let stackData;\n\n    try {\n      // It will throw an exception in some cases (eg: thumbnails)\n      stackData = getStackData(element);\n    } catch (error) {\n      return;\n    }\n\n    if (!stackData || !stackData.imageIds || stackData.imageIds.length === 0) {\n      return;\n    }\n\n    const stack = stackData;\n    const imageIdIndex = stack.imageIds.indexOf(eventData.imageId);\n\n    // Make sure the image that was removed is actually in this stack\n    // Before adding it to the indicesToRequest array\n    if (imageIdIndex < 0) {\n      return;\n    }\n\n    const stackPrefetchData = getToolState(element);\n\n    if (\n      !stackPrefetchData ||\n      !stackPrefetchData.data ||\n      !stackPrefetchData.data.length\n    ) {\n      return;\n    }\n\n    stackPrefetchData.indicesToRequest.push(imageIdIndex);\n  };\n}\n\nexport const clearFromImageIds = (stack) => {\n  const imageIdSet = new Set<string>(stack.imageIds);\n  return (requestDetails) =>\n    requestDetails.type !== requestType ||\n    !imageIdSet.has(requestDetails.additionalDetails.imageId);\n};\n","import {\n  getEnabledElement,\n  StackViewport,\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  getPromiseRemovedHandler,\n  nearestIndex,\n  range,\n} from './stackPrefetchUtils';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Preserving the existing pool should be the default behaviour, as there might\n  // be a volume of the same series already being loaded in the pool, and we don't want\n  // to cancel it middle of the way when the other stack viewport mounts. Worst case scenario\n  // there will be a few extra images in the pool but by the time that their turn comes\n  // we will have already loaded the volume and it will get read from the CACHE,\n  // so who cares\n  preserveExistingPool: true,\n};\n\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\n\nfunction prefetch(element) {\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n  const stack = getStackData(element);\n\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array\n  stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n\n  indicesToRequestCopy.forEach(function (imageIdIndex) {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n\n  // Identify the nearest imageIdIndex to the currentImageIdIndex\n  const nearest = nearestIndex(\n    stackPrefetch.indicesToRequest,\n    stack.currentImageIdIndex\n  );\n\n  let imageId;\n  let nextImageIdIndex;\n  const preventCache = false;\n\n  function doneCallback(image) {\n    console.log('prefetch done: %s', image.imageId);\n    const imageIdIndex = stack.imageIds.indexOf(image.imageId);\n\n    removeFromList(imageIdIndex);\n  }\n\n  // Prefetch images around the current image (before and after)\n  let lowerIndex = nearest.low;\n  let higherIndex = nearest.high;\n  const imageIdsToPrefetch = [];\n\n  while (\n    lowerIndex >= 0 ||\n    higherIndex < stackPrefetch.indicesToRequest.length\n  ) {\n    const currentIndex = stack.currentImageIdIndex;\n    const shouldSkipLower =\n      currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n      configuration.maxImagesToPrefetch;\n    const shouldSkipHigher =\n      stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n      configuration.maxImagesToPrefetch;\n\n    const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n    const shouldLoadHigher =\n      !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n\n    if (!shouldLoadHigher && !shouldLoadLower) {\n      break;\n    }\n\n    if (shouldLoadLower) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n\n    if (shouldLoadHigher) {\n      nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n      imageId = stack.imageIds[nextImageIdIndex];\n      imageIdsToPrefetch.push(imageId);\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader.loadAndCacheImage(imageId, options);\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  imageIdsToPrefetch.forEach((imageId) => {\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\nfunction enable(element) {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = {\n    indicesToRequest: range(0, stack.imageIds.length - 1),\n    enabled: true,\n    direction: 1,\n  };\n\n  // Remove the currentImageIdIndex from the list to request\n  const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(\n    stack.currentImageIdIndex\n  );\n\n  stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n\n  addToolState(element, stackPrefetchData);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n}\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n    stackPrefetchData.enabled = false;\n\n    // Clear current prefetch requests from the requestPool\n    imageLoadPoolManager.clearRequestStack(requestType);\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\n\nexport default stackPrefetch;\n","import {\n  imageLoader,\n  Enums,\n  eventTarget,\n  imageLoadPoolManager,\n  cache,\n  getConfiguration as getCoreConfiguration,\n} from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport {\n  getStackData,\n  requestType,\n  priority,\n  clearFromImageIds,\n  getPromiseRemovedHandler,\n} from './stackPrefetchUtils';\nimport roundNumber from '../roundNumber';\n\nlet configuration = {\n  maxImagesToPrefetch: Infinity,\n  // Fetch up to 2 image before and after\n  minBefore: 2,\n  maxAfter: 2,\n  // Increment the cache size by 10 images\n  directionExtraImages: 10,\n  preserveExistingPool: false,\n};\n\nlet resetPrefetchTimeout;\n// Starting the prefetch quickly isn't an issue as the main image is already being\n// loaded, so a 5 ms prefetch delay is fine\nconst resetPrefetchDelay = 5;\n\n/**\n * Call this to enable stack context sensitive prefetch.  Should be called\n * before stack data is set in order to start prefetch after load first image.\n * This will add a STACK_NEW_IMAGE to detect when a new image is displayed, and then\n * update the prefetch stack.  The context sensitive prefetch reacts to the\n * initial display, or significant moves, the already loaded images, the\n * cache size and the direction of navigation.  The behaviour is:\n *\n * 1. On navigating to a new image initially, or one that is at a different position:\n *  * Fetch the next/previous 2 images\n * 2. If the user is navigating forward/backward by less than 5 images, then\n *  * Prefetch additional images in the direction of navigation, up to 100\n * 3. If all the images in a given prefetch have completed, then:\n *  * Use the last prefetched image size as an image size for the stack\n *  * Fetch up to 1/4 of the cache size images near the current image\n *\n * This is designed to:\n *   * Get nearby images immediately so that they are available for navigation\n *     * Under the assumption that users might click and view an image, then\n *       navigate to next/previous image to see the exact image they want\n *   * Not interfere with loading other viewports if they are still loading\n *     * Load priority is prefetch, and minimal images are requested initially\n *   * Load an entire series if it will fit in memory\n *     * Allows navigating to other parts of the series and display images immediately\n *   * Have images available for CINE/navigation in one direction even when\n *     there is more image data than will fit in memory.\n *     * Up to 100 images in the direction of travel will be prefetched\n *\n * @param element - to prefetch on\n */\nconst enable = (element): void => {\n  const stack = getStackData(element);\n\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  updateToolState(element);\n\n  prefetch(element);\n\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n  element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n  eventTarget.addEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n};\n\nfunction prefetch(element) {\n  const stack = getStackData(element);\n  if (!stack?.imageIds?.length) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  // Get the stackPrefetch tool data\n  const stackPrefetchData = getToolState(element);\n\n  if (!stackPrefetchData) {\n    return;\n  }\n\n  const stackPrefetch = stackPrefetchData || {};\n\n  // If all the requests are complete, disable the stackPrefetch tool\n  stackPrefetch.enabled &&= stackPrefetch.indicesToRequest?.length;\n\n  // Make sure the tool is still enabled\n  if (stackPrefetch.enabled === false) {\n    return;\n  }\n\n  // Remove an imageIdIndex from the list of indices to request\n  // This fires when the individual image loading deferred is resolved\n  function removeFromList(imageIdIndex) {\n    const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n\n    if (index > -1) {\n      // Don't remove last element if imageIdIndex not found\n      stackPrefetch.indicesToRequest.splice(index, 1);\n    }\n  }\n\n  // Remove all already cached images from the\n  // IndicesToRequest array.\n  const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n  const { currentImageIdIndex } = stack;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n\n    if (!imageId) {\n      return;\n    }\n\n    const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n    // For nearby objects, ensure the last accessed time is updated\n    // by using getImageLoadObject.\n    // For more distant objects, just check if available, but dont\n    // change the access time.\n    // This allows throwing data that hasn't been accessed and is not\n    // nearby.\n    const imageCached =\n      distance < 6\n        ? cache.getImageLoadObject(imageId)\n        : cache.isLoaded(imageId);\n\n    if (imageCached) {\n      // Already in cache\n      removeFromList(imageIdIndex);\n    }\n  });\n\n  // Stop here if there are no images left to request\n  // After those in the cache have been removed\n  if (!stackPrefetch.indicesToRequest.length) {\n    return;\n  }\n\n  // Clear the requestPool of prefetch requests, if needed.\n  if (!configuration.preserveExistingPool) {\n    imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n  }\n\n  function doneCallback(imageId) {\n    const imageIdIndex = stack.imageIds.indexOf(imageId);\n\n    removeFromList(imageIdIndex);\n    const image = cache.getCachedImageBasedOnImageURI(imageId);\n    const { stats } = stackPrefetch;\n    const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n    if (decodeTimeInMS) {\n      stats.imageIds.set(imageId, decodeTimeInMS);\n      stats.decodeTimeInMS += decodeTimeInMS;\n      const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n      stats.loadTimeInMS += loadTimeInMS;\n    }\n\n    if (!stackPrefetch.indicesToRequest.length) {\n      if (image?.sizeInBytes) {\n        const { sizeInBytes } = image;\n        const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n        if (!stackPrefetch.cacheFill) {\n          stats.initialTime = Date.now() - stats.start;\n          stats.initialSize = stats.imageIds.size;\n          updateToolState(element, usage);\n          prefetch(element);\n        } else if (stats.imageIds.size) {\n          stats.fillTime = Date.now() - stats.start;\n          const { size } = stats.imageIds;\n          stats.fillSize = size;\n          console.log(\n            'Done cache fill',\n            stats.fillTime,\n            'ms',\n            size,\n            'items',\n            'average total time',\n            roundNumber(stats.fillTime / size),\n            'ms',\n            'average load',\n            roundNumber(stats.loadTimeInMS / size),\n            'ms',\n            'average decode',\n            roundNumber(stats.decodeTimeInMS / size),\n            'ms'\n          );\n        }\n      }\n    }\n  }\n\n  const requestFn = (imageId, options) =>\n    imageLoader\n      .loadAndCacheImage(imageId, options)\n      .then(() => doneCallback(imageId));\n\n  const { useNorm16Texture } = getCoreConfiguration().rendering;\n\n  indicesToRequestCopy.forEach((imageIdIndex) => {\n    const imageId = stack.imageIds[imageIdIndex];\n    // IMPORTANT: Request type should be passed if not the 'interaction'\n    // highest priority will be used for the request type in the imageRetrievalPool\n    const options = {\n      targetBuffer: {\n        type: useNorm16Texture ? undefined : 'Float32Array',\n      },\n      preScale: {\n        enabled: true,\n      },\n      requestType,\n    };\n\n    imageLoadPoolManager.addRequest(\n      requestFn.bind(null, imageId, options),\n      requestType,\n      // Additional details\n      {\n        imageId,\n      },\n      priority\n      // addToBeginning\n    );\n  });\n}\n\nfunction onImageUpdated(e) {\n  // Start prefetching again (after a delay)\n  // When the user has scrolled to a new image\n  clearTimeout(resetPrefetchTimeout);\n  resetPrefetchTimeout = setTimeout(function () {\n    const element = e.target;\n\n    // If playClip is enabled and the user loads a different series in the viewport\n    // An exception will be thrown because the element will not be enabled anymore\n    try {\n      updateToolState(element);\n      prefetch(element);\n    } catch (error) {\n      return;\n    }\n  }, resetPrefetchDelay);\n}\n\n// Not a full signum, but good enough for direction.\nconst signum = (x) => (x < 0 ? -1 : 1);\n\nconst updateToolState = (element, usage?: number) => {\n  const stack = getStackData(element);\n  if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n    console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n    return;\n  }\n\n  const { currentImageIdIndex } = stack;\n  let { maxAfter = 2, minBefore = 2 } = configuration;\n  const { directionExtraImages = 10 } = configuration;\n  // Use the currentImageIdIndex from the stack as the initialImageIdIndex\n  const stackPrefetchData = getToolState(element) || {\n    indicesToRequest: [],\n    currentImageIdIndex,\n    stackCount: 0,\n    enabled: true,\n    direction: 1,\n    stats: {\n      start: Date.now(),\n      imageIds: new Map(),\n      decodeTimeInMS: 0,\n      loadTimeInMS: 0,\n      totalBytes: 0,\n    },\n  };\n  const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n  stackPrefetchData.direction = signum(delta);\n  stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n  stackPrefetchData.enabled = true;\n\n  if (stackPrefetchData.stackCount < 100) {\n    stackPrefetchData.stackCount += directionExtraImages;\n  }\n\n  if (Math.abs(delta) > maxAfter || !delta) {\n    // Not incrementing by 1, so stop increasing the data size\n    // TODO - consider reversing the CINE playback\n    stackPrefetchData.stackCount = 0;\n    if (usage) {\n      // The usage of the cache that this stack can use\n      const positionFraction = currentImageIdIndex / stack.imageIds.length;\n      minBefore = Math.ceil(usage * positionFraction);\n      maxAfter = Math.ceil(usage * (1 - positionFraction));\n      stackPrefetchData.cacheFill = true;\n    } else {\n      stackPrefetchData.cacheFill = false;\n    }\n  } else if (delta < 0) {\n    minBefore += stackPrefetchData.stackCount;\n    maxAfter = 0;\n  } else {\n    maxAfter += stackPrefetchData.stackCount;\n    minBefore = 0;\n  }\n\n  const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n\n  const maxIndex = Math.min(\n    stack.imageIds.length - 1,\n    currentImageIdIndex + maxAfter\n  );\n\n  // Order these correctly initially\n  const indicesToRequest = [];\n  for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n    indicesToRequest.push(i);\n  }\n  for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n    indicesToRequest.push(i);\n  }\n  stackPrefetchData.indicesToRequest = indicesToRequest;\n\n  addToolState(element, stackPrefetchData);\n};\n\nfunction disable(element) {\n  clearTimeout(resetPrefetchTimeout);\n  element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n\n  const promiseRemovedHandler = getPromiseRemovedHandler(element);\n\n  eventTarget.removeEventListener(\n    Enums.Events.IMAGE_CACHE_IMAGE_REMOVED,\n    promiseRemovedHandler\n  );\n\n  const stackPrefetchData = getToolState(element);\n  // If there is actually something to disable, disable it\n\n  if (stackPrefetchData && stackPrefetchData.data.length) {\n    stackPrefetchData.enabled = false;\n    // Don't worry about clearing the requests - there aren't that many too be bothersome\n  }\n}\n\nfunction getConfiguration() {\n  return configuration;\n}\n\nfunction setConfiguration(config) {\n  configuration = config;\n}\n\nconst stackContextPrefetch = {\n  enable,\n  disable,\n  getConfiguration,\n  setConfiguration,\n};\n\nexport default stackContextPrefetch;\n","import { VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { vec3 } from 'gl-matrix';\n\n// Todo: merge this utility functionality with Crosshair _jump\n/**\n * Uses the viewport's current camera to jump to a specific world coordinate\n * @param enabledElement - enabled element\n * @param jumpWorld - location in the world to jump to\n * @returns True if successful\n */\nexport default function jumpToWorld(\n  viewport: Types.IVolumeViewport,\n  jumpWorld: Types.Point3\n): true | undefined {\n  // if not instance of volumeViewport, return\n  if (!(viewport instanceof VolumeViewport)) {\n    return;\n  }\n\n  const { focalPoint } = viewport.getCamera();\n\n  const delta: Types.Point3 = [0, 0, 0];\n  vec3.sub(delta, jumpWorld, focalPoint);\n\n  _applyShift(viewport, delta);\n\n  return true;\n}\n\nfunction _applyShift(viewport, delta) {\n  const camera = viewport.getCamera();\n  const normal = camera.viewPlaneNormal;\n\n  const dotProd = vec3.dot(delta, normal);\n  const projectedDelta = vec3.fromValues(normal[0], normal[1], normal[2]);\n\n  vec3.scale(projectedDelta, projectedDelta, dotProd);\n\n  if (\n    Math.abs(projectedDelta[0]) > 1e-3 ||\n    Math.abs(projectedDelta[1]) > 1e-3 ||\n    Math.abs(projectedDelta[2]) > 1e-3\n  ) {\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newPosition: Types.Point3 = [0, 0, 0];\n\n    vec3.add(newFocalPoint, camera.focalPoint, projectedDelta);\n    vec3.add(newPosition, camera.position, projectedDelta);\n\n    viewport.setCamera({\n      focalPoint: newFocalPoint,\n      position: newPosition,\n    });\n    viewport.render();\n  }\n}\n","import { utilities, cache, Types } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nimport pointInShapeCallback from '../pointInShapeCallback';\n\n/**\n * Gets the scalar data for a series of time points for either a single\n * coordinate or a segmentation mask, it will return the an array of scalar\n * data for a single coordinate or an array of arrays for a segmentation.\n *\n * @param dynamicVolume - 4D volume to compute time point data from\n * @param options - frameNumbers: which frames to use as timepoints, if left\n * blank, gets data timepoints over all frames\n * maskVolumeId: segmentationId to get timepoint data of\n * imageCoordinate: world coordinate to get timepoint data of\n * @returns\n */\nfunction getDataInTime(\n  dynamicVolume: Types.IDynamicImageVolume,\n  options: {\n    frameNumbers?;\n    maskVolumeId?;\n    imageCoordinate?;\n  }\n): number[] | number[][] {\n  let dataInTime;\n\n  // if frameNumbers is not provided, all frames are selected\n  const frames = options.frameNumbers || [\n    ...Array(dynamicVolume.numTimePoints).keys(),\n  ];\n\n  // You only need to provide either maskVolumeId OR imageCoordinate.\n  // Throws error if neither maskVolumeId or imageCoordinate is given,\n  // throws error if BOTH maskVolumeId and imageCoordinate is given\n  if (!options.maskVolumeId && !options.imageCoordinate) {\n    throw new Error(\n      'You should provide either maskVolumeId or imageCoordinate'\n    );\n  }\n\n  if (options.maskVolumeId && options.imageCoordinate) {\n    throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n  }\n\n  if (options.maskVolumeId) {\n    const segmentationVolume = cache.getVolume(options.maskVolumeId);\n\n    const dataInTime = _getTimePointDataMask(\n      frames,\n      dynamicVolume,\n      segmentationVolume\n    );\n\n    return dataInTime;\n  }\n\n  if (options.imageCoordinate) {\n    const dataInTime = _getTimePointDataCoordinate(\n      frames,\n      options.imageCoordinate,\n      dynamicVolume\n    );\n\n    return dataInTime;\n  }\n\n  return dataInTime;\n}\n\nfunction _getTimePointDataCoordinate(frames, coordinate, volume) {\n  const { dimensions, imageData } = volume;\n  const index = imageData.worldToIndex(coordinate);\n\n  index[0] = Math.floor(index[0]);\n  index[1] = Math.floor(index[1]);\n  index[2] = Math.floor(index[2]);\n\n  if (!utilities.indexWithinDimensions(index, dimensions)) {\n    throw new Error('outside bounds');\n  }\n\n  // calculate offset for index\n  const yMultiple = dimensions[0];\n  const zMultiple = dimensions[0] * dimensions[1];\n  const allScalarData = volume.getScalarDataArrays();\n  const value = [];\n\n  frames.forEach((frame) => {\n    const activeScalarData = allScalarData[frame];\n    const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n    value.push(activeScalarData[scalarIndex]);\n  });\n\n  return value;\n}\n\nfunction _getTimePointDataMask(frames, dynamicVolume, segmentationVolume) {\n  const { imageData: maskImageData } = segmentationVolume;\n  const segScalarData = segmentationVolume.getScalarData();\n\n  const len = segScalarData.length;\n\n  // Pre-allocate memory for array\n  const nonZeroVoxelIndices = [];\n  nonZeroVoxelIndices.length = len;\n\n  // Get the index of every non-zero voxel in mask\n  let actualLen = 0;\n  for (let i = 0, len = segScalarData.length; i < len; i++) {\n    if (segScalarData[i] !== 0) {\n      nonZeroVoxelIndices[actualLen++] = i;\n    }\n  }\n\n  // Trim the array to actual size\n  nonZeroVoxelIndices.length = actualLen;\n\n  const dynamicVolumeScalarDataArray = dynamicVolume.getScalarDataArrays();\n  const values = [];\n  const isSameVolume =\n    dynamicVolumeScalarDataArray[0].length === len &&\n    JSON.stringify(dynamicVolume.spacing) ===\n      JSON.stringify(segmentationVolume.spacing);\n\n  // if the segmentation mask is the same size as the dynamic volume (one frame)\n  // means we can just return the scalar data for the non-zero voxels\n  if (isSameVolume) {\n    for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n      const indexValues = [];\n      frames.forEach((frame) => {\n        const activeScalarData = dynamicVolumeScalarDataArray[frame];\n        indexValues.push(activeScalarData[nonZeroVoxelIndices[i]]);\n      });\n      values.push(indexValues);\n    }\n\n    return values;\n  }\n\n  // In case that the segmentation mask is not the same size as the dynamic volume (one frame)\n  // then we need to consider each voxel in the segmentation mask and check if it\n  // overlaps with the other volume, and if so we need to average the values of the\n  // overlapping voxels.\n  const callback = ({ pointLPS: segPointLPS, value: segValue }) => {\n    // see if the value is non-zero\n    if (segValue === 0) {\n      // not interested\n      return;\n    }\n\n    // Then for each non-zero voxel in the segmentation mask, we should\n    // again perform the pointInShapeCallback to run the averaging callback\n    // function to get the average value of the overlapping voxels.\n    const overlapIJKMinMax = getVoxelOverlap(\n      dynamicVolume.imageData,\n      dynamicVolume.dimensions,\n      dynamicVolume.spacing,\n      segPointLPS\n    );\n\n    // count represents the number of voxels of the dynamic volume that represents\n    // one voxel of the segmentation mask\n    let count = 0;\n    const perFrameSum = new Map();\n\n    // Pre-initialize the Map\n    frames.forEach((frame) => perFrameSum.set(frame, 0));\n\n    const averageCallback = ({ index }) => {\n      for (let i = 0; i < frames.length; i++) {\n        const value = dynamicVolumeScalarDataArray[i][index];\n        const frame = frames[i];\n        perFrameSum.set(frame, perFrameSum.get(frame) + value);\n      }\n      count++;\n    };\n\n    pointInShapeCallback(\n      dynamicVolume.imageData,\n      () => true,\n      averageCallback,\n      overlapIJKMinMax\n    );\n\n    // average the values\n    const averageValues = [];\n    perFrameSum.forEach((sum) => {\n      averageValues.push(sum / count);\n    });\n\n    values.push(averageValues);\n  };\n\n  // Since we have the non-zero voxel indices of the segmentation mask,\n  // we theoretically can use them, however, we kind of need to compute the\n  // pointLPS for each of the non-zero voxel indices, which is a bit of a pain.\n  // Todo: consider using the nonZeroVoxelIndices to compute the pointLPS\n  pointInShapeCallback(maskImageData, () => true, callback);\n\n  return values;\n}\n\nexport default getDataInTime;\n","import { Enums, Types } from '@cornerstonejs/core';\n\n/**\n * Gets the scalar data for a series of time frames from a 4D volume, returns an\n * array of scalar data after performing AVERAGE, SUM or SUBTRACT to be used to\n * create a 3D volume\n *\n * @param dynamicVolume4D - volume to compute time frame data from\n * @param operation - operation to perform on time frame data, operations include\n * SUM, AVERAGE, and SUBTRACT (can only be used with 2 time frames provided)\n * @param frameNumbers - an array of frame indices to perform the operation on, if\n * left empty, all frames will be used\n * @returns\n */\nfunction generateImageFromTimeData(\n  dynamicVolume: Types.IDynamicImageVolume,\n  operation: string,\n  frameNumbers?: number[]\n) {\n  // If no time frames provided, use all time frames\n  const frames = frameNumbers || [...Array(dynamicVolume.numTimePoints).keys()];\n  const numFrames = frames.length;\n\n  if (frames.length <= 1) {\n    throw new Error('Please provide two or more time points');\n  }\n\n  // Gets scalar data for all time frames\n  const typedArrays = dynamicVolume.getScalarDataArrays();\n\n  const arrayLength = typedArrays[0].length;\n  const finalArray = new Float32Array(arrayLength);\n\n  if (operation === Enums.DynamicOperatorType.SUM) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.SUBTRACT) {\n    if (frames.length > 2) {\n      throw new Error('Please provide only 2 time points for subtraction.');\n    }\n    for (let j = 0; j < arrayLength; j++) {\n      finalArray[j] += typedArrays[frames[0]][j] - typedArrays[frames[1]][j];\n    }\n    return finalArray;\n  }\n\n  if (operation === Enums.DynamicOperatorType.AVERAGE) {\n    for (let i = 0; i < numFrames; i++) {\n      const currentArray = typedArrays[frames[i]];\n      for (let j = 0; j < arrayLength; j++) {\n        finalArray[j] += currentArray[j];\n      }\n    }\n    for (let k = 0; k < arrayLength; k++) {\n      finalArray[k] = finalArray[k] / numFrames;\n    }\n    return finalArray;\n  }\n}\n\nexport default generateImageFromTimeData;\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\n/**\n * Gets a point from an array of numbers given its index\n * @param points array of number, each point defined by three consecutive numbers\n * @param idx index of the point to retrieve\n * @returns\n */\nexport function getPoint(points, idx) {\n  if (idx < points.length / 3) {\n    return [points[idx * 3], points[idx * 3 + 1], points[idx * 3 + 2]];\n  }\n}\n\n/**\n * Extract contour point sets from the outline of a poly data actor\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPointIndexes(polyData: vtkPolyData) {\n  const linesData = polyData.getLines().getData();\n  let idx = 0;\n  const lineSegments = new Map<number, number[]>();\n\n  // Populate lineSegments map\n  while (idx < linesData.length) {\n    const segmentSize = linesData[idx++];\n    const segment = [];\n    for (let i = 0; i < segmentSize; i++) {\n      segment.push(linesData[idx + i]);\n    }\n    lineSegments.set(segment[0], segment);\n    idx += segmentSize;\n  }\n\n  const contours = [];\n\n  // Function to find an available starting point\n  const findStartingPoint = (map) => {\n    for (const [key, value] of map.entries()) {\n      if (value !== undefined) {\n        return key;\n      }\n    }\n    return -1;\n  };\n\n  // Build contours\n  let startPoint = findStartingPoint(lineSegments);\n  while (startPoint !== -1) {\n    const contour = [startPoint];\n    while (lineSegments.has(startPoint)) {\n      const nextPoint = lineSegments.get(startPoint)[1];\n      if (lineSegments.has(nextPoint)) {\n        contour.push(nextPoint);\n      }\n      lineSegments.delete(startPoint);\n      startPoint = nextPoint;\n    }\n    contours.push(contour);\n    startPoint = findStartingPoint(lineSegments);\n  }\n\n  return contours.length ? contours : undefined;\n}\n\n/**\n * Extract contour points from a poly data object\n * @param polyData - vtk polyData\n * @returns\n */\nexport function getPolyDataPoints(polyData: vtkPolyData) {\n  const contoursIndexes = getPolyDataPointIndexes(polyData);\n  if (!contoursIndexes) {\n    return;\n  }\n\n  const rawPointsData = polyData.getPoints().getData();\n  return contoursIndexes.map((contourIndexes) =>\n    contourIndexes.map((index) => getPoint(rawPointsData, index))\n  );\n}\n","/**\n * Specify the position of the text/ticks.\n * Left/Right are the valid options for a vertical colorbars and Top/Bottom\n * for the horizontal ones.\n */\nexport enum ColorbarRangeTextPosition {\n  Top = 'top',\n  Left = 'left',\n  Bottom = 'bottom',\n  Right = 'right',\n}\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst isRangeValid = (range: ColorbarImageRange) => {\n  return range && range.upper > range.lower;\n};\n\nexport { isRangeValid as default, isRangeValid };\n","import type { ColorbarImageRange } from '../types/ColorbarImageRange';\n\nconst areColorbarRangesEqual = (\n  a: ColorbarImageRange,\n  b: ColorbarImageRange\n) => {\n  return !!a && !!b && a.lower === b.lower && a.upper === b.upper;\n};\n\nexport { areColorbarRangesEqual as default, areColorbarRangesEqual };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst isColorbarSizeValid = (size: ColorbarSize) => {\n  return !!size && size.width > 0 && size.height > 0;\n};\n\nexport { isColorbarSizeValid as default, isColorbarSizeValid };\n","import type { ColorbarSize } from '../types/ColorbarSize';\n\nconst areColorbarSizesEqual = (a: ColorbarSize, b: ColorbarSize) => {\n  return !!a && !!b && a.width === b.width && a.height === b.height;\n};\n\nexport { areColorbarSizesEqual as default, areColorbarSizesEqual };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { utilities } from '@cornerstonejs/core';\nimport interpolateVec3 from '../../math/vec3/interpolateVec3';\nimport { ColorbarCanvasProps } from './types/ColorbarCanvasProps';\nimport type { ColorbarImageRange, ColorbarVOIRange } from './types';\nimport type { ColorbarSize } from './types/ColorbarSize';\nimport {\n  isRangeValid,\n  areColorbarRangesEqual,\n  isColorbarSizeValid,\n  areColorbarSizesEqual,\n} from './common';\n\nconst { clamp } = utilities;\n\n/**\n * Canvas referenced by the color bar where the colormap is rendered. It may\n * show the full image range or only the VOI range.\n */\nclass ColorbarCanvas {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _colormap: IColorMapPreset;\n  private _showFullImageRange: boolean;\n\n  constructor(props: ColorbarCanvasProps) {\n    ColorbarCanvas.validateProps(props);\n\n    const {\n      colormap,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    this._colormap = colormap;\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._showFullImageRange = showFullPixelValueRange;\n    this._canvas = this._createRootElement(size);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get colormap(): IColorMapPreset {\n    return this._colormap;\n  }\n\n  public set colormap(colormap: IColorMapPreset) {\n    this._colormap = colormap;\n    this.render();\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  public get imageRange(): ColorbarImageRange {\n    return { ...this._imageRange };\n  }\n\n  public set imageRange(imageRange: ColorbarImageRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  public get voiRange(): ColorbarVOIRange {\n    return { ...this._voiRange };\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  public get showFullImageRange(): boolean {\n    return this._showFullImageRange;\n  }\n\n  public set showFullImageRange(showFullImageRange: boolean) {\n    if (showFullImageRange === this._showFullImageRange) {\n      return;\n    }\n\n    this._showFullImageRange = showFullImageRange;\n    this.render();\n  }\n\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  public dispose() {\n    const { _canvas: canvas } = this;\n    const { parentElement } = canvas;\n\n    parentElement?.removeChild(canvas);\n  }\n\n  private static validateProps(props: ColorbarCanvasProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createRootElement(size: ColorbarSize) {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      position: 'absolute',\n      top: '0',\n      left: '0',\n      pointerEvents: 'none',\n      boxSizing: 'border-box',\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  private render(): void {\n    if (!this._canvas.isConnected) {\n      return;\n    }\n\n    const { _colormap: colormap } = this;\n    const { RGBPoints: rgbPoints } = colormap;\n    const colorsCount = rgbPoints.length / 4;\n\n    // Returns a color point from rgbPoints. Each point has position, red,\n    // green and blue components which means each point has an offset equal\n    // to `4 * index`\n    const getColorPoint = (index) => {\n      const offset = 4 * index;\n\n      // It can get out of bounds when `voiRange.upper` is smaller than\n      // `imageRange.upper`. It's also checking if is smaller than zero\n      // for safety only because that should never happens.\n      if (index < 0 || index >= colorsCount) {\n        return;\n      }\n\n      return {\n        index,\n        position: rgbPoints[offset],\n        color: [\n          rgbPoints[offset + 1],\n          rgbPoints[offset + 2],\n          rgbPoints[offset + 3],\n        ],\n      };\n    };\n\n    const { width, height } = this._canvas;\n    const canvasContext = this._canvas.getContext('2d');\n    const isHorizontal = width > height;\n    const maxValue = isHorizontal ? width : height;\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullImageRange ? this._imageRange : { ...voiRange };\n\n    const { windowWidth } = utilities.windowLevel.toWindowLevel(\n      voiRange.lower,\n      voiRange.upper\n    );\n\n    let previousColorPoint = undefined;\n    let currentColorPoint = getColorPoint(0);\n\n    // Starts from `range.lower` incrementing by incRawPixelValue on each iteration\n    const incRawPixelValue = (range.upper - range.lower) / (maxValue - 1);\n    let rawPixelValue = range.lower;\n\n    for (let i = 0; i < maxValue; i++) {\n      const tVoiRange = (rawPixelValue - voiRange.lower) / windowWidth;\n\n      // Find the color in a linear way (O(n) complexity).\n      // currentColorPoint shall move to the next color until tVoiRange is smaller\n      // than or equal to next color position.\n      if (currentColorPoint) {\n        for (let i = currentColorPoint.index; i < colorsCount; i++) {\n          if (tVoiRange <= currentColorPoint.position) {\n            break;\n          }\n\n          previousColorPoint = currentColorPoint;\n          currentColorPoint = getColorPoint(i + 1);\n        }\n      }\n\n      let normColor;\n\n      // For:\n      //   - firstColorPoint = getColorPoint(0)\n      //   - secondColorPoint = getColorPoint(1)\n      //   - lastColorPoint = getColorPoint(colorsCount - 1)\n      // Then\n      //   - previousColorPoint shall be undefined when tVoiRange < firstColorPoint.position\n      //   - currentColorPoint shall be undefined when tVoiRange > lastColorPoint.position\n      //   - previousColorPoint and currentColorPoint will be defined when\n      //     currentColorPoint.position is between secondColorPoint.position and\n      //     lastColorPoint.position.\n      if (!previousColorPoint) {\n        normColor = [...currentColorPoint.color];\n      } else if (!currentColorPoint) {\n        normColor = [...previousColorPoint.color];\n      } else {\n        const tColorRange =\n          (tVoiRange - previousColorPoint.position) /\n          (currentColorPoint.position - previousColorPoint.position);\n\n        normColor = interpolateVec3(\n          previousColorPoint.color,\n          currentColorPoint.color,\n          tColorRange\n        );\n      }\n\n      const color = normColor.map((color) =>\n        clamp(Math.round(color * 255), 0, 255)\n      );\n\n      canvasContext.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;\n\n      if (isHorizontal) {\n        canvasContext.fillRect(i, 0, 1, height);\n      } else {\n        canvasContext.fillRect(0, height - i - 1, width, 1);\n      }\n\n      rawPixelValue += incRawPixelValue;\n    }\n  }\n}\n\nexport { ColorbarCanvas as default, ColorbarCanvas };\n","/**\n * Linear interpolation between two vec3.\n * Can be used, for example, to interpolate between two RGB colors.\n * @param a - First vec3\n * @param b - Second vec3\n * @param t - Time \"t\".\n *   - Vector A is returned for values smaller than or equel to 0.\n *   - Vector B is returned for values greater than or equal to 1.\n *   - An interpolation between vectors A and B is returned otherwise.\n * @returns\n */\nconst interpolateVec3 = (a, b, t) => {\n  return [\n    a[0] * (1 - t) + b[0] * t,\n    a[1] * (1 - t) + b[1] * t,\n    a[2] * (1 - t) + b[2] * t,\n  ];\n};\n\nexport { interpolateVec3 as default, interpolateVec3 };\n","import type {\n  ColorbarImageRange,\n  ColorbarVOIRange,\n  ColorbarSize,\n  ColorbarTicksProps,\n} from './types';\nimport {\n  isColorbarSizeValid,\n  isRangeValid,\n  areColorbarRangesEqual,\n  areColorbarSizesEqual,\n} from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\n\nconst DEFAULTS = {\n  FONT: '10px Arial',\n  COLOR: 'white',\n  TICK_SIZE: 5,\n  TICK_WIDTH: 1,\n  TICK_LABEL_MARGIN: 3,\n  MAX_NUM_TICKS: 8,\n\n  // Must start with 1 and end with 10\n  TICKS_STEPS: [1, 2.5, 5, 10],\n};\n\nclass ColorbarTicks {\n  private _canvas: HTMLCanvasElement;\n  private _imageRange: ColorbarImageRange;\n  private _voiRange: ColorbarVOIRange;\n  private _color: string;\n  private _tickSize: number;\n  private _tickWidth: number;\n  private _labelMargin: number;\n  private _maxNumTicks: number;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n  private _showFullPixelValueRange: boolean;\n  private _font: string;\n\n  constructor(props: ColorbarTicksProps) {\n    ColorbarTicks.validateProps(props);\n\n    const {\n      top = 0,\n      left = 0,\n      size = { width: 20, height: 100 },\n      imageRange = { lower: 0, upper: 1 },\n      voiRange = { lower: 0, upper: 1 },\n      ticks: ticksProps,\n      container,\n      showFullPixelValueRange = false,\n    } = props;\n\n    const { style: ticksStyle, position: rangeTextPosition } = ticksProps ?? {};\n\n    this._imageRange = imageRange;\n    this._voiRange = voiRange;\n    this._font = ticksStyle?.font ?? DEFAULTS.FONT;\n    this._color = ticksStyle?.color ?? DEFAULTS.COLOR;\n    this._tickSize = ticksStyle?.tickSize ?? DEFAULTS.TICK_SIZE;\n    this._tickWidth = ticksStyle?.tickWidth ?? DEFAULTS.TICK_WIDTH;\n    this._labelMargin = ticksStyle?.labelMargin ?? DEFAULTS.TICK_LABEL_MARGIN;\n    this._maxNumTicks = ticksStyle?.maxNumTicks ?? DEFAULTS.MAX_NUM_TICKS;\n    this._rangeTextPosition =\n      rangeTextPosition ?? ColorbarRangeTextPosition.Right;\n    this._showFullPixelValueRange = showFullPixelValueRange;\n    this._canvas = this._createCanvasElement(size, top, left);\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  public get size(): ColorbarSize {\n    const { width, height } = this._canvas;\n    return { width, height };\n  }\n\n  public set size(size: ColorbarSize) {\n    const { _canvas: canvas } = this;\n\n    if (!isColorbarSizeValid(size) || areColorbarSizesEqual(canvas, size)) {\n      return;\n    }\n\n    this._setCanvasSize(canvas, size);\n    this.render();\n  }\n\n  /**\n   * Canvas top position (pixels)\n   */\n  public get top(): number {\n    return Number.parseInt(this._canvas.style.top);\n  }\n\n  /**\n   * Change the canvas top position (pixels)\n   */\n  public set top(top: number) {\n    const { _canvas: canvas } = this;\n    const currentTop = this.top;\n\n    if (top === currentTop) {\n      return;\n    }\n\n    canvas.style.top = `${top}px`;\n    this.render();\n  }\n\n  /**\n   * Canvas left position (pixels)\n   */\n  public get left(): number {\n    return Number.parseInt(this._canvas.style.left);\n  }\n\n  /**\n   * Change the canvas left position (pixels)\n   */\n  public set left(left: number) {\n    const { _canvas: canvas } = this;\n    const currentLeft = this.left;\n\n    if (left === currentLeft) {\n      return;\n    }\n\n    canvas.style.left = `${left}px`;\n    this.render();\n  }\n\n  /**\n   * Image range\n   */\n  public get imageRange() {\n    return { ...this._imageRange };\n  }\n\n  /**\n   * Set the image range that should goes from minPixelValue to maxPixelValue\n   */\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(imageRange) ||\n      areColorbarRangesEqual(imageRange, this._imageRange)\n    ) {\n      return;\n    }\n\n    this._imageRange = imageRange;\n    this.render();\n  }\n\n  /**\n   * VOI range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public get voiRange() {\n    return { ...this._voiRange };\n  }\n\n  /**\n   * Set the VOI Range\n   * (lower: wc - ww / 2, upper: wc + ww / 2)\n   */\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, this._voiRange)\n    ) {\n      return;\n    }\n\n    this._voiRange = voiRange;\n    this.render();\n  }\n\n  /**\n   * Tick size (pixels)\n   */\n  public get tickSize(): number {\n    return this._tickSize;\n  }\n\n  /**\n   * Set the tick size\n   */\n  public set tickSize(tickSize: number) {\n    if (tickSize === this._tickSize) {\n      return;\n    }\n\n    this._tickSize = tickSize;\n    this.render();\n  }\n\n  /**\n   * Tick width (pixels)\n   */\n  public get tickWidth(): number {\n    return this._tickWidth;\n  }\n\n  /**\n   * Set the tick width. This width is used as `lineWidth` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineWidth\n   */\n  public set tickWidth(tickWidth: number) {\n    if (tickWidth === this._tickWidth) {\n      return;\n    }\n\n    this._tickWidth = tickWidth;\n    this.render();\n  }\n\n  /**\n   * Color used for ticks and labels.\n   */\n  public get color(): string {\n    return this._color;\n  }\n\n  /**\n   * Set the color used for ticks and labels. This color is used as `strokeStyle`\n   * and `fillStyle` by CanvasRenderingContext2D.\n   *\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle\n   */\n  public set color(color: string) {\n    if (color === this._color) {\n      return;\n    }\n\n    this._color = color;\n    this.render();\n  }\n\n  /**\n   * Return `true` when the ticks displayed are in the range from `imageRange.lower`\n   * to `imageRange.upper` or `false` when they are in the range from `voiRange.lower`\n   * to `voiRange.upper`\n   */\n  public get showFullPixelValueRange(): boolean {\n    return this._showFullPixelValueRange;\n  }\n\n  /**\n   * Change which range should be used when rendering the ticks. Set it to `true`\n   * to show from `imageRange.lower` to `imageRange.upper` or `false` show from\n   * `voiRange.lower` to `voiRange.upper`.\n   */\n  public set showFullPixelValueRange(showFullRange: boolean) {\n    if (showFullRange === this._showFullPixelValueRange) {\n      return;\n    }\n\n    this._showFullPixelValueRange = showFullRange;\n    this.render();\n  }\n\n  /**\n   * Ticks visibility\n   */\n  public get visible() {\n    return this._canvas.style.display === 'block';\n  }\n\n  /**\n   * Show/Hide the ticks\n   */\n  public set visible(visible) {\n    if (visible === this.visible) {\n      return;\n    }\n\n    this._canvas.style.display = visible ? 'block' : 'none';\n\n    if (visible) {\n      this.render();\n    }\n  }\n\n  /**\n   * Append the canvas to its parent element\n   * @param container - HTML element where the canvas should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    container.appendChild(this._canvas);\n    this.render();\n  }\n\n  private static validateProps(props: ColorbarTicksProps) {\n    const { size, imageRange, voiRange } = props;\n\n    if (size && !isColorbarSizeValid(size)) {\n      throw new Error('Invalid \"size\"');\n    }\n\n    if (imageRange && !isRangeValid(imageRange)) {\n      throw new Error('Invalid \"imageRange\"');\n    }\n\n    if (voiRange && !isRangeValid(voiRange)) {\n      throw new Error('Invalid \"voiRange\"');\n    }\n  }\n\n  private _setCanvasSize(canvas: HTMLCanvasElement, size: ColorbarSize) {\n    const { width, height } = size;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    Object.assign(canvas.style, {\n      width: `${width}px`,\n      height: `${height}px`,\n    });\n  }\n\n  private _createCanvasElement(\n    size: ColorbarSize,\n    top: number,\n    left: number\n  ): HTMLCanvasElement {\n    const canvas = document.createElement('canvas');\n\n    Object.assign(canvas.style, {\n      display: 'none',\n      position: 'absolute',\n      boxSizing: 'border-box',\n      top: `${top}px`,\n      left: `${left}px`,\n    });\n\n    this._setCanvasSize(canvas, size);\n\n    return canvas;\n  }\n\n  /**\n   * Calculate how many ticks can be displayed on the screen based on the\n   * pre-defined steps (`TICKS_STEPS`) as follow:\n   *   1. Calculate what should be the step (`roughStep`) based on the range and\n   *   the number of desired steps (`maxNumTicks`).\n   *   2. Find a number power of 10 (eg: 0.1, 1, 10, 100, etc.) that can be used\n   *   to multiply `roughStep` and return a number between 1 and 10 which is\n   *   called `roughtStepNormalized`.\n   *   3. Find in the TICKS_STEPS array a number that is bigger than or equal to\n   *   the `roughtStepNormalized` value (`normalizedStep`).\n   *   4. Multiply the `normalizedStep` to move it to the real range.\n   *\n   * @param range - Range with \"lower\" and \"upper\" values\n   */\n  private _getTicks(range) {\n    const { lower, upper } = range;\n    const rangeValue = upper - lower;\n\n    // First approximation based on the max number of ticks\n    const roughStep = rangeValue / (this._maxNumTicks - 1);\n\n    // Normalize rough step to find the normalized one that fits best\n    const stepPower = Math.pow(\n      10,\n      -Math.floor(Math.log10(Math.abs(roughStep)))\n    );\n\n    // Get a number between 1 and 10\n    const roughtStepNormalized = roughStep * stepPower;\n\n    // Find a normalize step that is greater than or equal to `roughtStepNormalized`\n    const normalizedStep = DEFAULTS.TICKS_STEPS.find(\n      (n) => n >= roughtStepNormalized\n    );\n\n    // Move `normalizedStep` to the real range\n    const step = normalizedStep / stepPower;\n\n    // Determine the scale limits based on the chosen step.\n    const scaleMax = Math.ceil(upper / step) * step;\n    const scaleMin = Math.floor(lower / step) * step;\n\n    // Find a possible tick values for the `step` computed\n    const ticksCount = Math.round((scaleMax - scaleMin) / step) + 1;\n    const ticks = [];\n\n    for (let i = 0; i < ticksCount; i++) {\n      ticks.push(scaleMin + i * step);\n    }\n\n    return { scaleMin, scaleMax, step, ticks };\n  }\n\n  private _getLeftTickInfo({ position, labelMeasure }) {\n    const { width } = this._canvas;\n    const labelX =\n      width - this.tickSize - labelMeasure.width - this._labelMargin;\n    const labelPoint = [labelX, position];\n    const tickPoints = {\n      start: [width - this._tickSize, position],\n      end: [width, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getRightTickInfo({ position }) {\n    const labelPoint = [this._tickSize + this._labelMargin, position];\n    const tickPoints = {\n      start: [0, position],\n      end: [this._tickSize, position],\n    };\n\n    return { labelPoint, tickPoints };\n  }\n\n  private _getTopTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private _getBottomTickInfo({ position, labelMeasure }) {\n    throw new Error('Not implemented');\n  }\n\n  private render() {\n    const { _canvas: canvas } = this;\n\n    if (!canvas.isConnected || !this.visible) {\n      return;\n    }\n\n    const { width, height } = canvas;\n    const isHorizontal = width >= height;\n    const maxCanvasPixelValue = isHorizontal ? width : height;\n    const canvasContext = canvas.getContext('2d');\n    const { _voiRange: voiRange } = this;\n    const range = this._showFullPixelValueRange\n      ? this._imageRange\n      : { ...voiRange };\n    const rangeWidth = range.upper - range.lower;\n    const { ticks } = this._getTicks(range);\n\n    canvasContext.clearRect(0, 0, width, height);\n    canvasContext.font = this._font;\n    canvasContext.textBaseline = 'middle';\n    canvasContext.fillStyle = this._color;\n    canvasContext.strokeStyle = this._color;\n    canvasContext.lineWidth = this.tickWidth;\n\n    ticks.forEach((tick) => {\n      let position = Math.round(\n        maxCanvasPixelValue * ((tick - range.lower) / rangeWidth)\n      );\n\n      // Zero at the bottom and max at the top on vertical colorbars\n      if (!isHorizontal) {\n        position = height - position;\n      }\n\n      if (position < 0 || position > maxCanvasPixelValue) {\n        return;\n      }\n\n      const label = tick.toString();\n      const labelMeasure = canvasContext.measureText(label);\n      let tickInfo;\n\n      if (isHorizontal) {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Top) {\n          tickInfo = this._getTopTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getBottomTickInfo({ position, labelMeasure });\n        }\n      } else {\n        if (this._rangeTextPosition === ColorbarRangeTextPosition.Left) {\n          tickInfo = this._getLeftTickInfo({ position, labelMeasure });\n        } else {\n          tickInfo = this._getRightTickInfo({ position });\n        }\n      }\n\n      const { labelPoint, tickPoints } = tickInfo;\n      const { start: tickStart, end: tickEnd } = tickPoints;\n\n      canvasContext.beginPath();\n      canvasContext.moveTo(tickStart[0], tickStart[1]);\n      canvasContext.lineTo(tickEnd[0], tickEnd[1]);\n      canvasContext.fillText(label, labelPoint[0], labelPoint[1]);\n      canvasContext.stroke();\n\n      return position;\n    });\n  }\n}\n\nexport { ColorbarTicks as default, ColorbarTicks };\n","import type { WidgetProps, WidgetSize } from './types';\n\n/**\n * Base class for any widget that can be added to cornerstone. Currently it is\n * responsible only for holding the `rootElement`, contains a method that allows\n * adding it to the DOM and it also listens to container's size changes when the\n * widget is already added to the DOM. `dispose` must be called to destroy the\n * widget because it removes the widget from the DOM and stop listening to\n * container changes.\n *\n * You can apply some styles to widgets using the widget id or the `widget` class.\n *\n * Example:\n *   type ColorPickerProps = WidgetProps & {\n *     selectedColor: string;\n *   }\n *\n *   class ColorPicker extends Widget {\n *     constructor(props: ColorPickerProps) {\n *       super(props);\n *       // [code]\n *     }\n *\n *     public show() {\n *       console.log('Show color picker');\n *     }\n *\n *     protected containerResized() {\n *       console.log('New container size: ', this.containerSize);\n *     }\n *   }\n *\n *   const colorPicker = new ColorPicker({\n *     container: document.body,\n *     selectedColor: '#000';\n *   });\n *\n *   // another way to add the color picker to the DOM\n *   colorPicker.appendTo(document.body)\n *\n *   // Show color picker\n *   colorPicker.show();\n */\nabstract class Widget {\n  private _id: string;\n  private _rootElement: HTMLElement;\n  private _containerSize: WidgetSize;\n  private _containerResizeObserver: ResizeObserver;\n\n  constructor({ id, container }: WidgetProps) {\n    this._id = id;\n    this._containerSize = { width: 0, height: 0 };\n    this._rootElement = this.createRootElement(id);\n    this._containerResizeObserver = new ResizeObserver(\n      this._containerResizeCallback\n    );\n\n    if (container) {\n      this.appendTo(container);\n    }\n  }\n\n  /**\n   * Widget id\n   */\n  public get id() {\n    return this._id;\n  }\n\n  /**\n   * Widget's root element\n   */\n  public get rootElement(): HTMLElement {\n    return this._rootElement;\n  }\n\n  /**\n   * Append the widget to a parent element\n   * @param container - HTML element where the widget should be added to\n   */\n  public appendTo(container: HTMLElement) {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement: currentContainer } = rootElement;\n\n    if (!container || container === currentContainer) {\n      return;\n    }\n\n    if (currentContainer) {\n      resizeObserver.unobserve(currentContainer);\n    }\n\n    container.appendChild(rootElement);\n    resizeObserver.observe(container);\n  }\n\n  /**\n   * Removes the widget from the DOM and stop listening to DOM events\n   */\n  public destroy() {\n    const {\n      _rootElement: rootElement,\n      _containerResizeObserver: resizeObserver,\n    } = this;\n    const { parentElement } = rootElement;\n\n    parentElement?.removeChild(rootElement);\n    resizeObserver.disconnect();\n  }\n\n  protected get containerSize(): WidgetSize {\n    // Returns a copy to prevent any external change\n    return { ...this._containerSize };\n  }\n\n  /**\n   * Creates the root element which is a div by default\n   * @param id - Root element id\n   * @returns A new HTML element where all other elements should be added to\n   */\n  protected createRootElement(id: string): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    rootElement.id = id;\n    rootElement.classList.add('widget');\n\n    Object.assign(rootElement.style, {\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  /**\n   * Method called every time widget's container is resize giving the\n   * opportunity to children classes to act when that happens.\n   */\n  protected onContainerResize() {\n    // no-op\n  }\n\n  private _containerResizeCallback = (entries: ResizeObserverEntry[]): void => {\n    let width;\n    let height;\n\n    const { contentRect, contentBoxSize } = entries[0];\n\n    // `contentRect` is better supported than `borderBoxSize` or `contentBoxSize`,\n    // but it is left over from an earlier implementation of the Resize Observer API\n    // and may be deprecated in future versions.\n    // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry/contentRect\n    if (contentRect) {\n      width = contentRect.width;\n      height = contentRect.height;\n    } else if (contentBoxSize?.length) {\n      width = contentBoxSize[0].inlineSize;\n      height = contentBoxSize[0].blockSize;\n    }\n\n    this._containerSize = { width, height };\n    this.onContainerResize();\n  };\n}\n\nexport { Widget as default, Widget };\n","import { IColorMapPreset } from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport { vec2 } from 'gl-matrix';\nimport { utilities as csUtils, Types } from '@cornerstonejs/core';\nimport type { ColorbarProps, ColorbarVOIRange } from './types';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\n\nconst DEFAULTS = {\n  MULTIPLIER: 1,\n  RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n  TICKS_BAR_SIZE: 50,\n};\n\ntype ColorbarPoints = {\n  page: Types.Point2;\n  client: Types.Point2;\n  local: Types.Point2;\n};\n\n/**\n * A base colorbar class that is not associated with any viewport. It is\n * possible to click and drag to change the VOI range, shows the ticks during\n * interaction and it can show full image range or VOI range.\n */\nclass Colorbar extends Widget {\n  private _colormaps: Map<string, IColorMapPreset>;\n  private _activeColormapName: string;\n  private _eventListenersManager: csUtils.eventListener.MultiTargetEventListenerManager;\n  private _canvas: ColorbarCanvas;\n  private _ticksBar: ColorbarTicks;\n  private _rangeTextPosition: ColorbarRangeTextPosition;\n\n  private _isMouseOver = false;\n  private _isInteracting = false;\n\n  constructor(props: ColorbarProps) {\n    super(props);\n\n    this._eventListenersManager =\n      new csUtils.eventListener.MultiTargetEventListenerManager();\n    this._colormaps = Colorbar.getColormapsMap(props);\n    this._activeColormapName = Colorbar.getInitialColormapName(props);\n    this._canvas = this._createCanvas(props);\n    this._ticksBar = this._createTicksBar(props);\n    this._rangeTextPosition =\n      props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n\n    this._canvas.appendTo(this.rootElement);\n    this._ticksBar.appendTo(this.rootElement);\n\n    this._addRootElementEventListeners();\n  }\n\n  /**\n   * Returns the active LUT name\n   */\n  public get activeColormapName() {\n    return this._activeColormapName;\n  }\n\n  /**\n   * Set the current active LUT name and re-renders the color bar\n   */\n  public set activeColormapName(colormapName: string) {\n    if (colormapName === this._activeColormapName) {\n      return;\n    }\n\n    const colormap = this._colormaps.get(colormapName);\n\n    if (!colormap) {\n      console.warn(`Invalid colormap name (${colormapName})`);\n      return;\n    }\n\n    this._activeColormapName = colormapName;\n    this._canvas.colormap = colormap;\n  }\n\n  public get imageRange() {\n    return this._canvas.imageRange;\n  }\n\n  public set imageRange(imageRange: ColorbarVOIRange) {\n    this._canvas.imageRange = imageRange;\n    this._ticksBar.imageRange = imageRange;\n  }\n\n  public get voiRange() {\n    return this._canvas.voiRange;\n  }\n\n  public set voiRange(voiRange: ColorbarVOIRange) {\n    const { voiRange: currentVoiRange } = this._canvas;\n\n    if (\n      !isRangeValid(voiRange) ||\n      areColorbarRangesEqual(voiRange, currentVoiRange)\n    ) {\n      return;\n    }\n\n    this._canvas.voiRange = voiRange;\n    this._ticksBar.voiRange = voiRange;\n    this.onVoiChange(voiRange);\n  }\n\n  public get showFullImageRange() {\n    return this._canvas.showFullImageRange;\n  }\n\n  public set showFullImageRange(value: boolean) {\n    this._canvas.showFullImageRange = value;\n    this._ticksBar.showFullPixelValueRange = value;\n  }\n\n  public destroy() {\n    super.destroy();\n    this._eventListenersManager.reset();\n  }\n\n  protected createRootElement(): HTMLElement {\n    const rootElement = document.createElement('div');\n\n    Object.assign(rootElement.style, {\n      position: 'relative',\n      fontSize: '0',\n      width: '100%',\n      height: '100%',\n    });\n\n    return rootElement;\n  }\n\n  protected onContainerResize() {\n    super.onContainerResize();\n    this.updateTicksBar();\n    this._canvas.size = this.containerSize;\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    // no-op\n  }\n\n  protected showTicks() {\n    this.updateTicksBar();\n    this._ticksBar.visible = true;\n  }\n\n  protected hideTicks() {\n    if (this._isInteracting || this._isMouseOver) {\n      return;\n    }\n\n    this._ticksBar.visible = false;\n  }\n\n  private static getColormapsMap(props: ColorbarProps) {\n    const { colormaps } = props;\n\n    return colormaps.reduce(\n      (items, item) => items.set(item.Name, item),\n      new Map<string, IColorMapPreset>()\n    );\n  }\n\n  private static getInitialColormapName(props: ColorbarProps) {\n    const { activeColormapName, colormaps } = props;\n    const colormapExists =\n      !!activeColormapName &&\n      colormaps.some((cm) => cm.Name === activeColormapName);\n\n    return colormapExists ? activeColormapName : colormaps[0].Name;\n  }\n\n  private _createCanvas(props: ColorbarProps) {\n    const { imageRange, voiRange, showFullPixelValueRange } = props;\n    const colormap = this._colormaps.get(this._activeColormapName);\n\n    return new ColorbarCanvas({\n      colormap,\n      imageRange,\n      voiRange: voiRange,\n      showFullPixelValueRange,\n    });\n  }\n\n  public _createTicksBar(props: ColorbarProps): ColorbarTicks {\n    const ticksProps = props.ticks;\n\n    return new ColorbarTicks({\n      imageRange: props.imageRange,\n      voiRange: props.voiRange,\n      ticks: ticksProps,\n      showFullPixelValueRange: props.showFullPixelValueRange,\n    });\n  }\n\n  private _getPointsFromMouseEvent(evt: MouseEvent): ColorbarPoints {\n    const { rootElement: element } = this;\n    const clientPoint: Types.Point2 = [evt.clientX, evt.clientY];\n    const pagePoint: Types.Point2 = [evt.pageX, evt.pageY];\n    const rect = element.getBoundingClientRect();\n    const localPoints: Types.Point2 = [\n      pagePoint[0] - rect.left - window.pageXOffset,\n      pagePoint[1] - rect.top - window.pageYOffset,\n    ];\n\n    return { client: clientPoint, page: pagePoint, local: localPoints };\n  }\n\n  private updateTicksBar() {\n    const { width: containerWidth, height: containerHeight } =\n      this.containerSize;\n\n    // ResizeObserver have not triggered any event when this happen\n    if (containerWidth === 0 && containerHeight === 0) {\n      return;\n    }\n\n    const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n    const isHorizontal = containerWidth >= containerHeight;\n    const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n    const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n\n    if (\n      !isRangeTextPositionValid(\n        containerWidth,\n        containerHeight,\n        rangeTextPosition\n      )\n    ) {\n      throw new Error(\n        'Invalid rangeTextPosition value for the current colobar orientation'\n      );\n    }\n\n    let ticksBarTop;\n    let ticksBarLeft;\n\n    ticksBar.size = { width, height };\n\n    if (isHorizontal) {\n      ticksBarLeft = 0;\n      ticksBarTop =\n        rangeTextPosition === ColorbarRangeTextPosition.Top\n          ? -height\n          : containerHeight;\n    } else {\n      ticksBarTop = 0;\n      ticksBarLeft =\n        rangeTextPosition === ColorbarRangeTextPosition.Left\n          ? -width\n          : containerWidth;\n    }\n\n    ticksBar.top = ticksBarTop;\n    ticksBar.left = ticksBarLeft;\n  }\n\n  private _mouseOverCallback = (evt) => {\n    this._isMouseOver = true;\n    this.showTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseOutCallback = (evt) => {\n    this._isMouseOver = false;\n    this.hideTicks();\n    evt.stopPropagation();\n  };\n\n  private _mouseDownCallback = (evt: MouseEvent) => {\n    this._isInteracting = true;\n    this.showTicks();\n    this._addVOIEventListeners(evt);\n    evt.stopPropagation();\n  };\n\n  private _mouseDragCallback = (evt, initialState) => {\n    const multipliers = this.getVOIMultipliers();\n    const currentPoints = this._getPointsFromMouseEvent(evt);\n    const { points: startPoints, voiRange: startVOIRange } = initialState;\n    const canvasDelta = vec2.sub(\n      vec2.create(),\n      currentPoints.local,\n      startPoints.local\n    );\n\n    const wwDelta = canvasDelta[0] * multipliers[0];\n    const wcDelta = canvasDelta[1] * multipliers[1];\n\n    if (!wwDelta && !wcDelta) {\n      return;\n    }\n\n    const { lower: voiLower, upper: voiUpper } = startVOIRange;\n    let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(\n      voiLower,\n      voiUpper\n    );\n\n    windowWidth = Math.max(windowWidth + wwDelta, 1);\n    windowCenter += wcDelta;\n\n    const newVoiRange = csUtils.windowLevel.toLowHighRange(\n      windowWidth,\n      windowCenter\n    );\n\n    this.voiRange = newVoiRange;\n    evt.stopPropagation();\n    evt.preventDefault();\n  };\n\n  private _mouseUpCallback = (evt) => {\n    this._isInteracting = false;\n    this.hideTicks();\n    this._removeVOIEventListeners();\n    evt.stopPropagation();\n  };\n\n  private _addRootElementEventListeners() {\n    const { _eventListenersManager: manager } = this;\n    const { rootElement: element } = this;\n\n    manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n    manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n    manager.addEventListener(\n      element,\n      'mousedown',\n      this._mouseDownCallback as EventListener\n    );\n  }\n\n  private _addVOIEventListeners(evt: MouseEvent) {\n    const { _eventListenersManager: manager } = this;\n    const points = this._getPointsFromMouseEvent(evt);\n    const voiRange = { ...this._canvas.voiRange };\n    const initialDragState = { points, voiRange };\n\n    this._removeVOIEventListeners();\n\n    manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n    manager.addEventListener(document, 'voi.mousemove', (evt) =>\n      this._mouseDragCallback(evt, initialDragState)\n    );\n  }\n\n  private _removeVOIEventListeners() {\n    const { _eventListenersManager: manager } = this;\n\n    manager.removeEventListener(document, 'voi.mouseup');\n    manager.removeEventListener(document, 'voi.mousemove');\n  }\n}\n\nexport { Colorbar as default, Colorbar };\n","import { ColorbarRangeTextPosition } from '../enums';\n\nfunction isRangeTextPositionValid(\n  colorbarWidth: number,\n  colorbarHeight: number,\n  rangeTextPosition: ColorbarRangeTextPosition\n) {\n  const isHorizontal = colorbarWidth >= colorbarHeight;\n  const validRangeTextPositions = isHorizontal\n    ? [ColorbarRangeTextPosition.Top, ColorbarRangeTextPosition.Bottom]\n    : [ColorbarRangeTextPosition.Left, ColorbarRangeTextPosition.Right];\n\n  return validRangeTextPositions.includes(rangeTextPosition);\n}\n\nexport { isRangeTextPositionValid as default, isRangeTextPositionValid };\n","import {\n  eventTarget,\n  VolumeViewport,\n  StackViewport,\n  Types,\n  Enums,\n  utilities,\n  getEnabledElement,\n} from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport type { ViewportColorbarProps, ColorbarVOIRange } from './types';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\n\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\n/**\n * A colorbar associated with a viewport that updates automatically when the\n * viewport VOI changes or when the stack/volume are updated..\n */\nclass ViewportColorbar extends Colorbar {\n  private _element: HTMLDivElement;\n  private _volumeId: string;\n\n  private _hideTicksTime: number;\n  private _hideTicksTimeoutId: number;\n\n  constructor(props: ViewportColorbarProps) {\n    const { element, volumeId } = props;\n    const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n    const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n\n    super({ ...props, imageRange, voiRange });\n\n    this._element = element;\n    this._volumeId = volumeId;\n\n    this._addCornerstoneEventListener();\n  }\n\n  public get element() {\n    return this._element;\n  }\n\n  public get enabledElement() {\n    return getEnabledElement(this._element);\n  }\n\n  protected getVOIMultipliers(): [number, number] {\n    const { viewport } = this.enabledElement;\n    return getVOIMultipliers(viewport, this._volumeId);\n  }\n\n  protected onVoiChange(voiRange: ColorbarVOIRange) {\n    super.onVoiChange(voiRange);\n\n    const { viewport } = this.enabledElement;\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: voiRange,\n      });\n      viewport.render();\n    } else if (viewport instanceof VolumeViewport) {\n      const { _volumeId: volumeId } = this;\n      const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        viewport.renderingEngineId\n      );\n\n      viewport.setProperties({ voiRange }, volumeId);\n      viewportsContainingVolumeUID.forEach((vp) => vp.render());\n    }\n  }\n\n  private static _getImageRange(element, volumeId?) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const actor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!actor) {\n      return defaultImageRange;\n    }\n\n    const imageData = actor.actor.getMapper().getInputData();\n    const imageRange = imageData.getPointData().getScalars().getRange();\n\n    return imageRange[0] === 0 && imageRange[1] === 0\n      ? defaultImageRange\n      : { lower: imageRange[0], upper: imageRange[1] };\n  }\n\n  private static _getVOIRange(element, volumeId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const volumeActor = volumeId\n      ? viewport.getActor(volumeId)\n      : viewport.getDefaultActor();\n\n    if (!volumeActor || !utilities.isImageActor(volumeActor)) {\n      return defaultImageRange;\n    }\n\n    const voiRange = (volumeActor.actor as Types.ImageActor)\n      .getProperty()\n      .getRGBTransferFunction(0)\n      .getRange();\n\n    return voiRange[0] === 0 && voiRange[1] === 0\n      ? defaultImageRange\n      : { lower: voiRange[0], upper: voiRange[1] };\n  }\n\n  private autoHideTicks = () => {\n    // Avoiding calling setTimeout multiple times when manipulating the VOI\n    // via WindowLevel tool for better performance\n    if (this._hideTicksTimeoutId) {\n      return;\n    }\n\n    const timeLeft = this._hideTicksTime - Date.now();\n\n    if (timeLeft <= 0) {\n      this.hideTicks();\n    } else {\n      this._hideTicksTimeoutId = window.setTimeout(() => {\n        // Recursive call until there is no more time left\n        this._hideTicksTimeoutId = 0;\n        this.autoHideTicks();\n      }, timeLeft);\n    }\n  };\n\n  private showAndAutoHideTicks(interval = 1000) {\n    this._hideTicksTime = Date.now() + interval;\n    this.showTicks();\n    this.autoHideTicks();\n  }\n\n  private _stackNewImageCallback = () => {\n    this.imageRange = ViewportColorbar._getImageRange(this._element);\n  };\n\n  private _imageVolumeModifiedCallback = (\n    evt: Types.EventTypes.ImageVolumeModifiedEvent\n  ) => {\n    const { volumeId } = evt.detail.imageVolume;\n\n    if (volumeId !== this._volumeId) {\n      return;\n    }\n\n    const { _element: element } = this;\n    this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n  };\n\n  private _viewportVOIModifiedCallback = (\n    evt: Types.EventTypes.VoiModifiedEvent\n  ) => {\n    const { viewportId, volumeId, range: voiRange } = evt.detail;\n    const { viewport } = this.enabledElement;\n\n    if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n      return;\n    }\n\n    this.voiRange = voiRange;\n    this.showAndAutoHideTicks();\n  };\n\n  private _addCornerstoneEventListener() {\n    const { _element: element } = this;\n\n    eventTarget.addEventListener(\n      Events.IMAGE_VOLUME_MODIFIED,\n      this._imageVolumeModifiedCallback\n    );\n\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._stackNewImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOI_MODIFIED,\n      this._viewportVOIModifiedCallback as EventListener\n    );\n  }\n}\n\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { Types, utilities as csUtils } from '@cornerstonejs/core';\nimport { isViewportPreScaled } from './viewport';\n\nconst DEFAULT_MULTIPLIER = 4;\n\nfunction getVOIMultipliers(\n  viewport: Types.IStackViewport | Types.IVolumeViewport,\n  volumeId?: string,\n  options?: {\n    fixedPTWindowWidth?: boolean;\n  }\n): [number, number] {\n  const modality = csUtils.getViewportModality(viewport, volumeId);\n\n  if (modality === 'PT') {\n    const { clientWidth, clientHeight } = viewport.element;\n    const ptMultiplier = 5 / Math.max(clientWidth, clientHeight);\n    const isPreScaled = isViewportPreScaled(viewport, volumeId);\n    const { fixedPTWindowWidth = true } = options ?? {};\n\n    // Set the \"X\" multiplier equal to zero in order to do not allow\n    // any change to the window width (0 * cursorDeltaX = 0)\n    const xMultiplier = fixedPTWindowWidth ? 0 : ptMultiplier;\n\n    return isPreScaled\n      ? [xMultiplier, ptMultiplier]\n      : [xMultiplier, DEFAULT_MULTIPLIER];\n  }\n\n  return [DEFAULT_MULTIPLIER, DEFAULT_MULTIPLIER];\n}\n\nexport { getVOIMultipliers as default, getVOIMultipliers };\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\n\n/**\n * Set the cursor for an HTML element. cursorNames can be either\n * cornerstone3DTools cursors or standard cursors.\n *\n * @param element - The element to set the cursor on.\n * @param cursorName - The name of the cursor to set. This can be\n * any cursor name either Cornerstone-specific cursor names or the standard\n * CSS cursor names.\n */\nfunction setCursorForElement(\n  element: HTMLDivElement,\n  cursorName: string\n): void {\n  let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n  if (!cursor) {\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  if (!cursor) {\n    console.log(\n      `Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`\n    );\n    cursor = MouseCursor.getDefinedCursor(cursorName);\n  }\n\n  setElementCursor(element, cursor);\n}\n\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport {\n  registerCursor,\n  svgCursorNames,\n  CursorSVG,\n} from './SVGCursorDescriptor';\n\n// Todo: this should be enum\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\n\nexport {\n  MouseCursor,\n  ImageMouseCursor,\n  SVGMouseCursor,\n  elementCursor,\n  registerCursor,\n  CursorNames,\n  CursorSVG,\n  setCursorForElement,\n};\n","import { ToolModes, AnnotationStyleStates } from '../../../enums';\nimport { getStyleProperty } from './helpers';\nimport { StyleSpecifier } from '../../../types/AnnotationStyle';\n\n/**\n * getFont - Returns a font string of the form \"{fontSize}px fontName\" used by `canvas`.\n * @param styleSpecifier - An object containing the specifications such as viewportId,\n * toolGroupId, toolName and annotationUID which are used to get the style if the level of specificity is\n * met (hierarchy is checked from most specific to least specific which is\n * annotationLevel -> viewportLevel -> toolGroupLevel -> default.\n * @param state - An optional state to determine the final property name\n * @param mode - An optional mode to determine the final property name\n * @returns The font string.\n */\nfunction getFont(\n  styleSpecifier: StyleSpecifier,\n  state?: AnnotationStyleStates,\n  mode?: ToolModes\n): string {\n  const fontSize = getStyleProperty(\n    'textBoxFontSize',\n    styleSpecifier,\n    state,\n    mode\n  );\n  const fontFamily = getStyleProperty(\n    'textBoxFontFamily',\n    styleSpecifier,\n    state,\n    mode\n  );\n\n  return `${fontSize}px ${fontFamily}`;\n}\n\nexport default getFont;\n","import * as Enums from '../../../enums';\nimport { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport validateLabelmap from '../../../tools/displayTools/Labelmap/validateRepresentationData';\n\n/**\n * Checks if the segmentationInputArray is valid meaning it contains\n * correct representationProps for the representation type that is being used.\n *\n * @param segmentationInputArray - Array of segmentation inputs\n * @internal\n */\nfunction validateSegmentationInput(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  if (!segmentationInputArray || !segmentationInputArray.length) {\n    throw new Error('The segmentationInputArray is undefined or empty array');\n  }\n\n  segmentationInputArray.forEach((segmentationInput) => {\n    if (segmentationInput.segmentationId === undefined) {\n      throw new Error(\n        'The segmentationInput.segmentationId is undefined, please provide a valid segmentationId'\n      );\n    }\n\n    if (segmentationInput.representation === undefined) {\n      throw new Error(\n        'The segmentationInput.representation is undefined, please provide a valid representation'\n      );\n    }\n\n    if (\n      segmentationInput.representation.type ===\n      Enums.SegmentationRepresentations.Labelmap\n    ) {\n      validateLabelmap(segmentationInput);\n    }\n  });\n}\n\nexport default validateSegmentationInput;\n","import { SegmentationPublicInput } from '../../../types/SegmentationStateTypes';\nimport { cache } from '@cornerstonejs/core';\nimport { LabelmapSegmentationData } from '../../../types/LabelmapTypes';\n\nfunction validate(segmentationInput: SegmentationPublicInput): void {\n  if (!segmentationInput.representation.data) {\n    throw new Error(\n      'The segmentationInput.representationData.data is undefined, please provide a valid representationData.data'\n    );\n  }\n\n  const representationData = segmentationInput.representation\n    .data as LabelmapSegmentationData;\n\n  if (!representationData.volumeId) {\n    throw new Error(\n      'The segmentationInput.representationData.volumeId is undefined, please provide a valid representationData.volumeId'\n    );\n  }\n\n  const cachedVolume = cache.getVolume(representationData.volumeId);\n\n  if (!cachedVolume) {\n    throw new Error(\n      `volumeId of ${representationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`\n    );\n  }\n}\n\nexport default validate;\n","import _cloneDeep from 'lodash.clonedeep';\nimport { SegmentationPublicInput } from '../../types/SegmentationStateTypes';\nimport { validateSegmentationInput } from './helpers';\nimport { addSegmentation as addSegmentationToState } from './segmentationState';\n/**\n * Adds the segmentation to the cornerstone3D segmentation state. It should be\n * noted that segmentations are not added to any toolGroup's viewports. In order to\n * do so, you should add a \"representation\" of the segmentation to the toolGroup\n * using addSegmentationRepresentations helper. The reason for this is that there\n * can be multiple representations of the same segmentation (e.g. Labelmap and\n * Contour, etc. - Currently only Labelmap representations is supported).\n * @param segmentationInputArray - The array of segmentation input, each of which\n * defining the segmentationId and the main representation data for the segmentation.\n */\nfunction addSegmentations(\n  segmentationInputArray: SegmentationPublicInput[]\n): void {\n  validateSegmentationInput(segmentationInputArray);\n\n  segmentationInputArray.map((segInput) => {\n    const segmentationInput = _cloneDeep(segInput);\n\n    addSegmentationToState(segmentationInput);\n  });\n}\n\nexport default addSegmentations;\n","import _cloneDeep from 'lodash.clonedeep';\nimport {\n  SegmentationRepresentationConfig,\n  RepresentationPublicInput,\n} from '../../types/SegmentationStateTypes';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getToolGroup } from '../../store/ToolGroupManager';\n\nimport { labelmapDisplay } from '../../tools/displayTools/Labelmap';\nimport { contourDisplay } from '../../tools/displayTools/Contour';\nimport { surfaceDisplay } from '../../tools/displayTools/Surface';\n\n/**\n * Set the specified segmentation representations on the viewports of the specified\n * toolGroup. It accepts a second argument which is a toolGroup specific representation\n * configuration.\n *\n * @param toolGroupId - The Id of the toolGroup to add the segmentation representations to\n * @param representationInputArray - An array of segmentation representations to add to the toolGroup\n * @param toolGroupSpecificRepresentationConfig - The toolGroup specific configuration\n * for the segmentation representations\n */\nasync function addSegmentationRepresentations(\n  toolGroupId: string,\n  representationInputArray: RepresentationPublicInput[],\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string[]> {\n  // Check if there exists a toolGroup with the toolGroupId\n  const toolGroup = getToolGroup(toolGroupId);\n\n  if (!toolGroup) {\n    throw new Error(`No tool group found for toolGroupId: ${toolGroupId}`);\n  }\n\n  const promises = representationInputArray.map((representationInput) => {\n    return _addSegmentationRepresentation(\n      toolGroupId,\n      representationInput,\n      toolGroupSpecificRepresentationConfig\n    );\n  });\n\n  const segmentationRepresentationUIDs = await Promise.all(promises);\n\n  return segmentationRepresentationUIDs;\n}\n\nasync function _addSegmentationRepresentation(\n  toolGroupId: string,\n  representationInput: RepresentationPublicInput,\n  toolGroupSpecificRepresentationConfig?: SegmentationRepresentationConfig\n): Promise<string> {\n  let segmentationRepresentationUID;\n\n  if (representationInput.type === Representations.Labelmap) {\n    segmentationRepresentationUID =\n      await labelmapDisplay.addSegmentationRepresentation(\n        toolGroupId,\n        representationInput,\n        toolGroupSpecificRepresentationConfig\n      );\n  } else if (representationInput.type === Representations.Contour) {\n    segmentationRepresentationUID =\n      await contourDisplay.addSegmentationRepresentation(\n        toolGroupId,\n        representationInput,\n        toolGroupSpecificRepresentationConfig\n      );\n  } else if (representationInput.type === Representations.Surface) {\n    segmentationRepresentationUID =\n      await surfaceDisplay.addSegmentationRepresentation(\n        toolGroupId,\n        representationInput,\n        toolGroupSpecificRepresentationConfig\n      );\n  } else {\n    throw new Error(\n      `The representation type ${representationInput.type} is not supported`\n    );\n  }\n\n  return segmentationRepresentationUID;\n}\n\nexport default addSegmentationRepresentations;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * Tool that pans the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass PanTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\n\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { BaseTool } from './base';\n\n/**\n * Tool that rotates the camera in the plane defined by the viewPlaneNormal and the viewUp.\n */\nclass TrackballRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        rotateIncrementDegrees: 2,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  rotateCamera = (viewport, centerWorld, axis, angle) => {\n    const vtkCamera = viewport.getVtkActiveCamera();\n    const viewUp = vtkCamera.getViewUp();\n    const focalPoint = vtkCamera.getFocalPoint();\n    const position = vtkCamera.getPosition();\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, centerWorld);\n    mat4.rotate(transform, transform, angle, axis);\n    mat4.translate(transform, transform, [\n      -centerWorld[0],\n      -centerWorld[1],\n      -centerWorld[2],\n    ]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, axis);\n    vec3.transformMat4(newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n  };\n\n  // pseudocode inspired from\n  // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js\n  _dragCallback(evt: EventTypes.InteractionEventType): void {\n    const { element, currentPoints, lastPoints } = evt.detail;\n    const currentPointsCanvas = currentPoints.canvas;\n    const lastPointsCanvas = lastPoints.canvas;\n    const { rotateIncrementDegrees } = this.configuration;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const normalizedPosition = [\n      currentPointsCanvas[0] / width,\n      currentPointsCanvas[1] / height,\n    ];\n\n    const normalizedPreviousPosition = [\n      lastPointsCanvas[0] / width,\n      lastPointsCanvas[1] / height,\n    ];\n\n    const center: Types.Point2 = [width * 0.5, height * 0.5];\n    // NOTE: centerWorld corresponds to the focal point in cornerstone3D\n    const centerWorld = viewport.canvasToWorld(center);\n    const normalizedCenter = [0.5, 0.5];\n\n    const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n    const op = [normalizedPreviousPosition[0], 0, 0];\n    const oe = [normalizedPosition[0], 0, 0];\n\n    const opsq = op[0] ** 2;\n    const oesq = oe[0] ** 2;\n\n    const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n    const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n\n    const nop: Types.Point3 = [op[0], 0, lop];\n    vtkMath.normalize(nop);\n    const noe: Types.Point3 = [oe[0], 0, loe];\n    vtkMath.normalize(noe);\n\n    const dot = vtkMath.dot(nop, noe);\n    if (Math.abs(dot) > 0.0001) {\n      const angleX =\n        -2 *\n        Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n        Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n        rotateIncrementDegrees;\n\n      const upVec = camera.viewUp;\n      const atV = camera.viewPlaneNormal;\n      const rightV: Types.Point3 = [0, 0, 0];\n      const forwardV: Types.Point3 = [0, 0, 0];\n\n      vtkMath.cross(upVec, atV, rightV);\n      vtkMath.normalize(rightV);\n\n      vtkMath.cross(atV, rightV, forwardV);\n      vtkMath.normalize(forwardV);\n      vtkMath.normalize(upVec);\n\n      this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n\n      const angleY =\n        (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n        rotateIncrementDegrees;\n\n      this.rotateCamera(viewport, centerWorld, rightV, angleY);\n\n      viewport.render();\n    }\n  }\n}\n\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  utilities,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * ProbeTool let you get the underlying voxel value by putting a probe in that\n * location. It will give index of the location and value of the voxel.\n * You can use ProbeTool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Probe tool's text box are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * To use the ProbeTool, you first need to add it to cornerstoneTools, then create\n * a toolGroup and add the ProbeTool to it. Finally, setToolActive on the toolGroup\n *\n * ```js\n * cornerstoneTools.addTool(ProbeTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(ProbeTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(ProbeTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n *\n */\n\nclass ProbeTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  // Not necessary for this tool but needs to be defined since it's an abstract\n  // method from the parent class.\n  isPointNearTool(): boolean {\n    return false;\n  }\n\n  toolSelectedCallback() {}\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Probe Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It checks if the mouse click is near ProveTool, it overwrites the baseAnnotationTool\n   * getHandleNearImagePoint method.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: ProbeAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const point = data.handles.points[0];\n    const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n\n    const near =\n      vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n\n    if (near === true) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ProbeAnnotation\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    // Find viewports to render on drag.\n\n    this.editData = {\n      //handle, // This would be useful for other tools with more than one handle\n      annotation,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { viewportId } = enabledElement;\n    this.eventDispatchDetail = {\n      viewportId,\n      renderingEngineId: renderingEngine.id,\n    };\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragCallback = (evt) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points[0] = [...worldPos];\n    annotation.invalidated = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the probe annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ProbeAnnotation;\n      const annotationUID = annotation.annotationUID;\n      const data = annotation.data;\n      const point = data.handles.points[0];\n      const canvasCoordinates = viewport.worldToCanvas(point);\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].value == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          index: null,\n          value: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related stackViewports data if\n        // they are not at the referencedImageId, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const handleGroupUID = '0';\n\n      drawHandlesSvg(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        [canvasCoordinates],\n        { color }\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (textLines) {\n        const textCanvasCoordinates = [\n          canvasCoordinates[0] + 6,\n          canvasCoordinates[1] - 6,\n        ];\n\n        const textUID = '0';\n        drawTextBoxSvg(\n          svgDrawingHelper,\n          annotationUID,\n          textUID,\n          textLines,\n          [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n          options\n        );\n      }\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId, viewport } = enabledElement;\n\n    const worldPos = data.handles.points[0];\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const modalityUnitOptions = {\n        isPreScaled: isViewportPreScaled(viewport, targetId),\n        isSuvScaled: this.isSuvScaled(\n          viewport,\n          targetId,\n          annotation.metadata.referencedImageId\n        ),\n      };\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata } = image;\n      const scalarData =\n        'getScalarData' in image ? image.getScalarData() : image.scalarData;\n\n      const modality = metadata.Modality;\n      const index = transformWorldToIndex(imageData, worldPos);\n\n      index[0] = Math.round(index[0]);\n      index[1] = Math.round(index[1]);\n      index[2] = Math.round(index[2]);\n\n      if (csUtils.indexWithinDimensions(index, dimensions)) {\n        this.isHandleOutsideImage = false;\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        const value =\n          scalarData[index[2] * zMultiple + index[1] * yMultiple + index[0]];\n\n        // Index[2] for stackViewport is always 0, but for visualization\n        // we reset it to be imageId index\n        if (targetId.startsWith('imageId:')) {\n          const imageId = targetId.split('imageId:')[1];\n          const imageURI = csUtils.imageIdToURI(imageId);\n          const viewports = utilities.getViewportsWithImageURI(\n            imageURI,\n            renderingEngineId\n          );\n\n          const viewport = viewports[0];\n\n          index[2] = viewport.getCurrentImageIdIndex();\n        }\n\n        const modalityUnit = getModalityUnit(\n          modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        cachedStats[targetId] = {\n          index,\n          value,\n          Modality: modality,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetId] = {\n          index,\n          Modality: modality,\n        };\n      }\n\n      annotation.invalidated = false;\n\n      // Dispatching annotation modified\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nProbeTool.toolName = 'Probe';\nexport default ProbeTool;\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  PublicToolProps,\n  SVGDrawingHelper,\n  ToolProps,\n} from '../../types';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nimport { ProbeAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\n\nclass DragProbeTool extends ProbeTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    newAnnotation?: boolean;\n  } | null;\n  eventDispatchDetail: {\n    viewportId: string;\n    renderingEngineId: string;\n  };\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  postMouseDownCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotation: ProbeAnnotation = {\n      invalidated: true,\n      highlighted: true,\n      isVisible: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: { points: [<Types.Point3>[...worldPos]] },\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      newAnnotation: true,\n      viewportIdsToRender,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  postTouchStartCallback = (\n    evt: EventTypes.InteractionEventType\n  ): ProbeAnnotation => {\n    return this.postMouseDownCallback(evt);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const annotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      [this.editData.annotation]\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const annotation = this.editData.annotation;\n    const annotationUID = annotation.annotationUID;\n    const data = annotation.data;\n    const point = data.handles.points[0];\n    const canvasCoordinates = viewport.worldToCanvas(point);\n\n    styleSpecifier.annotationUID = annotationUID;\n\n    const color = this.getStyle('color', styleSpecifier, annotation);\n\n    const modalityUnitOptions = {\n      isPreScaled: isViewportPreScaled(viewport, targetId),\n\n      isSuvScaled: this.isSuvScaled(\n        viewport,\n        targetId,\n        annotation.metadata.referencedImageId\n      ),\n    };\n\n    if (\n      !data.cachedStats[targetId] ||\n      data.cachedStats[targetId].value == null\n    ) {\n      data.cachedStats[targetId] = {\n        Modality: null,\n        index: null,\n        value: null,\n      };\n\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    } else if (annotation.invalidated) {\n      this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n    }\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const handleGroupUID = '0';\n\n    drawHandlesSvg(\n      svgDrawingHelper,\n      annotationUID,\n      handleGroupUID,\n      [canvasCoordinates],\n      { color }\n    );\n\n    renderStatus = true;\n\n    const textLines = this.configuration.getTextLines(data, targetId);\n    if (textLines) {\n      const textCanvasCoordinates = [\n        canvasCoordinates[0] + 6,\n        canvasCoordinates[1] - 6,\n      ];\n\n      const textUID = '0';\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textUID,\n        textLines,\n        [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n        this.getLinkedTextBoxStyle(styleSpecifier, annotation)\n      );\n    }\n\n    return renderStatus;\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { index, value, modalityUnit } = cachedVolumeStats;\n\n  if (value === undefined) {\n    return;\n  }\n\n  const textLines = [];\n\n  textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n\n  textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n\n  return textLines;\n}\n\nDragProbeTool.toolName = 'DragProbe';\nexport default DragProbeTool;\n","import { BaseTool } from './base';\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  StackViewport,\n  utilities,\n  cache,\n  Types,\n} from '@cornerstonejs/core';\nimport { EventTypes } from '../types';\n\n// Todo: should move to configuration\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\n\n/**\n * WindowLevel tool manipulates the windowLevel applied to a viewport. It\n * provides a way to set the windowCenter and windowWidth of a viewport\n * by dragging mouse over the image.\n *\n */\nclass WindowLevelTool extends BaseTool {\n  static toolName;\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this.mouseDragCallback(evt);\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    let volumeId,\n      lower,\n      upper,\n      modality,\n      newRange,\n      viewportsContainingVolumeUID;\n    let isPreScaled = false;\n\n    if (viewport instanceof VolumeViewport) {\n      const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n      volumeId = targetId.split('volumeId:')[1];\n      viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(\n        volumeId,\n        renderingEngine.id\n      );\n      const properties = viewport.getProperties();\n      ({ lower, upper } = properties.voiRange);\n      const volume = cache.getVolume(volumeId);\n      modality = volume.metadata.Modality;\n      isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n    } else if (viewport instanceof StackViewport) {\n      const properties = viewport.getProperties();\n      modality = viewport.modality;\n      ({ lower, upper } = properties.voiRange);\n      const { preScale } = viewport.getImageData();\n      isPreScaled =\n        preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n    } else {\n      throw new Error('Viewport is not a valid type');\n    }\n\n    // If modality is PT, treat it special to not include the canvas delta in\n    // the x direction. For other modalities, use the canvas delta in both\n    // directions, and if the viewport is a volumeViewport, the multiplier\n    // is calculate using the volume min and max.\n    if (modality === PT) {\n      newRange = this.getPTScaledNewRange({\n        deltaPointsCanvas: deltaPoints.canvas,\n        lower,\n        upper,\n        clientHeight: element.clientHeight,\n        isPreScaled,\n        viewport,\n        volumeId,\n      });\n    } else {\n      newRange = this.getNewRange({\n        viewport,\n        deltaPointsCanvas: deltaPoints.canvas,\n        volumeId,\n        lower,\n        upper,\n      });\n    }\n\n    if (viewport instanceof StackViewport) {\n      viewport.setProperties({\n        voiRange: newRange,\n      });\n\n      viewport.render();\n      return;\n    }\n\n    if (viewport instanceof VolumeViewport) {\n      viewport.setProperties({\n        voiRange: newRange,\n      });\n\n      viewportsContainingVolumeUID.forEach((vp) => {\n        vp.render();\n      });\n      return;\n    }\n  }\n\n  getPTScaledNewRange({\n    deltaPointsCanvas,\n    lower,\n    upper,\n    clientHeight,\n    viewport,\n    volumeId,\n    isPreScaled,\n  }) {\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (isPreScaled) {\n      multiplier = 5 / clientHeight;\n    } else {\n      multiplier =\n        this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n        DEFAULT_MULTIPLIER;\n    }\n\n    const deltaY = deltaPointsCanvas[1];\n    const wcDelta = deltaY * multiplier;\n\n    upper -= wcDelta;\n    upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n\n    return { lower, upper };\n  }\n\n  getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n    const multiplier =\n      this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n      DEFAULT_MULTIPLIER;\n\n    const wwDelta = deltaPointsCanvas[0] * multiplier;\n    const wcDelta = deltaPointsCanvas[1] * multiplier;\n\n    let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(\n      lower,\n      upper\n    );\n\n    windowWidth += wwDelta;\n    windowCenter += wcDelta;\n\n    windowWidth = Math.max(windowWidth, 1);\n\n    // Convert back to range\n    return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter);\n  }\n\n  _getMultiplierFromDynamicRange(viewport, volumeId) {\n    let imageDynamicRange;\n\n    if (volumeId) {\n      const imageVolume = cache.getVolume(volumeId);\n      const { dimensions } = imageVolume;\n      const scalarData = imageVolume.getScalarData();\n      const calculatedDynamicRange = this._getImageDynamicRangeFromMiddleSlice(\n        scalarData,\n        dimensions\n      );\n      const BitsStored = imageVolume?.metadata?.BitsStored;\n      const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n      // Burned in Pixels often use pixel values above the BitsStored.\n      // This results in a multiplier which is way higher than what you would\n      // want in practice. Thus we take the min between the metadata dynamic\n      // range and actual middel slice dynamic range.\n      imageDynamicRange = Math.min(\n        calculatedDynamicRange,\n        metadataDynamicRange\n      );\n    } else {\n      imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n    }\n\n    const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n\n    let multiplier = DEFAULT_MULTIPLIER;\n\n    if (ratio > 1) {\n      multiplier = Math.round(ratio);\n    }\n    return multiplier;\n  }\n\n  _getImageDynamicRangeFromViewport(viewport) {\n    const { imageData } = viewport.getImageData();\n    const dimensions = imageData.getDimensions();\n\n    let scalarData;\n    // if getScalarData is a method on imageData\n    if (imageData.getScalarData) {\n      scalarData = imageData.getScalarData();\n    } else {\n      scalarData = imageData.getPointData().getScalars();\n    }\n\n    if (dimensions[2] !== 1) {\n      return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n    }\n\n    let range;\n    if (scalarData.getRange) {\n      range = scalarData.getRange();\n    } else {\n      const { min, max } = this._getMinMax(scalarData, scalarData.length);\n      range = [min, max];\n    }\n\n    return range[1] - range[0];\n  }\n\n  _getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n    const middleSliceIndex = Math.floor(dimensions[2] / 2);\n\n    const frameLength = dimensions[0] * dimensions[1];\n    let bytesPerVoxel;\n    let TypedArrayConstructor;\n\n    if (scalarData instanceof Float32Array) {\n      bytesPerVoxel = 4;\n      TypedArrayConstructor = Float32Array;\n    } else if (scalarData instanceof Uint8Array) {\n      bytesPerVoxel = 1;\n      TypedArrayConstructor = Uint8Array;\n    } else if (scalarData instanceof Uint16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Uint16Array;\n    } else if (scalarData instanceof Int16Array) {\n      bytesPerVoxel = 2;\n      TypedArrayConstructor = Int16Array;\n    }\n\n    const buffer = scalarData.buffer;\n    const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n    const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n\n    const { max, min } = this._getMinMax(frame, frameLength);\n\n    return max - min;\n  };\n\n  private _getMinMax(frame: Uint8Array | Float32Array, frameLength: number) {\n    let min = Infinity;\n    let max = -Infinity;\n\n    for (let i = 0; i < frameLength; i++) {\n      const voxel = frame[i];\n\n      if (voxel < min) {\n        min = voxel;\n      }\n\n      if (voxel > max) {\n        max = voxel;\n      }\n    }\n    return { max, min };\n  }\n}\n\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getEnabledElement, Types } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\n\n/**\n * ZoomTool tool manipulates the camera zoom applied to a viewport. It\n * provides a way to set the zoom of a viewport by dragging mouse over the image.\n *\n */\nclass ZoomTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  mouseDragCallback: (evt: EventTypes.InteractionEventType) => void;\n  initialMousePosWorld: Types.Point3;\n  dirVec: Types.Point3;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        // whether zoom to the center of the image OR zoom to the mouse position\n        zoomToCenter: false,\n        minZoomScale: 0.1,\n        maxZoomScale: 30,\n        pinchToZoom: true,\n        pan: true,\n        invert: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.initialMousePosWorld = [0, 0, 0];\n    this.dirVec = [0, 0, 0];\n    if (this.configuration.pinchToZoom) {\n      this.touchDragCallback = this._pinchCallback.bind(this);\n    } else {\n      this.touchDragCallback = this._dragCallback.bind(this);\n    }\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventData = evt.detail;\n    const { element, currentPoints } = eventData;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint } = camera;\n\n    this.initialMousePosWorld = worldPos;\n\n    // The direction vector from the clicked location to the focal point\n    // which would act as the vector to translate the image (if zoomToCenter is false)\n    let dirVec = vec3.fromValues(\n      focalPoint[0] - worldPos[0],\n      focalPoint[1] - worldPos[1],\n      focalPoint[2] - worldPos[2]\n    );\n\n    dirVec = vec3.normalize(vec3.create(), dirVec);\n\n    this.dirVec = dirVec as Types.Point3;\n\n    // we should not return true here, returning true in the preMouseDownCallback\n    // means that the event is handled by the tool and no other methods\n    // can claim the event, which will result in a bug where having Zoom on primary\n    // and clicking on an annotation will not manipulate the annotation, but will\n    // instead zoom the image (which is not what we want), so we return false here\n    return false;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    if (!this.configuration.pinchToZoom) {\n      return this.preMouseDownCallback(evt);\n    }\n  };\n\n  _pinchCallback(evt: EventTypes.InteractionEventType) {\n    const pointsList = (evt as EventTypes.TouchStartEventType).detail\n      .currentPointsList;\n\n    if (pointsList.length > 1) {\n      const { element, currentPoints } = evt.detail;\n      const enabledElement = getEnabledElement(element);\n      const { viewport } = enabledElement;\n      const camera = viewport.getCamera();\n      const worldPos = currentPoints.world;\n      const { focalPoint } = camera;\n      this.initialMousePosWorld = worldPos;\n      // The direction vector from the clicked location to the focal point\n      // which would act as the vector to translate the image (if zoomToCenter is false)\n      let dirVec = vec3.fromValues(\n        focalPoint[0] - worldPos[0],\n        focalPoint[1] - worldPos[1],\n        focalPoint[2] - worldPos[2]\n      );\n      dirVec = vec3.normalize(vec3.create(), dirVec);\n\n      this.dirVec = dirVec as Types.Point3;\n      if (camera.parallelProjection) {\n        this._dragParallelProjection(evt, viewport, camera, true);\n      } else {\n        this._dragPerspectiveProjection(evt, viewport, camera, true);\n      }\n      viewport.render();\n    }\n\n    if (this.configuration.pan) {\n      this._panCallback(evt);\n    }\n  }\n\n  // Takes ICornerstoneEvent, Mouse or Touch\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n\n    if (camera.parallelProjection) {\n      this._dragParallelProjection(evt, viewport, camera);\n    } else {\n      this._dragPerspectiveProjection(evt, viewport, camera);\n    }\n\n    viewport.render();\n  }\n\n  _dragParallelProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { parallelScale, focalPoint, position } = camera;\n\n    const zoomScale = 5 / size[1];\n    const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n\n    const parallelScaleToSet = (1.0 - k) * parallelScale;\n\n    let focalPointToSet = focalPoint;\n    let positionToSet = position;\n\n    // if we're not zooming to the center, we need to adjust the focal point\n    // and position to set the focal point and position to the value that\n    // would simulate the zoom to the mouse position\n    if (!this.configuration.zoomToCenter) {\n      // Distance of the initial mouse position (world) to the focal point\n      // which is always the center of the canvas.\n      const distanceToCanvasCenter = vec3.distance(\n        focalPoint,\n        this.initialMousePosWorld\n      );\n\n      positionToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        position,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n\n      focalPointToSet = vec3.scaleAndAdd(\n        vec3.create(),\n        focalPoint,\n        this.dirVec,\n        -distanceToCanvasCenter * k\n      ) as Types.Point3;\n    }\n\n    // If it is a regular GPU accelerated viewport, then parallel scale\n    // has a physical meaning and we can use that to determine the threshold\n    // Added spacing preset in case there is no imageData on viewport\n    const imageData = viewport.getImageData();\n    let spacing = [1, 1, 1];\n    if (imageData) {\n      spacing = imageData.spacing;\n    }\n\n    const { minZoomScale, maxZoomScale } = this.configuration;\n\n    const t = element.clientHeight * spacing[1] * 0.5;\n    const scale = t / parallelScaleToSet;\n\n    let cappedParallelScale = parallelScaleToSet;\n    let thresholdExceeded = false;\n\n    if (imageData) {\n      if (scale < minZoomScale) {\n        cappedParallelScale = t / minZoomScale;\n        thresholdExceeded = true;\n      } else if (scale >= maxZoomScale) {\n        cappedParallelScale = t / maxZoomScale;\n        thresholdExceeded = true;\n      }\n    }\n\n    viewport.setCamera({\n      parallelScale: cappedParallelScale,\n      focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n      position: thresholdExceeded ? position : positionToSet,\n    });\n  };\n\n  _dragPerspectiveProjection = (\n    evt: EventTypes.InteractionEventType,\n    viewport: Types.IStackViewport | Types.IVolumeViewport,\n    camera: Types.ICamera,\n    pinch = false\n  ): void => {\n    const { element, deltaPoints } = evt.detail;\n    const deltaY = pinch\n      ? (evt as EventTypes.TouchDragEventType).detail.deltaDistance.canvas\n      : deltaPoints.canvas[1];\n\n    const size = [element.clientWidth, element.clientHeight];\n    const { position, focalPoint, viewPlaneNormal } = camera;\n\n    const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n    const zoomScale = Math.sqrt(distance) / size[1];\n\n    const directionOfProjection = [\n      -viewPlaneNormal[0],\n      -viewPlaneNormal[1],\n      -viewPlaneNormal[2],\n    ];\n\n    const k = this.configuration.invert\n      ? deltaY / zoomScale\n      : deltaY * zoomScale;\n\n    let tmp = k * directionOfProjection[0];\n    position[0] += tmp;\n    focalPoint[0] += tmp;\n\n    tmp = k * directionOfProjection[1];\n    position[1] += tmp;\n    focalPoint[1] += tmp;\n\n    tmp = k * directionOfProjection[2];\n    position[2] += tmp;\n    focalPoint[2] += tmp;\n\n    viewport.setCamera({ position, focalPoint });\n  };\n\n  _panCallback(evt: EventTypes.InteractionEventType) {\n    const { element, deltaPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n\n    const deltaPointsWorld = deltaPoints.world;\n    const camera = enabledElement.viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    enabledElement.viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n    enabledElement.viewport.render();\n  }\n}\n\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import {\n  getEnabledElementByIds,\n  VolumeViewport,\n  StackViewport,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { scroll } from '../utilities';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The StackScrollTool is a tool that allows the user to scroll through a\n * stack of images by pressing the mouse click and dragging\n */\nclass StackScrollTool extends BaseTool {\n  static toolName;\n  deltaY: number;\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.deltaY = 1;\n  }\n\n  mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n  touchDragCallback(evt: EventTypes.InteractionEventType) {\n    this._dragCallback(evt);\n  }\n\n  _dragCallback(evt: EventTypes.InteractionEventType) {\n    const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n\n    const targetId = this.getTargetId(viewport);\n    const { debounceIfNotLoaded, invert, loop } = this.configuration;\n\n    const deltaPointY = deltaPoints.canvas[1];\n\n    let volumeId;\n    if (viewport instanceof VolumeViewport) {\n      volumeId = targetId.split('volumeId:')[1];\n    }\n\n    const pixelsPerImage = this._getPixelPerImage(viewport);\n    const deltaY = deltaPointY + this.deltaY;\n\n    if (!pixelsPerImage) {\n      return;\n    }\n\n    if (Math.abs(deltaY) >= pixelsPerImage) {\n      const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n\n      scroll(viewport, {\n        delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n        volumeId,\n        debounceLoading: debounceIfNotLoaded,\n        loop: loop,\n      });\n\n      this.deltaY = deltaY % pixelsPerImage;\n    } else {\n      this.deltaY = deltaY;\n    }\n  }\n\n  _getPixelPerImage(viewport) {\n    const { element } = viewport;\n    const numberOfSlices = this._getNumberOfSlices(viewport);\n\n    // The Math.max here makes it easier to mouseDrag-scroll small or really large image stacks\n    return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n  }\n\n  _getNumberOfSlices(viewport) {\n    if (viewport instanceof VolumeViewport) {\n      const { numberOfSlices } =\n        csUtils.getImageSliceDataForVolumeViewport(viewport);\n      return numberOfSlices;\n    } else if (viewport instanceof StackViewport) {\n      return viewport.getImageIds().length;\n    }\n  }\n}\n\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import type { Types } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\n\ntype Line2D = [Types.Point2, Types.Point2];\ntype Line3D = [Types.Point3, Types.Point3];\ntype Line = Line2D | Line3D;\n\n/**\n * Calculates the angle between two 3D lines.\n */\nfunction angleBetween3DLines(line1: Line3D, line2: Line3D): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec3.sub(vec3.create(), p2, p1);\n  const v2 = vec3.sub(vec3.create(), p3, p4);\n\n  const dot = vec3.dot(v1, v2);\n\n  const v1Length = vec3.length(v1);\n  const v2Length = vec3.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n\n  const radian = Math.acos(cos);\n\n  return (radian * 180) / Math.PI;\n}\n\n/**\n * Calculates the angle between two 2D lines.\n */\nfunction angleBetween2DLines(line1: Line2D, line2: Line2D): number {\n  const [p1, p2] = line1;\n  const [p3, p4] = line2;\n\n  const v1 = vec2.sub(vec2.create(), p2, p1);\n  const v2 = vec2.sub(vec2.create(), p3, p4);\n\n  const dot = vec2.dot(v1, v2);\n  const v1Length = vec2.length(v1);\n  const v2Length = vec2.length(v2);\n\n  const cos = dot / (v1Length * v2Length);\n  return Math.acos(cos) * (180 / Math.PI);\n}\n\n/**\n * Returns the angle between two lines in degrees.\n * The angle measured is that between the vectors\n * line1[1]->line1[0] AND line2[0]->line2[1].\n * @param line1 - Line = [p1, p2]\n * @param line2 - Line = [p3, p4]\n * @returns The angle between two lines in degrees.\n */\nexport default function angleBetweenLines(line1: Line, line2: Line): number {\n  const is3D = line1[0].length === 3;\n  return is3D\n    ? angleBetween3DLines(line1 as Line3D, line2 as Line3D)\n    : angleBetween2DLines(line1 as Line2D, line2 as Line2D);\n}\n","import {\n  BaseVolumeViewport,\n  getEnabledElement,\n  Types,\n} from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nimport { PublicToolProps, ToolProps, EventTypes } from '../types';\n\n/**\n * The PlanarRotateTool is a tool that allows the user to rotate\n * the image by pressing the mouse click and dragging\n */\nclass PlanarRotateTool extends BaseTool {\n  static toolName;\n  touchDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n  mouseDragCallback: (evt: EventTypes.MouseDragEventType) => void;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this.touchDragCallback = this._dragCallback.bind(this);\n    this.mouseDragCallback = this._dragCallback.bind(this);\n  }\n\n  _dragCallback(evt: EventTypes.MouseDragEventType) {\n    const { element, currentPoints, startPoints } = evt.detail;\n    const currentPointWorld = currentPoints.world;\n    const startPointWorld = startPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const width = element.clientWidth;\n    const height = element.clientHeight;\n\n    const centerCanvas: Types.Point2 = [width * 0.5, height * 0.5];\n    const centerWorld = viewport.canvasToWorld(centerCanvas);\n\n    let angle = angleBetweenLines(\n      [startPointWorld, centerWorld],\n      [centerWorld, currentPointWorld]\n    );\n\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n    const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n    const cross = vec3.cross(vec3.create(), v1, v2);\n    if (vec3.dot(viewPlaneNormal, cross) > 0) {\n      angle = -angle;\n    }\n\n    if (Number.isNaN(angle)) {\n      return;\n    }\n\n    if (viewport instanceof BaseVolumeViewport) {\n      const rotAngle = (angle * Math.PI) / 180;\n      const rotMat = mat4.identity(new Float32Array(16));\n      mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n      const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n      viewport.setCamera({ viewUp: rotatedViewUp as Types.Point3 });\n    } else {\n      const { rotation } = (viewport as Types.IStackViewport).getProperties();\n      viewport.setProperties({ rotation: rotation + angle });\n    }\n\n    viewport.render();\n  }\n}\n\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { MouseWheelEventType } from '../types/EventTypes';\nimport scroll from '../utilities/scroll';\n\n/**\n * The StackScrollMouseWheelTool is a tool that allows the user to scroll through a\n * stack of images using the mouse wheel\n */\nclass StackScrollMouseWheelTool extends BaseTool {\n  static toolName;\n\n  _configuration: any;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        invert: false,\n        debounceIfNotLoaded: true,\n        loop: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType): void {\n    const { wheel, element } = evt.detail;\n    const { direction } = wheel;\n    const { invert } = this.configuration;\n    const { viewport } = getEnabledElement(element);\n    const delta = direction * (invert ? -1 : 1);\n\n    const targetId = this.getTargetId(viewport);\n    const volumeId = targetId.split('volumeId:')[1];\n\n    scroll(viewport, {\n      delta,\n      debounceLoading: this.configuration.debounceIfNotLoaded,\n      loop: this.configuration.loop,\n      volumeId,\n    });\n  }\n}\n\nStackScrollMouseWheelTool.toolName = 'StackScrollMouseWheel';\nexport default StackScrollMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { mat4, vec3 } from 'gl-matrix';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { MouseWheelEventType } from '../types/EventTypes';\n\nconst DIRECTIONS = {\n  X: [1, 0, 0],\n  Y: [0, 1, 0],\n  Z: [0, 0, 1],\n  CUSTOM: [],\n};\n\n/**\n * Tool that rotates the camera on mouse wheel.\n * It rotates the camera around the focal point, and around a defined axis. Default\n * axis is set to be Z axis, but it can be configured to any custom normalized axis.\n *\n */\nclass VolumeRotateMouseWheelTool extends BaseTool {\n  static toolName;\n  _configuration: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        direction: DIRECTIONS.Z,\n        rotateIncrementDegrees: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  mouseWheelCallback(evt: MouseWheelEventType) {\n    // https://github.com/kitware/vtk-js/blob/HEAD/Sources/Interaction/Manipulators/MouseCameraUnicamRotateManipulator/index.js#L73\n    const { element, wheel } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { direction, rotateIncrementDegrees } = this.configuration;\n\n    const camera = viewport.getCamera();\n    const { viewUp, position, focalPoint } = camera;\n\n    const { direction: deltaY } = wheel;\n\n    const [cx, cy, cz] = focalPoint;\n    const [ax, ay, az] = direction;\n\n    const angle = deltaY * rotateIncrementDegrees;\n\n    // position[3] = 1.0\n    // focalPoint[3] = 1.0\n    // viewUp[3] = 0.0\n\n    const newPosition: Types.Point3 = [0, 0, 0];\n    const newFocalPoint: Types.Point3 = [0, 0, 0];\n    const newViewUp: Types.Point3 = [0, 0, 0];\n\n    const transform = mat4.identity(new Float32Array(16));\n    mat4.translate(transform, transform, [cx, cy, cz]);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    mat4.translate(transform, transform, [-cx, -cy, -cz]);\n    vec3.transformMat4(newPosition, position, transform);\n    vec3.transformMat4(newFocalPoint, focalPoint, transform);\n\n    mat4.identity(transform);\n    mat4.rotate(transform, transform, angle, [ax, ay, az]);\n    vec3.transformMat4(<Types.Point3>newViewUp, viewUp, transform);\n\n    viewport.setCamera({\n      position: newPosition,\n      viewUp: newViewUp,\n      focalPoint: newFocalPoint,\n    });\n\n    viewport.render();\n  }\n}\n\nVolumeRotateMouseWheelTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateMouseWheelTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport jumpToWorld from '../utilities/viewport/jumpToWorld';\nimport { PublicToolProps, ToolProps } from '../types';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\n\n/**\n * On a Maximum Intensity Projection (MIP) viewport, MIPJumpToClickTool allows the\n * user to click on a point in the MIP and the targetViewportIdS (provided in the\n * tool configuration) will be scrolled (jumped) to the location of the point with\n * the highest intensity value in the MIP.\n */\nclass MIPJumpToClickTool extends BaseTool {\n  static toolName;\n\n  _bounds: any;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        targetViewportIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Handles the click event, and move the camera's focal point the brightest\n   * point that is in the line of sight of camera. This function 1) search for the\n   * brightest point in the line of sight, 2) move the camera to that point,\n   * this triggers a cameraModified event which then 4) moves all other synced\n   * viewports and their crosshairs.\n   *\n   * @param evt - click event\n   */\n  mouseClickCallback(evt): void {\n    const { element, currentPoints } = evt.detail;\n\n    // 1. Getting the enabled element\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    // 2. Getting the target volume that is clicked on\n    const targetId = this.getTargetId(viewport as Types.IVolumeViewport);\n\n    if (!targetId.startsWith('volumeId')) {\n      throw new Error(\n        `MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`\n      );\n    }\n\n    const volumeId = targetId.split('volumeId:')[1];\n\n    // 3. Criteria function to search for the point (maximum intensity)\n    let maxIntensity = -Infinity;\n    const maxFn = (intensity, point) => {\n      if (intensity > maxIntensity) {\n        maxIntensity = intensity;\n        return point;\n      }\n    };\n\n    // 4. Search for the brightest point location in the line of sight\n    const brightestPoint = getPointInLineOfSightWithCriteria(\n      viewport as Types.IVolumeViewport,\n      currentPoints.world,\n      volumeId,\n      maxFn\n    );\n\n    if (!brightestPoint || !brightestPoint.length) {\n      return;\n    }\n\n    const { targetViewportIds, toolGroupId } = this.configuration;\n    // TODO - consider making this a utility\n    const viewports = renderingEngine.getViewports().filter((vp) => {\n      if (targetViewportIds?.indexOf(vp.id) >= 0) {\n        return true;\n      }\n      const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n      if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n        return true;\n      }\n      return false;\n    });\n\n    // 6. Update all the targetedViewports to jump\n    viewports.forEach((viewport) => {\n      // Todo: current limitation is that we cannot jump in viewports\n      // that don't belong to the renderingEngine of the source clicked viewport\n      if (viewport instanceof VolumeViewport) {\n        jumpToWorld(viewport, brightestPoint);\n      } else {\n        console.warn(\n          'Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport'\n        );\n      }\n    });\n  }\n}\n\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { LengthAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * LengthTool let you draw annotations that measures the length of two drawing\n * points on a slice. You can use the LengthTool in all imaging planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(LengthTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(LengthTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(LengthTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n\n */\n\nclass LengthTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): LengthAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: LengthAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: LengthAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as LengthAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      // Todo: move these into annotationTool class\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      // Need to update to sync with annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    // TODO clean up, this doesn't need a length per volume, it has no stats derived from volumes.\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const scale = getCalibratedScale(image);\n\n      const length = this._calculateLength(worldPos1, worldPos2) / scale;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n\n      this._isInsideVolume(index1, index2, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      // TODO -> Do we instead want to clip to the bounds of the volume and only include that portion?\n      // Seems like a lot of work for an unrealistic case. At the moment bail out of stat calculation if either\n      // corner is off the canvas.\n\n      // todo: add insideVolume calculation, for removing tool if outside\n      cachedStats[targetId] = {\n        length,\n        unit: getCalibratedLengthUnits(null, image),\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { length, unit } = cachedVolumeStats;\n\n  // Can be null on load\n  if (length === undefined || length === null || isNaN(length)) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(length)} ${unit}`];\n\n  return textLines;\n}\n\nLengthTool.toolName = 'Length';\nexport default LengthTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\n\nimport { AnnotationTool } from './base';\n\nimport {\n  getEnabledElementByIds,\n  getEnabledElement,\n  utilities as csUtils,\n  Enums,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getToolGroup,\n  getToolGroupForViewport,\n} from '../store/ToolGroupManager';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../stateManagement/annotation/annotationState';\n\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\n\nimport * as lineSegment from '../utilities/math/line';\nimport {\n  Annotation,\n  Annotations,\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../types';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { RENDERING_DEFAULTS } = CONSTANTS;\n\n// TODO: nested config is weird\ninterface ToolConfiguration {\n  configuration?: {\n    getReferenceLineColor?: (viewportId: string) => string;\n    getReferenceLineControllable?: (viewportId: string) => boolean;\n    getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n    getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n    referenceLinesCenterGapRadius?: number;\n    shadow?: boolean;\n    autopan?: {\n      enabled: boolean;\n      panSize: number;\n    };\n    mobile?: {\n      enabled: boolean;\n      opacity: number;\n      handleRadius: number;\n    };\n  };\n}\n\ninterface CrosshairsAnnotation extends Annotation {\n  data: {\n    handles: {\n      rotationPoints: any[]; // rotation handles, used for rotation interactions\n      slabThicknessPoints: any[]; // slab thickness handles, used for setting the slab thickness\n      activeOperation: number | null; // 0 translation, 1 rotation handles, 2 slab thickness handles\n      toolCenter: Types.Point3;\n    };\n    activeViewportIds: string[]; // a list of the viewport ids connected to the reference lines being translated\n    viewportId: string;\n  };\n}\n\nfunction defaultReferenceLineColor() {\n  return 'rgb(0, 200, 0)';\n}\n\nfunction defaultReferenceLineControllable() {\n  return true;\n}\n\nfunction defaultReferenceLineDraggableRotatable() {\n  return true;\n}\n\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n  return true;\n}\n\nconst OPERATION = {\n  DRAG: 1,\n  ROTATE: 2,\n  SLAB: 3,\n};\n\nconst EPSILON = 1e-3;\n\n/**\n * CrosshairsTool is a tool that provides reference lines between different viewports\n * of a toolGroup. Using crosshairs, you can jump to a specific location in one\n * viewport and the rest of the viewports in the toolGroup will be aligned to that location.\n * Crosshairs have grababble handles that can be used to rotate and translate the\n * reference lines. They can also be used to set the slab thickness of the viewports\n * by modifying the slab thickness handles.\n *\n */\nclass CrosshairsTool extends AnnotationTool {\n  static toolName;\n\n  toolCenter: Types.Point3 = [0, 0, 0]; // NOTE: it is assumed that all the active/linked viewports share the same crosshair center.\n  // This because the rotation operation rotates also all the other active/intersecting reference lines of the same angle\n  _getReferenceLineColor?: (viewportId: string) => string;\n  _getReferenceLineControllable?: (viewportId: string) => boolean;\n  _getReferenceLineDraggableRotatable?: (viewportId: string) => boolean;\n  _getReferenceLineSlabThicknessControlsOn?: (viewportId: string) => boolean;\n  editData: {\n    annotation: any;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse'],\n      configuration: {\n        shadow: true,\n        // renders a colored circle on top right of the viewports whose color\n        // matches the color of the reference line\n        viewportIndicators: true,\n        // Auto pan is a configuration which will update pan\n        // other viewports in the toolGroup if the center of the crosshairs\n        // is outside of the viewport. This might be useful for the case\n        // when the user is scrolling through an image (usually in the zoomed view)\n        // and the crosshairs will eventually get outside of the viewport for\n        // the other viewports.\n        autoPan: {\n          enabled: false,\n          panSize: 10,\n        },\n        // radius of the area around the intersection of the planes, in which\n        // the reference lines will not be rendered. This is only used when\n        // having 3 viewports in the toolGroup.\n        referenceLinesCenterGapRadius: 20,\n        // actorUIDs for slabThickness application, if not defined, the slab thickness\n        // will be applied to all actors of the viewport\n        filterActorUIDsToSetSlabThickness: [],\n        // blend mode for slabThickness modifications\n        slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n        mobile: {\n          enabled: false,\n          opacity: 0.8,\n          handleRadius: 9,\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._getReferenceLineColor =\n      toolProps.configuration?.getReferenceLineColor ||\n      defaultReferenceLineColor;\n    this._getReferenceLineControllable =\n      toolProps.configuration?.getReferenceLineControllable ||\n      defaultReferenceLineControllable;\n    this._getReferenceLineDraggableRotatable =\n      toolProps.configuration?.getReferenceLineDraggableRotatable ||\n      defaultReferenceLineDraggableRotatable;\n    this._getReferenceLineSlabThicknessControlsOn =\n      toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n      defaultReferenceLineSlabThicknessControlsOn;\n  }\n\n  /**\n   * Gets the camera from the viewport, and adds crosshairs annotation for the viewport\n   * to the annotationManager. If any annotation is found in the annotationManager, it\n   * overwrites it.\n   * @param viewportInfo - The viewportInfo for the viewport to add the crosshairs\n   * @returns viewPlaneNormal and center of viewport canvas in world space\n   */\n  initializeViewport = ({\n    renderingEngineId,\n    viewportId,\n  }: Types.IViewportId): {\n    normal: Types.Point3;\n    point: Types.Point3;\n  } => {\n    const enabledElement = getEnabledElementByIds(\n      viewportId,\n      renderingEngineId\n    );\n    const { FrameOfReferenceUID, viewport } = enabledElement;\n    const { element } = viewport;\n    const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n\n    // Check if there is already annotation for this viewport\n    let annotations = this._getAnnotations(enabledElement);\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (annotations.length) {\n      // If found, it will override it by removing the annotation and adding it later\n      removeAnnotation(annotations[0].annotationUID);\n    }\n\n    const annotation = {\n      highlighted: false,\n      metadata: {\n        cameraPosition: <Types.Point3>[...position],\n        cameraFocalPoint: <Types.Point3>[...focalPoint],\n        FrameOfReferenceUID,\n        toolName: this.getToolName(),\n      },\n      data: {\n        handles: {\n          rotationPoints: [], // rotation handles, used for rotation interactions\n          slabThicknessPoints: [], // slab thickness handles, used for setting the slab thickness\n          toolCenter: this.toolCenter,\n        },\n        activeOperation: null, // 0 translation, 1 rotation handles, 2 slab thickness handles\n        activeViewportIds: [], // a list of the viewport ids connected to the reference lines being translated\n        viewportId,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    return {\n      normal: viewPlaneNormal,\n      point: viewport.canvasToWorld([\n        viewport.canvas.clientWidth / 2,\n        viewport.canvas.clientHeight / 2,\n      ]),\n    };\n  };\n\n  _getViewportsInfo = () => {\n    const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    return viewports;\n  };\n\n  onSetToolActive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    // Upon new setVolumes on viewports we need to update the crosshairs\n    // reference points in the new space, so we subscribe to the event\n    // and update the reference points accordingly.\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    this._subscribeToViewportNewVolumeSet(viewportsInfo);\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolPassive() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolEnabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this.computeToolCenter(viewportsInfo);\n  }\n\n  onSetToolDisabled() {\n    const viewportsInfo = this._getViewportsInfo();\n\n    this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n\n    // Crosshairs annotations in the state\n    // has no value when the tool is disabled\n    // since viewports can change (zoom, pan, scroll)\n    // between disabled and enabled/active states.\n    // so we just remove the annotations from the state\n    viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n      const enabledElement = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n\n      if (!enabledElement) {\n        return;\n      }\n\n      const annotations = this._getAnnotations(enabledElement);\n\n      if (annotations?.length) {\n        annotations.forEach((annotation) => {\n          removeAnnotation(annotation.annotationUID);\n        });\n      }\n    });\n  }\n\n  /**\n   * When activated, it initializes the crosshairs. It begins by computing\n   * the intersection of viewports associated with the crosshairs instance.\n   * When all three views are accessible, the intersection (e.g., crosshairs tool centre)\n   * will be an exact point in space; however, with two viewports, because the\n   * intersection of two planes is a line, it assumes the last view is between the centre\n   * of the two rendering viewports.\n   * @param viewportsInfo Array of viewportInputs which each item containing {viewportId, renderingEngineId}\n   */\n  computeToolCenter = (viewportsInfo): void => {\n    if (!viewportsInfo.length || viewportsInfo.length === 1) {\n      throw new Error(\n        'For crosshairs to operate, at least two viewports must be given.'\n      );\n    }\n\n    // Todo: handle two same view viewport, or more than 3 viewports\n    const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n\n    // Initialize first viewport\n    const { normal: normal1, point: point1 } =\n      this.initializeViewport(firstViewport);\n\n    // Initialize second viewport\n    const { normal: normal2, point: point2 } =\n      this.initializeViewport(secondViewport);\n\n    let normal3 = <Types.Point3>[0, 0, 0];\n    let point3 = vec3.create();\n\n    // If there are three viewports\n    if (thirdViewport) {\n      ({ normal: normal3, point: point3 } =\n        this.initializeViewport(thirdViewport));\n    } else {\n      // If there are only two views (viewport) associated with the crosshairs:\n      // In this situation, we don't have a third information to find the\n      // exact intersection, and we \"assume\" the third view is looking at\n      // a location in between the first and second view centers\n      vec3.add(point3, point1, point2);\n      vec3.scale(point3, point3, 0.5);\n      vec3.cross(normal3, normal1, normal2);\n    }\n\n    // Planes of each viewport\n    const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n    const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n    const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n\n    // Calculating the intersection of 3 planes\n    // prettier-ignore\n    this.toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane)\n\n    // assuming all viewports are in the same rendering engine\n    const { renderingEngine } = getEnabledElementByIds(\n      viewportsInfo[0].viewportId,\n      viewportsInfo[0].renderingEngineId\n    );\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * addNewAnnotation acts as jump for the crosshairs tool. It is called when\n   * the user clicks on the image. It does not store the annotation in the stateManager though.\n   *\n   * @param evt - The mouse event\n   * @param interactionType - The type of interaction (e.g., mouse, touch, etc.)\n   * @returns Crosshairs annotation\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CrosshairsAnnotation => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { currentPoints } = eventDetail;\n    const jumpWorld = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this._jump(enabledElement, jumpWorld);\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredAnnotations = this.filterInteractableAnnotationsForElement(\n      viewport.element,\n      annotations\n    );\n\n    // viewport Annotation\n    const { data } = filteredAnnotations[0];\n\n    const { rotationPoints } = data.handles;\n    const viewportIdArray = [];\n    // put all the draggable reference lines in the viewportIdArray\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n      viewportIdArray.push(otherViewport.id);\n      // rotation handles are two per viewport\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n    // set translation operation\n    data.handles.activeOperation = OPERATION.DRAG;\n\n    evt.preventDefault();\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n    return filteredAnnotations[0];\n  };\n\n  cancel = () => {\n    console.log('Not implemented yet');\n  };\n\n  /**\n   * It checks if the mouse click is near crosshairs handles, if yes\n   * it returns the handle location. If the mouse click is not near any\n   * of the handles, it does not return anything.\n   *\n   * @param element - The element that the tool is attached to.\n   * @param annotation - The annotation object associated with the annotation\n   * @param canvasCoords - The coordinates of the mouse click on canvas\n   * @param proximity - The distance from the mouse cursor to the point\n   * that is considered \"near\".\n   * @returns The handle that is closest to the cursor, or null if the cursor\n   * is not near any of the handles.\n   */\n  getHandleNearImagePoint(\n    element: HTMLDivElement,\n    annotation: Annotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): ToolHandle | undefined {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    let point = this._getRotationHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n\n    point = this._getSlabThicknessHandleNearImagePoint(\n      viewport,\n      annotation,\n      canvasCoords,\n      proximity\n    );\n\n    if (point !== null) {\n      return point;\n    }\n  }\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n\n    // NOTE: handle index or coordinates are not used when dragging.\n    // This because the handle points are actually generated in the renderTool and they are a derivative\n    // from the camera variables of the viewports and of the slab thickness variable.\n    // Remember that the translation and rotation operations operate on the camera\n    // variables and not really on the handles. Similar for the slab thickness.\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * It returns if the canvas point is near the provided crosshairs annotation in the\n   * provided element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CrosshairsAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: Annotation,\n    interactionType: InteractionTypes\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    annotation.highlighted = true;\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  onCameraModified = (evt) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const viewport = enabledElement.viewport as Types.IVolumeViewport;\n\n    const annotations = this._getAnnotations(enabledElement);\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport that the camera modified is originating from\n    const viewportAnnotation =\n      filteredToolAnnotations[0] as CrosshairsAnnotation;\n\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    // -- Update the camera of other linked viewports containing the same volumeId that\n    //    have the same camera in case of translation\n    // -- Update the crosshair center in world coordinates in annotation.\n    // This is necessary because other tools can modify the position of the slices,\n    // e.g. stackScroll tool at wheel scroll. So we update the coordinates of the center always here.\n    // NOTE: rotation and slab thickness handles are created/updated in renderTool.\n    const currentCamera = viewport.getCamera();\n    const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n    const deltaCameraPosition: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.position,\n      oldCameraPosition,\n      deltaCameraPosition\n    );\n\n    const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(\n      currentCamera.focalPoint,\n      oldCameraFocalPoint,\n      deltaCameraFocalPoint\n    );\n\n    // updated cached \"previous\" camera position and focal point\n    viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n    viewportAnnotation.metadata.cameraFocalPoint = [\n      ...currentCamera.focalPoint,\n    ];\n\n    const viewportControllable = this._getReferenceLineControllable(\n      viewport.id\n    );\n    const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(\n      viewport.id\n    );\n    if (\n      !csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n      viewportControllable &&\n      viewportDraggableRotatable\n    ) {\n      // Is camera Modified a TRANSLATION or ROTATION?\n      let isRotation = false;\n\n      // This is guaranteed to be the same diff for both position and focal point\n      // if the camera is modified by pan, zoom, or scroll BUT for rotation of\n      // crosshairs handles it will be different.\n      const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(\n        deltaCameraPosition,\n        deltaCameraFocalPoint,\n        1e-3\n      );\n\n      // NOTE: it is a translation if the the focal point and camera position shifts are the same\n      if (!cameraModifiedSameForPosAndFocalPoint) {\n        isRotation = true;\n      }\n\n      const cameraModifiedInPlane =\n        Math.abs(\n          vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)\n        ) < 1e-2;\n\n      // TRANSLATION\n      // NOTE1: if the camera modified is a result of a pan or zoom don't update the crosshair center\n      // NOTE2: rotation handles are updates in renderTool\n      if (!isRotation && !cameraModifiedInPlane) {\n        this.toolCenter[0] += deltaCameraPosition[0];\n        this.toolCenter[1] += deltaCameraPosition[1];\n        this.toolCenter[2] += deltaCameraPosition[2];\n      }\n    }\n\n    // AutoPan modification\n    if (this.configuration.autoPan?.enabled) {\n      const toolGroup = getToolGroupForViewport(\n        viewport.id,\n        renderingEngine.id\n      );\n\n      const otherViewportIds = toolGroup\n        .getViewportIds()\n        .filter((id) => id !== viewport.id);\n\n      otherViewportIds.forEach((viewportId) => {\n        this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n      });\n    }\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  mouseMoveCallback = (\n    evt: EventTypes.MouseMoveEventType,\n    filteredToolAnnotations: Annotations\n  ): boolean => {\n    const { element, currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n    let imageNeedsUpdate = false;\n\n    for (let i = 0; i < filteredToolAnnotations.length; i++) {\n      const annotation = filteredToolAnnotations[i] as CrosshairsAnnotation;\n\n      if (isAnnotationLocked(annotation)) {\n        continue;\n      }\n\n      const { data, highlighted } = annotation;\n      if (!data.handles) {\n        continue;\n      }\n\n      const previousActiveOperation = data.handles.activeOperation;\n      const previousActiveViewportIds =\n        data.activeViewportIds && data.activeViewportIds.length > 0\n          ? [...data.activeViewportIds]\n          : [];\n\n      // This init are necessary, because when we move the mouse they are not cleaned by _endCallback\n      data.activeViewportIds = [];\n      data.handles.activeOperation = null;\n\n      const handleNearImagePoint = this.getHandleNearImagePoint(\n        element,\n        annotation,\n        canvasCoords,\n        6\n      );\n\n      let near = false;\n      if (handleNearImagePoint) {\n        near = true;\n      } else {\n        near = this._pointNearTool(element, annotation, canvasCoords, 6);\n      }\n\n      const nearToolAndNotMarkedActive = near && !highlighted;\n      const notNearToolAndMarkedActive = !near && highlighted;\n      if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n        annotation.highlighted = !highlighted;\n        imageNeedsUpdate = true;\n      } else if (\n        data.handles.activeOperation !== previousActiveOperation ||\n        !this._areViewportIdArraysEqual(\n          data.activeViewportIds,\n          previousActiveViewportIds\n        )\n      ) {\n        imageNeedsUpdate = true;\n      }\n    }\n\n    return imageNeedsUpdate;\n  };\n\n  filterInteractableAnnotationsForElement = (element, annotations) => {\n    if (!annotations || !annotations.length) {\n      return [];\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n\n    const viewportUIDSpecificCrosshairs = annotations.filter(\n      (annotation) => annotation.data.viewportId === viewportId\n    );\n\n    return viewportUIDSpecificCrosshairs;\n  };\n\n  /**\n   * renders the crosshairs lines and handles in the requestAnimationFrame callback\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, renderingEngine } = enabledElement;\n    const { element } = viewport;\n    const annotations = this._getAnnotations(enabledElement);\n    const camera = viewport.getCamera();\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!annotations?.length || !viewportAnnotation?.data) {\n      // No annotations yet, and didn't just create it as we likely don't have a FrameOfReference/any data loaded yet.\n      return renderStatus;\n    }\n\n    const annotationUID = viewportAnnotation.annotationUID;\n\n    // Get cameras/canvases for each of these.\n    // -- Get two world positions for this canvas in this line (e.g. the diagonal)\n    // -- Convert these world positions to this canvas.\n    // -- Extend/confine this line to fit in this canvas.\n    // -- Render this line.\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n\n    const data = viewportAnnotation.data;\n    const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    const otherViewportAnnotations =\n      this._filterAnnotationsByUniqueViewportOrientations(\n        enabledElement,\n        annotations\n      );\n\n    const referenceLines = [];\n\n    // get canvas information for points and lines (canvas box, canvas horizontal distances)\n    const canvasBox = [0, 0, clientWidth, clientHeight];\n\n    otherViewportAnnotations.forEach((annotation) => {\n      const { data } = annotation;\n\n      data.handles.toolCenter = this.toolCenter;\n\n      const otherViewport = renderingEngine.getViewport(\n        data.viewportId\n      ) as Types.IVolumeViewport;\n\n      const otherCamera = otherViewport.getCamera();\n\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const otherViewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      const otherViewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      // get coordinates for the reference line\n      const { clientWidth, clientHeight } = otherViewport.canvas;\n      const otherCanvasDiagonalLength = Math.sqrt(\n        clientWidth * clientWidth + clientHeight * clientHeight\n      );\n      const otherCanvasCenter: Types.Point2 = [\n        clientWidth * 0.5,\n        clientHeight * 0.5,\n      ];\n      const otherViewportCenterWorld =\n        otherViewport.canvasToWorld(otherCanvasCenter);\n\n      const direction: Types.Point3 = [0, 0, 0];\n      vtkMath.cross(\n        camera.viewPlaneNormal,\n        otherCamera.viewPlaneNormal,\n        direction\n      );\n      vtkMath.normalize(direction);\n      vtkMath.multiplyScalar(\n        <Types.Point3>direction,\n        otherCanvasDiagonalLength\n      );\n\n      const pointWorld0: Types.Point3 = [0, 0, 0];\n      vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n\n      const pointWorld1: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n\n      const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n\n      const otherViewportCenterCanvas = viewport.worldToCanvas(\n        otherViewportCenterWorld\n      );\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        pointCanvas0,\n        otherViewportCenterCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      // Graphic:\n      // Mid -> SlabThickness handle\n      // Short -> Rotation handle\n      //                           Long\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      // Long --- Mid--- Short--- Center --- Short --- Mid --- Long\n      //                            |\n      //                            |\n      //                            |\n      //                          Short\n      //                            |\n      //                            |\n      //                            |\n      //                           Mid\n      //                            |\n      //                            |\n      //                            |\n      //                           Long\n      const canvasVectorFromCenterLong = vec2.create();\n\n      vec2.scale(\n        canvasVectorFromCenterLong,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 100\n      );\n      const canvasVectorFromCenterMid = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterMid,\n        canvasUnitVectorFromCenter,\n        // to maximize the visibility of the controls, they need to be\n        // placed at most at half the length of the shortest side of the canvas.\n        // Chosen 0.4 to have some margin to the edge.\n        canvasMinDimensionLength * 0.4\n      );\n      const canvasVectorFromCenterShort = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterShort,\n        canvasUnitVectorFromCenter,\n        // Chosen 0.2 because is half of 0.4.\n        canvasMinDimensionLength * 0.2\n      );\n      const canvasVectorFromCenterStart = vec2.create();\n      const centerGap = this.configuration.referenceLinesCenterGapRadius;\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        // Don't put a gap if the the third view is missing\n        otherViewportAnnotations.length === 2 ? centerGap : 0\n      );\n\n      // Computing Reference start and end (4 lines per viewport in case of 3 view MPR)\n      const refLinePointOne = vec2.create();\n      const refLinePointTwo = vec2.create();\n      const refLinePointThree = vec2.create();\n      const refLinePointFour = vec2.create();\n\n      let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n      if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n        refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n      vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n      vec2.subtract(\n        refLinePointThree,\n        refLinesCenter,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        refLinePointFour,\n        refLinesCenter,\n        canvasVectorFromCenterLong\n      );\n\n      // Clipping lines to be only included in a box (canvas), we don't want\n      // the lines goes beyond canvas\n      liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n      liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n\n      // Computing rotation handle positions\n      const rotHandleOne = vec2.create();\n      vec2.subtract(\n        rotHandleOne,\n        crosshairCenterCanvas,\n        canvasVectorFromCenterMid\n      );\n\n      const rotHandleTwo = vec2.create();\n      vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n\n      // Computing SlabThickness (st below) position\n\n      // SlabThickness center in canvas\n      let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n      }\n\n      // SlabThickness center in world\n      let stHandlesCenterWorld: Types.Point3 = [...this.toolCenter];\n      if (\n        !otherViewportDraggableRotatable &&\n        otherViewportSlabThicknessControlsOn\n      ) {\n        stHandlesCenterWorld = [...otherViewportCenterWorld];\n      }\n\n      const worldUnitVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n      vtkMath.normalize(worldUnitVectorFromCenter);\n\n      const { viewPlaneNormal } = camera;\n      // @ts-ignore // Todo: fix after vtk pr merged\n      const { matrix } = vtkMatrixBuilder\n        .buildFromDegree()\n        // @ts-ignore fix after vtk pr merged\n        .rotate(90, viewPlaneNormal);\n\n      const worldUnitOrthoVectorFromCenter: Types.Point3 = [0, 0, 0];\n      vec3.transformMat4(\n        worldUnitOrthoVectorFromCenter,\n        worldUnitVectorFromCenter,\n        matrix\n      );\n\n      const slabThicknessValue = otherViewport.getSlabThickness();\n      const worldOrthoVectorFromCenter: Types.Point3 = [\n        ...worldUnitOrthoVectorFromCenter,\n      ];\n      vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n\n      const worldVerticalRefPoint: Types.Point3 = [0, 0, 0];\n      vtkMath.add(\n        stHandlesCenterWorld,\n        worldOrthoVectorFromCenter,\n        worldVerticalRefPoint\n      );\n\n      // convert vertical world distances in canvas coordinates\n      const canvasVerticalRefPoint = viewport.worldToCanvas(\n        worldVerticalRefPoint\n      );\n\n      // points for slab thickness lines\n      const canvasOrthoVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasOrthoVectorFromCenter,\n        stHandlesCenterCanvas,\n        canvasVerticalRefPoint\n      );\n\n      const stLinePointOne = vec2.create();\n      vec2.subtract(\n        stLinePointOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n\n      const stLinePointTwo = vec2.create();\n      vec2.add(\n        stLinePointTwo,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n\n      liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n\n      const stLinePointThree = vec2.create();\n      vec2.add(\n        stLinePointThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointThree,\n        stLinePointThree,\n        canvasOrthoVectorFromCenter\n      );\n\n      const stLinePointFour = vec2.create();\n      vec2.subtract(\n        stLinePointFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterLong\n      );\n      vec2.subtract(\n        stLinePointFour,\n        stLinePointFour,\n        canvasOrthoVectorFromCenter\n      );\n\n      liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n\n      // points for slab thickness handles\n      const stHandleOne = vec2.create();\n      const stHandleTwo = vec2.create();\n      const stHandleThree = vec2.create();\n      const stHandleFour = vec2.create();\n\n      vec2.subtract(\n        stHandleOne,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n      vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n      vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n      vec2.subtract(\n        stHandleThree,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n      vec2.add(\n        stHandleFour,\n        stHandlesCenterCanvas,\n        canvasVectorFromCenterShort\n      );\n      vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n\n      referenceLines.push([\n        otherViewport,\n        refLinePointOne,\n        refLinePointTwo,\n        refLinePointThree,\n        refLinePointFour,\n        stLinePointOne,\n        stLinePointTwo,\n        stLinePointThree,\n        stLinePointFour,\n        rotHandleOne,\n        rotHandleTwo,\n        stHandleOne,\n        stHandleTwo,\n        stHandleThree,\n        stHandleFour,\n      ]);\n    });\n\n    const newRtpoints = [];\n    const newStpoints = [];\n    const viewportColor = this._getReferenceLineColor(viewport.id);\n    const color =\n      viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n    referenceLines.forEach((line, lineIndex) => {\n      // get color for the reference line\n      const otherViewport = line[0];\n      const viewportColor = this._getReferenceLineColor(otherViewport.id);\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n        this.configuration.mobile?.enabled;\n      const selectedViewportId = data.activeViewportIds.find(\n        (id) => id === otherViewport.id\n      );\n\n      let color =\n        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n      let lineWidth = 1;\n\n      const lineActive =\n        data.handles.activeOperation !== null &&\n        data.handles.activeOperation === OPERATION.DRAG &&\n        selectedViewportId;\n\n      if (lineActive) {\n        lineWidth = 2.5;\n      }\n\n      let lineUID = `${lineIndex}`;\n      if (viewportControllable && viewportDraggableRotatable) {\n        lineUID = `${lineIndex}One`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[1],\n          line[2],\n          {\n            color,\n            lineWidth,\n          }\n        );\n\n        lineUID = `${lineIndex}Two`;\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[3],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      } else {\n        drawLineSvg(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          line[2],\n          line[4],\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      if (viewportControllable) {\n        color =\n          viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n\n        const rotHandlesActive =\n          data.handles.activeOperation === OPERATION.ROTATE;\n        const rotationHandles = [line[9], line[10]];\n\n        const rotHandleWorldOne = [\n          viewport.canvasToWorld(line[9]),\n          otherViewport,\n          line[1],\n          line[2],\n        ];\n        const rotHandleWorldTwo = [\n          viewport.canvasToWorld(line[10]),\n          otherViewport,\n          line[3],\n          line[4],\n        ];\n        newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n\n        const slabThicknessHandlesActive =\n          data.handles.activeOperation === OPERATION.SLAB;\n        const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n\n        const slabThicknessHandleWorldOne = [\n          viewport.canvasToWorld(line[11]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldTwo = [\n          viewport.canvasToWorld(line[12]),\n          otherViewport,\n          line[5],\n          line[6],\n        ];\n        const slabThicknessHandleWorldThree = [\n          viewport.canvasToWorld(line[13]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        const slabThicknessHandleWorldFour = [\n          viewport.canvasToWorld(line[14]),\n          otherViewport,\n          line[7],\n          line[8],\n        ];\n        newStpoints.push(\n          slabThicknessHandleWorldOne,\n          slabThicknessHandleWorldTwo,\n          slabThicknessHandleWorldThree,\n          slabThicknessHandleWorldFour\n        );\n\n        if (\n          (lineActive || this.configuration.mobile?.enabled) &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw all handles inactive (rotation and slab thickness)\n          let handleUID = `${lineIndex}One`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n          handleUID = `${lineIndex}Two`;\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (\n          lineActive &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportDraggableRotatable\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw rotation handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'circle',\n            }\n          );\n        } else if (\n          selectedViewportId &&\n          !rotHandlesActive &&\n          !slabThicknessHandlesActive &&\n          viewportSlabThicknessControlsOn\n        ) {\n          const handleUID = `${lineIndex}`;\n          // draw slab thickness handles inactive\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.handleRadius\n                : 3,\n              opacity: this.configuration.mobile?.enabled\n                ? this.configuration.mobile?.opacity\n                : 1,\n              type: 'rect',\n            }\n          );\n        } else if (rotHandlesActive && viewportDraggableRotatable) {\n          const handleUID = `${lineIndex}`;\n          // draw all rotation handles as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            handleUID,\n            rotationHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'circle',\n            }\n          );\n        } else if (\n          slabThicknessHandlesActive &&\n          selectedViewportId &&\n          viewportSlabThicknessControlsOn\n        ) {\n          // draw only the slab thickness handles for the active viewport as active\n          drawHandlesSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            slabThicknessHandles,\n            {\n              color,\n              handleRadius: 2,\n              fill: color,\n              type: 'rect',\n            }\n          );\n        }\n        const slabThicknessValue = otherViewport.getSlabThickness();\n        if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n          // draw slab thickness reference lines\n          lineUID = `${lineIndex}STOne`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[5],\n            line[6],\n            {\n              color,\n              width: 1,\n              lineDash: [2, 3],\n            }\n          );\n\n          lineUID = `${lineIndex}STTwo`;\n          drawLineSvg(\n            svgDrawingHelper,\n            annotationUID,\n            lineUID,\n            line[7],\n            line[8],\n            {\n              color,\n              width: line,\n              lineDash: [2, 3],\n            }\n          );\n        }\n      }\n    });\n\n    renderStatus = true;\n\n    // Save new handles points in annotation\n    data.handles.rotationPoints = newRtpoints;\n    data.handles.slabThicknessPoints = newStpoints;\n\n    if (this.configuration.viewportIndicators) {\n      // render a circle to pin point the viewport color\n      // TODO: This should not be part of the tool, and definitely not part of the renderAnnotation loop\n      const referenceColorCoordinates = [\n        clientWidth * 0.95,\n        clientHeight * 0.05,\n      ] as Types.Point2;\n      const circleRadius = canvasDiagonalLength * 0.01;\n\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        referenceColorCoordinates,\n        circleRadius,\n        { color, fill: color }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _getAnnotations = (enabledElement: Types.IEnabledElement) => {\n    const { viewport } = enabledElement;\n    return getAnnotations(this.getToolName(), viewport.element);\n  };\n\n  _onNewVolume = (e: any) => {\n    const viewportsInfo = this._getViewportsInfo();\n    this.computeToolCenter(viewportsInfo);\n  };\n\n  _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.removeEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _subscribeToViewportNewVolumeSet(viewports) {\n    viewports.forEach(({ viewportId, renderingEngineId }) => {\n      const { viewport } = getEnabledElementByIds(\n        viewportId,\n        renderingEngineId\n      );\n      const { element } = viewport;\n\n      element.addEventListener(\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\n        this._onNewVolume\n      );\n    });\n  }\n\n  _autoPanViewportIfNecessary(\n    viewportId: string,\n    renderingEngine: Types.IRenderingEngine\n  ): void {\n    // 1. Check if the toolCenter is outside the viewport\n    // 2. If it is outside, pan the viewport to fit in the toolCenter\n\n    const viewport = renderingEngine.getViewport(viewportId);\n    const { clientWidth, clientHeight } = viewport.canvas;\n\n    const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n\n    // pan the viewport to fit the toolCenter in the direction\n    // that is out of bounds\n    const pan = this.configuration.autoPan.panSize;\n\n    const visiblePointCanvas = <Types.Point2>[\n      toolCenterCanvas[0],\n      toolCenterCanvas[1],\n    ];\n\n    if (toolCenterCanvas[0] < 0) {\n      visiblePointCanvas[0] = pan;\n    } else if (toolCenterCanvas[0] > clientWidth) {\n      visiblePointCanvas[0] = clientWidth - pan;\n    }\n\n    if (toolCenterCanvas[1] < 0) {\n      visiblePointCanvas[1] = pan;\n    } else if (toolCenterCanvas[1] > clientHeight) {\n      visiblePointCanvas[1] = clientHeight - pan;\n    }\n\n    if (\n      visiblePointCanvas[0] === toolCenterCanvas[0] &&\n      visiblePointCanvas[1] === toolCenterCanvas[1]\n    ) {\n      return;\n    }\n\n    const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n\n    const deltaPointsWorld = [\n      visiblePointWorld[0] - this.toolCenter[0],\n      visiblePointWorld[1] - this.toolCenter[1],\n      visiblePointWorld[2] - this.toolCenter[2],\n    ];\n\n    const camera = viewport.getCamera();\n    const { focalPoint, position } = camera;\n\n    const updatedPosition = <Types.Point3>[\n      position[0] - deltaPointsWorld[0],\n      position[1] - deltaPointsWorld[1],\n      position[2] - deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] - deltaPointsWorld[0],\n      focalPoint[1] - deltaPointsWorld[1],\n      focalPoint[2] - deltaPointsWorld[2],\n    ];\n\n    viewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    viewport.render();\n  }\n\n  _areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n    if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n      return false;\n    }\n\n    viewportIdArrayOne.forEach((id) => {\n      let itemFound = false;\n      for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n        if (id === viewportIdArrayTwo[i]) {\n          itemFound = true;\n          break;\n        }\n      }\n      if (itemFound === false) {\n        return false;\n      }\n    });\n\n    return true;\n  };\n\n  // It filters the viewports with crosshairs and only return viewports\n  // that have different camera.\n  _getAnnotationsForViewportsWithDifferentCameras = (\n    enabledElement,\n    annotations\n  ) => {\n    const { viewportId, renderingEngine, viewport } = enabledElement;\n\n    const otherViewportAnnotations = annotations.filter(\n      (annotation) => annotation.data.viewportId !== viewportId\n    );\n\n    if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, position } = camera;\n\n    const viewportsWithDifferentCameras = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { viewportId } = annotation.data;\n        const targetViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfTarget = targetViewport.getCamera();\n\n        return !(\n          csUtils.isEqual(\n            cameraOfTarget.viewPlaneNormal,\n            viewPlaneNormal,\n            1e-2\n          ) && csUtils.isEqual(cameraOfTarget.position, position, 1)\n        );\n      }\n    );\n\n    return viewportsWithDifferentCameras;\n  };\n\n  _filterViewportWithSameOrientation = (\n    enabledElement,\n    referenceAnnotation,\n    annotations\n  ) => {\n    const { renderingEngine } = enabledElement;\n    const { data } = referenceAnnotation;\n    const viewport = renderingEngine.getViewport(data.viewportId);\n\n    const linkedViewportAnnotations = annotations.filter((annotation) => {\n      const { data } = annotation;\n      const otherViewport = renderingEngine.getViewport(data.viewportId);\n      const otherViewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n\n      return otherViewportControllable === true;\n    });\n\n    if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n      return [];\n    }\n\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherViewportsAnnotationsWithSameCameraDirection =\n      linkedViewportAnnotations.filter((annotation) => {\n        const { viewportId } = annotation.data;\n        const otherViewport = renderingEngine.getViewport(viewportId);\n        const otherCamera = otherViewport.getCamera();\n        const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n        vtkMath.normalize(otherViewPlaneNormal);\n\n        return (\n          csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n          csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2)\n        );\n      });\n\n    return otherViewportsAnnotationsWithSameCameraDirection;\n  };\n\n  _filterAnnotationsByUniqueViewportOrientations = (\n    enabledElement,\n    annotations\n  ) => {\n    const { renderingEngine, viewport } = enabledElement;\n    const camera = viewport.getCamera();\n    const viewPlaneNormal = camera.viewPlaneNormal;\n    vtkMath.normalize(viewPlaneNormal);\n\n    const otherLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable === true\n        );\n      }\n    );\n\n    const otherViewportsAnnotationsWithUniqueCameras = [];\n    // Iterate first on other viewport from the same scene linked\n    for (\n      let i = 0;\n      i < otherLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const otherViewportControllable = this._getReferenceLineControllable(\n          otherViewport.id\n        );\n\n        return (\n          viewport !== otherViewport &&\n          // scene === otherScene &&\n          otherViewportControllable !== true\n        );\n      }\n    );\n\n    // Iterate second on other viewport from the same scene non linked\n    for (\n      let i = 0;\n      i < otherNonLinkedViewportAnnotationsFromSameScene.length;\n      ++i\n    ) {\n      const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    // Iterate on all the viewport\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n      const annotation = otherViewportAnnotations[i];\n      if (\n        otherViewportsAnnotationsWithUniqueCameras.some(\n          (element) => element === annotation\n        )\n      ) {\n        continue;\n      }\n\n      const { viewportId } = annotation.data;\n      const otherViewport = renderingEngine.getViewport(viewportId);\n      const otherCamera = otherViewport.getCamera();\n      const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n      vtkMath.normalize(otherViewPlaneNormal);\n\n      if (\n        csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n        csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)\n      ) {\n        continue;\n      }\n\n      let cameraFound = false;\n      for (\n        let jj = 0;\n        jj < otherViewportsAnnotationsWithUniqueCameras.length;\n        ++jj\n      ) {\n        const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n        const { viewportId } = annotation.data;\n        const stockedViewport = renderingEngine.getViewport(viewportId);\n        const cameraOfStocked = stockedViewport.getCamera();\n\n        if (\n          csUtils.isEqual(\n            cameraOfStocked.viewPlaneNormal,\n            otherCamera.viewPlaneNormal,\n            1e-2\n          ) &&\n          csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)\n        ) {\n          cameraFound = true;\n        }\n      }\n\n      if (!cameraFound) {\n        otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n      }\n    }\n\n    return otherViewportsAnnotationsWithUniqueCameras;\n  };\n\n  _checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n    const actors = viewport.getActors();\n    const otherViewportActors = otherViewport.getActors();\n\n    let sameScene = true;\n\n    actors.forEach((actor) => {\n      if (\n        actors.length !== otherViewportActors.length ||\n        otherViewportActors.find(({ uid }) => uid === actor.uid) === undefined\n      ) {\n        sameScene = false;\n      }\n    });\n\n    return sameScene;\n  };\n\n  _jump = (enabledElement, jumpWorld) => {\n    state.isInteractingWithTool = true;\n    const { viewport, renderingEngine } = enabledElement;\n\n    const annotations = this._getAnnotations(enabledElement);\n\n    const delta: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n\n    // TRANSLATION\n    // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n    const otherViewportAnnotations =\n      this._getAnnotationsForViewportsWithDifferentCameras(\n        enabledElement,\n        annotations\n      );\n\n    const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n      (annotation) => {\n        const { data } = annotation;\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n\n        const sameScene = this._checkIfViewportsRenderingSameScene(\n          viewport,\n          otherViewport\n        );\n\n        return (\n          this._getReferenceLineControllable(otherViewport.id) &&\n          this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n          sameScene\n        );\n      }\n    );\n\n    if (viewportsAnnotationsToUpdate.length === 0) {\n      state.isInteractingWithTool = false;\n      return false;\n    }\n\n    this._applyDeltaShiftToSelectedViewportCameras(\n      renderingEngine,\n      viewportsAnnotationsToUpdate,\n      delta\n    );\n\n    state.isInteractingWithTool = false;\n\n    return true;\n  };\n\n  _activateModify = (element) => {\n    // mobile sometimes has lingering interaction even when touchEnd triggers\n    // this check allows for multiple handles to be active which doesn't affect\n    // tool usage.\n    state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    this.editData.annotation.data.handles.activeOperation = null;\n    this.editData.annotation.data.activeViewportIds = [];\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    this.editData = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const requireSameOrientation = false;\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      requireSameOrientation\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const delta = eventDetail.deltaPoints.world;\n\n    if (\n      Math.abs(delta[0]) < 1e-3 &&\n      Math.abs(delta[1]) < 1e-3 &&\n      Math.abs(delta[2]) < 1e-3\n    ) {\n      return;\n    }\n\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const annotations = this._getAnnotations(\n      enabledElement\n    ) as CrosshairsAnnotation[];\n    const filteredToolAnnotations =\n      this.filterInteractableAnnotationsForElement(element, annotations);\n\n    // viewport Annotation\n    const viewportAnnotation = filteredToolAnnotations[0];\n    if (!viewportAnnotation) {\n      return;\n    }\n\n    const { handles } = viewportAnnotation.data;\n    const { currentPoints } = evt.detail;\n    const canvasCoords = currentPoints.canvas;\n\n    if (handles.activeOperation === OPERATION.DRAG) {\n      // TRANSLATION\n      // get the annotation of the other viewport which are parallel to the delta shift and are of the same scene\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      this._applyDeltaShiftToSelectedViewportCameras(\n        renderingEngine,\n        viewportsAnnotationsToUpdate,\n        delta\n      );\n    } else if (handles.activeOperation === OPERATION.ROTATE) {\n      // ROTATION\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportDraggableRotatable =\n            this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportDraggableRotatable === true\n          );\n        }\n      );\n\n      const dir1 = vec2.create();\n      const dir2 = vec2.create();\n\n      const center: Types.Point3 = [\n        this.toolCenter[0],\n        this.toolCenter[1],\n        this.toolCenter[2],\n      ];\n\n      const centerCanvas = viewport.worldToCanvas(center);\n\n      const finalPointCanvas = eventDetail.currentPoints.canvas;\n      const originalPointCanvas = vec2.create();\n      vec2.sub(\n        originalPointCanvas,\n        finalPointCanvas,\n        eventDetail.deltaPoints.canvas\n      );\n      vec2.sub(dir1, originalPointCanvas, <vec2>centerCanvas);\n      vec2.sub(dir2, finalPointCanvas, <vec2>centerCanvas);\n\n      let angle = vec2.angle(dir1, dir2);\n\n      if (\n        this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)\n      ) {\n        angle *= -1;\n      }\n\n      // Rounding the angle to allow rotated handles to be undone\n      // If we don't round and rotate handles clockwise by 0.0131233 radians,\n      // there's no assurance that the counter-clockwise rotation occurs at\n      // precisely -0.0131233, resulting in the drawn annotations being lost.\n      angle = Math.round(angle * 100) / 100;\n\n      const rotationAxis = viewport.getCamera().viewPlaneNormal;\n      // @ts-ignore : vtkjs incorrect typing\n      const { matrix } = vtkMatrixBuilder\n        .buildFromRadian()\n        .translate(center[0], center[1], center[2])\n        // @ts-ignore\n        .rotate(angle, rotationAxis) //todo: why we are passing\n        .translate(-center[0], -center[1], -center[2]);\n\n      const otherViewportsIds = [];\n      // update camera for the other viewports.\n      // NOTE: The lines then are rendered by the onCameraModified\n      viewportsAnnotationsToUpdate.forEach((annotation) => {\n        const { data } = annotation;\n        data.handles.toolCenter = center;\n\n        const otherViewport = renderingEngine.getViewport(data.viewportId);\n        const camera = otherViewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n\n        viewUp[0] += position[0];\n        viewUp[1] += position[1];\n        viewUp[2] += position[2];\n\n        vec3.transformMat4(focalPoint, focalPoint, matrix);\n        vec3.transformMat4(position, position, matrix);\n        vec3.transformMat4(viewUp, viewUp, matrix);\n\n        viewUp[0] -= position[0];\n        viewUp[1] -= position[1];\n        viewUp[2] -= position[2];\n\n        otherViewport.setCamera({\n          position,\n          viewUp,\n          focalPoint,\n        });\n        otherViewportsIds.push(otherViewport.id);\n      });\n      renderingEngine.renderViewports(otherViewportsIds);\n    } else if (handles.activeOperation === OPERATION.SLAB) {\n      // SLAB THICKNESS\n      // this should be just the active one under the mouse,\n      const otherViewportAnnotations =\n        this._getAnnotationsForViewportsWithDifferentCameras(\n          enabledElement,\n          annotations\n        );\n\n      const referenceAnnotations = otherViewportAnnotations.filter(\n        (annotation) => {\n          const { data } = annotation;\n          const otherViewport = renderingEngine.getViewport(data.viewportId);\n          const otherViewportControllable = this._getReferenceLineControllable(\n            otherViewport.id\n          );\n          const otherViewportSlabThicknessControlsOn =\n            this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n          return (\n            otherViewportControllable === true &&\n            otherViewportSlabThicknessControlsOn === true &&\n            viewportAnnotation.data.activeViewportIds.find(\n              (id) => id === otherViewport.id\n            )\n          );\n        }\n      );\n\n      if (referenceAnnotations.length === 0) {\n        return;\n      }\n      const viewportsAnnotationsToUpdate =\n        this._filterViewportWithSameOrientation(\n          enabledElement,\n          referenceAnnotations[0],\n          annotations\n        );\n\n      const viewportsIds = [];\n      viewportsIds.push(viewport.id);\n      viewportsAnnotationsToUpdate.forEach(\n        (annotation: CrosshairsAnnotation) => {\n          const { data } = annotation;\n\n          const otherViewport = renderingEngine.getViewport(\n            data.viewportId\n          ) as Types.IVolumeViewport;\n          const camera = otherViewport.getCamera();\n          const normal = camera.viewPlaneNormal;\n\n          const dotProd = vtkMath.dot(delta, normal);\n          const projectedDelta: Types.Point3 = [...normal];\n          vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n          if (\n            Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3\n          ) {\n            const mod = Math.sqrt(\n              projectedDelta[0] * projectedDelta[0] +\n                projectedDelta[1] * projectedDelta[1] +\n                projectedDelta[2] * projectedDelta[2]\n            );\n\n            const currentPoint = eventDetail.lastPoints.world;\n            const direction: Types.Point3 = [0, 0, 0];\n\n            const currentCenter: Types.Point3 = [\n              this.toolCenter[0],\n              this.toolCenter[1],\n              this.toolCenter[2],\n            ];\n\n            // use this.toolCenter only if viewportDraggableRotatable\n            const viewportDraggableRotatable =\n              this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n              const { rotationPoints } = this.editData.annotation.data.handles;\n              // Todo: what is a point uid?\n              const otherViewportRotationPoints = rotationPoints.filter(\n                (point) => point[1].uid === otherViewport.id\n              );\n              if (otherViewportRotationPoints.length === 2) {\n                const point1 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[0][3]\n                );\n                const point2 = viewport.canvasToWorld(\n                  otherViewportRotationPoints[1][3]\n                );\n                vtkMath.add(point1, point2, currentCenter);\n                vtkMath.multiplyScalar(<Types.Point3>currentCenter, 0.5);\n              }\n            }\n\n            vtkMath.subtract(currentPoint, currentCenter, direction);\n            const dotProdDirection = vtkMath.dot(direction, normal);\n            const projectedDirection: Types.Point3 = [...normal];\n            vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n            const normalizedProjectedDirection: Types.Point3 = [\n              projectedDirection[0],\n              projectedDirection[1],\n              projectedDirection[2],\n            ];\n            vec3.normalize(\n              normalizedProjectedDirection,\n              normalizedProjectedDirection\n            );\n            const normalizedProjectedDelta: Types.Point3 = [\n              projectedDelta[0],\n              projectedDelta[1],\n              projectedDelta[2],\n            ];\n            vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n\n            let slabThicknessValue = otherViewport.getSlabThickness();\n            if (\n              csUtils.isOpposite(\n                normalizedProjectedDirection,\n                normalizedProjectedDelta,\n                1e-3\n              )\n            ) {\n              slabThicknessValue -= mod;\n            } else {\n              slabThicknessValue += mod;\n            }\n\n            slabThicknessValue = Math.abs(slabThicknessValue);\n            slabThicknessValue = Math.max(\n              RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS,\n              slabThicknessValue\n            );\n\n            const near = this._pointNearReferenceLine(\n              viewportAnnotation,\n              canvasCoords,\n              6,\n              otherViewport\n            );\n\n            if (near) {\n              slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n            }\n\n            // We want to set the slabThickness for the viewport's actors but\n            // since the crosshairs tool instance has configuration regarding which\n            // actorUIDs (in case of volume -> actorUID = volumeIds) to set the\n            // slabThickness for, we need to delegate the slabThickness setting\n            // to the crosshairs tool instance of the toolGroup since configurations\n            // exist on the toolInstance and each toolGroup has its own crosshairs\n            // tool instance (Otherwise, we would need to set this filterActorUIDsToSetSlabThickness at\n            // the viewport level which makes tool and viewport state convoluted).\n            const toolGroup = getToolGroupForViewport(\n              otherViewport.id,\n              renderingEngine.id\n            );\n            const crosshairsInstance = toolGroup.getToolInstance(\n              this.getToolName()\n            );\n            crosshairsInstance.setSlabThickness(\n              otherViewport,\n              slabThicknessValue\n            );\n\n            viewportsIds.push(otherViewport.id);\n          }\n        }\n      );\n      renderingEngine.renderViewports(viewportsIds);\n    }\n  };\n\n  setSlabThickness(viewport, slabThickness) {\n    let actorUIDs;\n    const { filterActorUIDsToSetSlabThickness } = this.configuration;\n    if (\n      filterActorUIDsToSetSlabThickness &&\n      filterActorUIDsToSetSlabThickness.length > 0\n    ) {\n      actorUIDs = filterActorUIDsToSetSlabThickness;\n    }\n\n    let blendModeToUse = this.configuration.slabThicknessBlendMode;\n    if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n      blendModeToUse = Enums.BlendModes.COMPOSITE;\n    }\n\n    const immediate = false;\n    viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n    viewport.setSlabThickness(slabThickness, actorUIDs);\n  }\n\n  _isClockWise(a, b, c) {\n    // return true if the rotation is clockwise\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n  }\n\n  _applyDeltaShiftToSelectedViewportCameras(\n    renderingEngine,\n    viewportsAnnotationsToUpdate,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    viewportsAnnotationsToUpdate.forEach((annotation) => {\n      this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n    });\n  }\n\n  _applyDeltaShiftToViewportCamera(\n    renderingEngine: Types.IRenderingEngine,\n    annotation,\n    delta\n  ) {\n    // update camera for the other viewports.\n    // NOTE1: The lines then are rendered by the onCameraModified\n    // NOTE2: crosshair center are automatically updated in the onCameraModified event\n    const { data } = annotation;\n\n    const viewport = renderingEngine.getViewport(data.viewportId);\n    const camera = viewport.getCamera();\n    const normal = camera.viewPlaneNormal;\n\n    // Project delta over camera normal\n    // (we don't need to pan, we need only to scroll the camera as in the wheel stack scroll tool)\n    const dotProd = vtkMath.dot(delta, normal);\n    const projectedDelta: Types.Point3 = [...normal];\n    vtkMath.multiplyScalar(projectedDelta, dotProd);\n\n    if (\n      Math.abs(projectedDelta[0]) > 1e-3 ||\n      Math.abs(projectedDelta[1]) > 1e-3 ||\n      Math.abs(projectedDelta[2]) > 1e-3\n    ) {\n      const newFocalPoint: Types.Point3 = [0, 0, 0];\n      const newPosition: Types.Point3 = [0, 0, 0];\n\n      vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n      vtkMath.add(camera.position, projectedDelta, newPosition);\n\n      viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n      });\n      viewport.render();\n    }\n  }\n\n  _pointNearReferenceLine = (\n    annotation,\n    canvasCoords,\n    proximity,\n    lineViewport\n  ) => {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      if (otherViewport.id !== lineViewport.id) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        return true;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    return false;\n  };\n\n  _getRotationHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { rotationPoints } = data.handles;\n\n    for (let i = 0; i < rotationPoints.length; i++) {\n      const point = rotationPoints[i][0];\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n      if (!viewportDraggableRotatable) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.ROTATE;\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _getSlabThicknessHandleNearImagePoint(\n    viewport,\n    annotation,\n    canvasCoords,\n    proximity\n  ) {\n    const { data } = annotation;\n    const { slabThicknessPoints } = data.handles;\n\n    for (let i = 0; i < slabThicknessPoints.length; i++) {\n      const point = slabThicknessPoints[i][0];\n      const otherViewport = slabThicknessPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      if (!viewportControllable) {\n        continue;\n      }\n\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n      if (!viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n      if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n        data.handles.activeOperation = OPERATION.SLAB;\n\n        data.activeViewportIds = [otherViewport.id];\n\n        this.editData = {\n          annotation,\n        };\n\n        return point;\n      }\n    }\n\n    return null;\n  }\n\n  _pointNearTool(element, annotation, canvasCoords, proximity) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { clientWidth, clientHeight } = viewport.canvas;\n    const canvasDiagonalLength = Math.sqrt(\n      clientWidth * clientWidth + clientHeight * clientHeight\n    );\n    const { data } = annotation;\n\n    const { rotationPoints } = data.handles;\n    const { slabThicknessPoints } = data.handles;\n    const viewportIdArray = [];\n\n    for (let i = 0; i < rotationPoints.length - 1; ++i) {\n      const otherViewport = rotationPoints[i][1];\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportDraggableRotatable =\n        this._getReferenceLineDraggableRotatable(otherViewport.id);\n\n      if (!viewportControllable || !viewportDraggableRotatable) {\n        continue;\n      }\n\n      const lineSegment1 = {\n        start: {\n          x: rotationPoints[i][2][0],\n          y: rotationPoints[i][2][1],\n        },\n        end: {\n          x: rotationPoints[i][3][0],\n          y: rotationPoints[i][3][1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: rotationPoints[i + 1][2][0],\n          y: rotationPoints[i + 1][2][1],\n        },\n        end: {\n          x: rotationPoints[i + 1][3][0],\n          y: rotationPoints[i + 1][3][1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id);\n        data.handles.activeOperation = OPERATION.DRAG;\n      }\n\n      // rotation handles are two for viewport\n      i++;\n    }\n\n    for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n      const otherViewport = slabThicknessPoints[i][1];\n      if (viewportIdArray.find((id) => id === otherViewport.id)) {\n        continue;\n      }\n\n      const viewportControllable = this._getReferenceLineControllable(\n        otherViewport.id\n      );\n      const viewportSlabThicknessControlsOn =\n        this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n\n      if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n        continue;\n      }\n\n      const stPointLineCanvas1 = slabThicknessPoints[i][2];\n      const stPointLineCanvas2 = slabThicknessPoints[i][3];\n\n      const centerCanvas = vec2.create();\n      vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n      vec2.scale(centerCanvas, centerCanvas, 0.5);\n\n      const canvasUnitVectorFromCenter = vec2.create();\n      vec2.subtract(\n        canvasUnitVectorFromCenter,\n        stPointLineCanvas1,\n        centerCanvas\n      );\n      vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n\n      const canvasVectorFromCenterStart = vec2.create();\n      vec2.scale(\n        canvasVectorFromCenterStart,\n        canvasUnitVectorFromCenter,\n        canvasDiagonalLength * 0.05\n      );\n\n      const stPointLineCanvas1Start = vec2.create();\n      const stPointLineCanvas2Start = vec2.create();\n      vec2.add(\n        stPointLineCanvas1Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n      vec2.subtract(\n        stPointLineCanvas2Start,\n        centerCanvas,\n        canvasVectorFromCenterStart\n      );\n\n      const lineSegment1 = {\n        start: {\n          x: stPointLineCanvas1Start[0],\n          y: stPointLineCanvas1Start[1],\n        },\n        end: {\n          x: stPointLineCanvas1[0],\n          y: stPointLineCanvas1[1],\n        },\n      };\n\n      const distanceToPoint1 = lineSegment.distanceToPoint(\n        [lineSegment1.start.x, lineSegment1.start.y],\n        [lineSegment1.end.x, lineSegment1.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      const lineSegment2 = {\n        start: {\n          x: stPointLineCanvas2Start[0],\n          y: stPointLineCanvas2Start[1],\n        },\n        end: {\n          x: stPointLineCanvas2[0],\n          y: stPointLineCanvas2[1],\n        },\n      };\n\n      const distanceToPoint2 = lineSegment.distanceToPoint(\n        [lineSegment2.start.x, lineSegment2.start.y],\n        [lineSegment2.end.x, lineSegment2.end.y],\n        [canvasCoords[0], canvasCoords[1]]\n      );\n\n      if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n        viewportIdArray.push(otherViewport.id); // we still need this to draw inactive slab thickness handles\n        data.handles.activeOperation = null; // no operation\n      }\n\n      // slab thickness handles are in couples\n      i++;\n    }\n\n    data.activeViewportIds = [...viewportIdArray];\n\n    this.editData = {\n      annotation,\n    };\n\n    return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n  }\n}\n\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { vec3 } from 'gl-matrix';\nimport {\n  getRenderingEngines,\n  CONSTANTS,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport { ReferenceLineAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\n/**\n * @public\n */\n\nclass ReferenceLines extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    sourceViewport: any;\n    annotation: ReferenceLineAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceViewportId: '',\n        showFullDimension: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    // this._throttledCalculateCachedStats = throttle(\n    //   this._calculateCachedStats,\n    //   100,\n    //   { trailing: true }\n    // );\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    // Todo: handle this case where it is too soon to get the rendering engine\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n\n    const sourceViewport = renderingEngine.getViewport(\n      this.configuration.sourceViewportId\n    ) as Types.IVolumeViewport;\n\n    if (!sourceViewport || !sourceViewport.getImageData()) {\n      return;\n    }\n\n    const { element } = sourceViewport;\n    const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n\n    const sourceViewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(sourceViewport);\n\n    let annotation = this.editData.annotation;\n    const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n\n    if (!annotation) {\n      const newAnnotation: ReferenceLineAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: sourceViewportCanvasCornersInWorld,\n          },\n        },\n      };\n\n      addAnnotation(newAnnotation, element);\n      annotation = newAnnotation;\n    } else {\n      this.editData.annotation.data.handles.points =\n        sourceViewportCanvasCornersInWorld;\n    }\n\n    this.editData = {\n      sourceViewport,\n      renderingEngine,\n      annotation,\n    };\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewports\n        .filter((viewport) => viewport.id !== sourceViewport.id)\n        .map((viewport) => viewport.id)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the reference lines\n    // we really don't care which viewport triggered the\n    // camera modification, since we want to update all of them\n    // with respect to the targetViewport\n    this._init();\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport: targetViewport } = enabledElement;\n    const { annotation, sourceViewport } = this.editData;\n\n    let renderStatus = false;\n\n    if (!sourceViewport) {\n      return renderStatus;\n    }\n\n    if (sourceViewport.id === targetViewport.id) {\n      // If the source viewport is the same as the current viewport, we don't need to render\n      return renderStatus;\n    }\n\n    if (!annotation || !annotation?.data?.handles?.points) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n    const { viewPlaneNormal: sourceViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    let pointSetToUse = pointSet1;\n\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const newNormal = vec3.cross(\n      vec3.create(),\n      topBottomVec,\n      topRightVec\n    ) as Types.Point3;\n\n    if (this.isParallel(newNormal, viewPlaneNormal)) {\n      return renderStatus;\n    }\n\n    // check if it is perpendicular to the viewPlaneNormal which means\n    // the line does not intersect the viewPlaneNormal\n    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n      // 'use pointSet2';\n      pointSetToUse = pointSet2;\n    }\n\n    const lineStartWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[0],\n      pointSetToUse[1],\n      targetViewportPlane\n    );\n\n    const lineEndWorld = csUtils.planar.linePlaneIntersection(\n      pointSetToUse[2],\n      pointSetToUse[3],\n      targetViewportPlane\n    );\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n      targetViewport.worldToCanvas(world)\n    );\n\n    if (this.configuration.showFullDimension) {\n      canvasCoordinates = this.handleFullDimension(\n        targetViewport,\n        lineStartWorld,\n        viewPlaneNormal,\n        viewUp,\n        lineEndWorld,\n        canvasCoordinates\n      );\n    }\n\n    const dataId = `${annotationUID}-line`;\n    const lineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      lineUID,\n      canvasCoordinates[0],\n      canvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      dataId\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  isPerpendicular = (vec1: Types.Point3, vec2: Types.Point3): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private handleFullDimension(\n    targetViewport: Types.IStackViewport | Types.IVolumeViewport,\n    lineStartWorld: Types.Point3,\n    viewPlaneNormal: Types.Point3,\n    viewUp: Types.Point3,\n    lineEndWorld: Types.Point3,\n    canvasCoordinates: Types.Point2[]\n  ) {\n    const renderingEngine = targetViewport.getRenderingEngine();\n    const targetId = this.getTargetId(targetViewport);\n    const targetImage = this.getTargetIdImage(targetId, renderingEngine);\n\n    const referencedImageId = this.getReferencedImageId(\n      targetViewport,\n      lineStartWorld,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    if (referencedImageId && targetImage) {\n      try {\n        const { imageData, dimensions } = targetImage;\n\n        // Calculate bound image coordinates\n        const [\n          topLeftImageCoord,\n          topRightImageCoord,\n          bottomRightImageCoord,\n          bottomLeftImageCoord,\n        ] = [\n          imageData.indexToWorld([0, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([dimensions[0] - 1, 0, 0]) as Types.Point3,\n          imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n          ]) as Types.Point3,\n          imageData.indexToWorld([0, dimensions[1] - 1, 0]) as Types.Point3,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate line start and end image coordinates\n        const [lineStartImageCoord, lineEndImageCoord] = [\n          lineStartWorld,\n          lineEndWorld,\n        ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n\n        // Calculate intersection points between line and image bounds\n        canvasCoordinates = [\n          [topLeftImageCoord, topRightImageCoord],\n          [topRightImageCoord, bottomRightImageCoord],\n          [bottomLeftImageCoord, bottomRightImageCoord],\n          [topLeftImageCoord, bottomLeftImageCoord],\n        ]\n          .map(([start, end]) =>\n            this.intersectInfiniteLines(\n              start,\n              end,\n              lineStartImageCoord,\n              lineEndImageCoord\n            )\n          )\n          .filter((point) => point && this.isInBound(point, dimensions))\n          .map((point) => {\n            const world = csUtils.imageToWorldCoords(\n              referencedImageId,\n              point as Types.Point2\n            );\n            return targetViewport.worldToCanvas(world);\n          });\n      } catch (err) {\n        console.log(err);\n      }\n    }\n    return canvasCoordinates;\n  }\n\n  // get the intersection point between two infinite lines, not line segments\n  intersectInfiniteLines(\n    line1Start: Types.Point2,\n    line1End: Types.Point2,\n    line2Start: Types.Point2,\n    line2End: Types.Point2\n  ) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n\n    // Compute a1, b1, c1, where line joining points 1 and 2 is \"a1 x  +  b1 y  +  c1  =  0\"\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n\n    // Compute a2, b2, c2\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n\n    if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n      return;\n    }\n\n    const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n    const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n\n    return [x, y];\n  }\n\n  isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  isInBound(point: number[], dimensions: Types.Point3): boolean {\n    return (\n      point[0] >= 0 &&\n      point[0] <= dimensions[0] &&\n      point[1] >= 0 &&\n      point[1] <= dimensions[1]\n    );\n  }\n}\n\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport {\n  metaData,\n  CONSTANTS,\n  getRenderingEngine,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\n\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\n\nimport {\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\n\nconst { EPSILON } = CONSTANTS;\n\nexport interface OverlayGridAnnotation extends Annotation {\n  data: {\n    viewportData: Map<string, object>;\n    pointSets: Array<object>;\n  };\n}\n\n/**\n * @public\n */\nclass OverlayGridTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        sourceImageIds: [],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onSetToolActive = (): void => {\n    this._init();\n  };\n\n  _init = (): void => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n    if (!sourceImageIds?.length) {\n      console.warn(\n        'OverlayGridTool: No sourceImageIds provided in configuration'\n      );\n      return;\n    }\n\n    const imagePlaneModule = metaData.get(\n      'imagePlaneModule',\n      sourceImageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n      console.warn(\n        'OverlayGridTool: No imagePlaneModule found for sourceImageIds'\n      );\n      return;\n    }\n\n    const { frameOfReferenceUID } = imagePlaneModule;\n\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn('OverlayGridTool: No viewports found');\n      return;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const pointSets = sourceImageIds.map((id) => {\n        // check if pointSets for the imageId was calculated. If not calculate and store\n        return this.calculateImageIdPointSets(id);\n      });\n\n      const newAnnotation: OverlayGridAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          viewportData: new Map(),\n          pointSets,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  /**\n   * Calculates the point sets based on the image corners relative to an imageId\n   * @param imageId - The imageId to calculate the point sets for\n   * @returns\n   */\n  calculateImageIdPointSets = (imageId: string) => {\n    const {\n      imagePositionPatient,\n      rows,\n      columns,\n      rowCosines,\n      columnCosines,\n      rowPixelSpacing,\n      columnPixelSpacing,\n    } = metaData.get('imagePlaneModule', imageId);\n\n    // top left world, top right world, bottom right world, bottom left world\n    const topLeft = <Types.Point3>[...imagePositionPatient];\n    const topRight = <Types.Point3>[...imagePositionPatient];\n    const bottomLeft = <Types.Point3>[...imagePositionPatient];\n    const bottomRight = <Types.Point3>[...imagePositionPatient];\n\n    vec3.scaleAndAdd(\n      topRight,\n      imagePositionPatient,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n    vec3.scaleAndAdd(\n      bottomLeft,\n      imagePositionPatient,\n      rowCosines,\n      rows * rowPixelSpacing\n    );\n\n    vec3.scaleAndAdd(\n      bottomRight,\n      bottomLeft,\n      columnCosines,\n      columns * columnPixelSpacing\n    );\n\n    // check if the topLeft and bottomLeft line is parallel to the viewUp\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n    const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n\n    return { pointSet1, pointSet2 };\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const sourceImageIds = this.configuration.sourceImageIds;\n\n    let renderStatus = false;\n    if (!sourceImageIds?.length) {\n      return renderStatus;\n    }\n\n    const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n    const targetImageIds = targetViewport.getImageIds();\n    if (targetImageIds.length < 2) {\n      return renderStatus;\n    }\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n\n    const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n    const imageIdNormal = <Types.Point3>(\n      this.getImageIdNormal(sourceImageIds[0])\n    );\n\n    if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n      // If the source and target viewports are parallel, we don't need to render\n      return renderStatus;\n    }\n\n    const targetViewportPlane = csUtils.planar.planeEquation(\n      viewPlaneNormal,\n      focalPoint\n    );\n\n    const pointSets = annotation.data.pointSets;\n    const viewportData = annotation.data.viewportData;\n    for (let i = 0; i < sourceImageIds.length; i++) {\n      // check if pointSets for the imageId was calculated. If not calculate and store\n      const { pointSet1, pointSet2 } = pointSets[i];\n\n      const targetData =\n        viewportData.get(targetViewport.id) ||\n        this.initializeViewportData(viewportData, targetViewport.id);\n\n      // check if pointSetToUse was calculated. If not calculate and store\n      if (!targetData.pointSetsToUse[i]) {\n        let pointSetToUse = pointSet1;\n\n        let topBottomVec = vec3.subtract(\n          vec3.create(),\n          pointSet1[0],\n          pointSet1[1]\n        );\n        topBottomVec = vec3.normalize(\n          vec3.create(),\n          topBottomVec\n        ) as Types.Point3;\n\n        // check if it is perpendicular to the viewPlaneNormal which means\n        // the line does not intersect the viewPlaneNormal\n        if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n          // 'use pointSet2';\n          pointSetToUse = pointSet2;\n        }\n\n        targetData.pointSetsToUse[i] = pointSetToUse;\n\n        targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[0],\n          pointSetToUse[1],\n          targetViewportPlane\n        );\n\n        targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(\n          pointSetToUse[2],\n          pointSetToUse[3],\n          targetViewportPlane\n        );\n      }\n\n      const lineStartWorld = targetData.lineStartsWorld[i];\n      const lineEndWorld = targetData.lineEndsWorld[i];\n\n      styleSpecifier.annotationUID = annotationUID;\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) =>\n        targetViewport.worldToCanvas(world)\n      );\n\n      const dataId = `${annotationUID}-line`;\n      const lineUID = `${i}`;\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        dataId\n      );\n    }\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n\n  private initializeViewportData = (viewportData, id) => {\n    viewportData.set(id, {\n      pointSetsToUse: [],\n      lineStartsWorld: [],\n      lineEndsWorld: [],\n    });\n\n    return viewportData.get(id);\n  };\n\n  private isPerpendicular = (\n    vec1: Types.Point3,\n    vec2: Types.Point3\n  ): boolean => {\n    const dot = vec3.dot(vec1, vec2);\n    return Math.abs(dot) < EPSILON;\n  };\n\n  private isParallel(vec1: Types.Point3, vec2: Types.Point3): boolean {\n    return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n  }\n\n  private getImageIdNormal(imageId: string): vec3 {\n    const { imageOrientationPatient } = metaData.get(\n      'imagePlaneModule',\n      imageId\n    );\n    const rowCosineVec = vec3.fromValues(\n      imageOrientationPatient[0],\n      imageOrientationPatient[1],\n      imageOrientationPatient[2]\n    );\n    const colCosineVec = vec3.fromValues(\n      imageOrientationPatient[3],\n      imageOrientationPatient[4],\n      imageOrientationPatient[5]\n    );\n    return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n  }\n}\n\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { drawPolyline } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { PublicToolProps, ToolProps, SVGDrawingHelper } from '../types';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { Annotation } from '../types';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\n\nexport interface SegmentationIntersectionAnnotation extends Annotation {\n  data: {\n    actorsWorldPointsMap: Map<string, Map<string, object>>;\n  };\n}\n\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        opacity: 0.5,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Initialize the annotation data and calculates surface intersections\n   * @returns\n   */\n  _init = (): void => {\n    const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportsInfo?.length) {\n      console.warn(this.getToolName() + 'Tool: No viewports found');\n      return;\n    }\n\n    const firstViewport = getRenderingEngine(\n      viewportsInfo[0].renderingEngineId\n    )?.getViewport(viewportsInfo[0].viewportId);\n\n    if (!firstViewport) {\n      return;\n    }\n    const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n    const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n\n    if (!annotations?.length) {\n      const actorsWorldPointsMap = new Map();\n      calculateSurfaceSegmentationIntersections(\n        actorsWorldPointsMap,\n        viewportsInfo\n      );\n      const newAnnotation: SegmentationIntersectionAnnotation = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n          toolName: this.getToolName(),\n          FrameOfReferenceUID: frameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          actorsWorldPointsMap,\n        },\n      };\n\n      addAnnotation(newAnnotation, frameOfReferenceUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      getRenderingEngine(viewportsInfo[0].renderingEngineId),\n      viewportsInfo.map(({ viewportId }) => viewportId)\n    );\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    this._init();\n  };\n\n  /**\n   * Renders the surface intersections\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    let renderStatus = false;\n\n    const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n    const annotation = annotations[0];\n    const { annotationUID } = annotation;\n    const actorsWorldPointsMap = annotation.data.actorsWorldPointsMap;\n\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n\n    actorEntries.forEach((actorEntry) => {\n      if (!actorEntry?.clippingFilter) {\n        return;\n      }\n      const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n      if (!actorWorldPointMap) {\n        return;\n      }\n      if (!actorWorldPointMap.get(cacheId)) {\n        return;\n      }\n      let polyLineIdx = 1;\n      const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n      for (let i = 0; i < worldPointsSet.length; i++) {\n        const worldPoints = worldPointsSet[i];\n        const canvasPoints = worldPoints.map((point) =>\n          viewport.worldToCanvas(point)\n        );\n\n        const options = {\n          color: color,\n          fillColor: color,\n          fillOpacity: this.configuration.opacity,\n          connectLastToFirst: true,\n        };\n\n        const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n        drawPolyline(\n          svgDrawingHelper,\n          annotationUID,\n          polyLineUID,\n          canvasPoints,\n          options\n        );\n        polyLineIdx++;\n      }\n    });\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a list of viewports\n * @param actorWorldPointsMap\n * @param viewportsInfo\n */\nfunction calculateSurfaceSegmentationIntersections(\n  actorsWorldPointsMap,\n  viewportsInfo\n) {\n  viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n    const viewport =\n      getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n    calculateSurfaceSegmentationIntersectionsForViewport(\n      actorsWorldPointsMap,\n      viewport\n    );\n  });\n}\n\n/**\n * Calculates surface intersections points for all surface actors in a viewport\n * generating a set of polyline points for each actor\n * @param actorWorldPointsMap\n * @param viewport\n */\nfunction calculateSurfaceSegmentationIntersectionsForViewport(\n  actorsWorldPointsMap,\n  viewport\n) {\n  const actorEntries = viewport.getActors();\n\n  // we should not use the focalPoint here, since the pan and zoom updates it,\n  // imageIndex is reliable enough\n  const cacheId = getCacheId(viewport);\n\n  actorEntries.forEach((actorEntry) => {\n    if (!actorEntry?.clippingFilter) {\n      return;\n    }\n\n    let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n    if (!actorWorldPointsMap) {\n      actorWorldPointsMap = new Map();\n      actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n    }\n    if (!actorWorldPointsMap.get(cacheId)) {\n      const polyData = actorEntry.clippingFilter.getOutputData();\n      const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n      if (!worldPointsSet) {\n        return;\n      }\n\n      // worldPointsSet = removeExtraPoints(viewport, worldPointsSet);\n      const colorArray = actorEntry.actor.getProperty().getColor();\n      const color = colorToString(colorArray);\n      actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n    }\n  });\n}\n\nfunction getCacheId(viewport) {\n  const { viewPlaneNormal } = viewport.getCamera();\n  const imageIndex = viewport.getCurrentImageIdIndex();\n  return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\n\n/**\n * Transform a color array into a string\n * @param colorArray\n * @returns\n */\nfunction colorToString(colorArray): string {\n  function colorComponentToString(component) {\n    let componentString = Math.floor(component * 255).toString(16);\n    if (componentString.length === 1) {\n      componentString = '0' + componentString;\n    }\n    return componentString;\n  }\n  return (\n    '#' +\n    colorComponentToString(colorArray[0]) +\n    colorComponentToString(colorArray[1]) +\n    colorComponentToString(colorArray[2])\n  );\n}\n\n/**\n * Remove duplicate and unnecessary points\n * @param worldPoints\n * @param canvasPoints\n * @returns\n */\nfunction removeExtraPoints(viewport, worldPointsSet) {\n  return worldPointsSet.map((worldPoints) => {\n    const canvasPoints = worldPoints.map((point) => {\n      const canvasPoint = viewport.worldToCanvas(point);\n      return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n    });\n\n    let lastPoint;\n    const newWorldPoints = [];\n    let newCanvasPoints = [];\n    // removing duplicate points\n    for (let i = 0; i < worldPoints.length; i++) {\n      if (lastPoint) {\n        if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n          newWorldPoints.push(worldPoints[i]);\n          newCanvasPoints.push(canvasPoints[i]);\n        }\n      }\n      lastPoint = canvasPoints[i];\n    }\n\n    // checking if a middle point is near the start\n    const firstPoint = newCanvasPoints[0];\n    for (\n      let j = Math.min(30, newCanvasPoints.length);\n      j < newCanvasPoints.length;\n      j++\n    ) {\n      if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n        newCanvasPoints = newCanvasPoints.slice(0, j);\n        return newWorldPoints.slice(0, j);\n      }\n    }\n    return newWorldPoints;\n  });\n}\n\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\n\n/**\n * Given two world positions and an orthogonal view to an `imageVolume` defined by\n * a `viewPlaneNormal` and a `viewUp`, get the width and height in world coordinates of the rectangle\n * defined by the two points. The implementation works both with orthogonal\n * non-orthogonal rectangles.\n *\n * @param viewPlaneNormal - The normal of the view.\n * @param viewUp - The up direction of the view.\n * @param imageVolume - The imageVolume to use to measure.\n * @param worldPos1 - The first world position.\n * @param worldPos2 - The second world position.\n *\n * @returns The `worldWidth` and `worldHeight`.\n */\nexport default function getWorldWidthAndHeightFromTwoPoints(\n  viewPlaneNormal: Types.Point3,\n  viewUp: Types.Point3,\n  worldPos1: Types.Point3,\n  worldPos2: Types.Point3\n): { worldWidth: number; worldHeight: number } {\n  const viewRight = vec3.create();\n\n  vec3.cross(viewRight, <vec3>viewUp, <vec3>viewPlaneNormal);\n\n  const pos1 = vec3.fromValues(...worldPos1);\n  const pos2 = vec3.fromValues(...worldPos2);\n\n  const diagonal = vec3.create();\n  vec3.subtract(diagonal, pos1, pos2);\n\n  const diagonalLength = vec3.length(diagonal);\n\n  // When the two points are very close to each other return width as 0\n  // to avoid NaN the cosTheta formula calculation\n  if (diagonalLength < 0.0001) {\n    return { worldWidth: 0, worldHeight: 0 };\n  }\n\n  const cosTheta =\n    vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n\n  const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\n  const worldWidth = sinTheta * diagonalLength;\n  const worldHeight = cosTheta * diagonalLength;\n\n  return { worldWidth, worldHeight };\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawEllipse as drawEllipseSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  pointInEllipse,\n  getCanvasEllipseCorners,\n} from '../../utilities/math/ellipse';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { EllipticalROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities/';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * EllipticalROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use EllipticalROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Elliptical tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(EllipticalROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(EllipticalROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(EllipticalROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(EllipticalROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass EllipticalROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    centerWorld?: Array<number>;\n    canvasWidth?: number;\n    canvasHeight?: number;\n    originalHandleCanvas?: Array<number>;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the ellipse.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a EllipticalROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): EllipticalROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n          ] as [Types.Point3, Types.Point3, Types.Point3, Types.Point3],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        initialRotation: viewport.getRotation(),\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      centerWorld: worldPos,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: EllipticalROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n    const canvasCorners = getCanvasEllipseCorners(canvasCoordinates);\n\n    const [canvasPoint1, canvasPoint2] = canvasCorners;\n\n    const minorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) + proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) + proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) - proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) - proximity,\n    };\n\n    const majorEllipse = {\n      left: Math.min(canvasPoint1[0], canvasPoint2[0]) - proximity / 2,\n      top: Math.min(canvasPoint1[1], canvasPoint2[1]) - proximity / 2,\n      width: Math.abs(canvasPoint1[0] - canvasPoint2[0]) + proximity,\n      height: Math.abs(canvasPoint1[1] - canvasPoint2[1]) + proximity,\n    };\n\n    const pointInMinorEllipse = this._pointInEllipseCanvas(\n      minorEllipse,\n      canvasCoords\n    );\n    const pointInMajorEllipse = this._pointInEllipseCanvas(\n      majorEllipse,\n      canvasCoords\n    );\n\n    if (pointInMajorEllipse && !pointInMinorEllipse) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: EllipticalROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    let centerCanvas;\n    let centerWorld;\n    let canvasWidth;\n    let canvasHeight;\n    let originalHandleCanvas;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n      const { viewport } = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = viewport;\n\n      handleIndex = points.findIndex((p) => p === handle);\n\n      const pointsCanvas = points.map(worldToCanvas);\n\n      originalHandleCanvas = pointsCanvas[handleIndex];\n\n      canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n      canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n\n      centerCanvas = [\n        (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n        (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n      ];\n\n      centerWorld = canvasToWorld(centerCanvas);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      canvasWidth,\n      canvasHeight,\n      centerWorld,\n      originalHandleCanvas,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Elliptical ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the ellipse,\n    // and they are by definition not in the ellipse on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerWorld } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n\n    // Todo: why bottom is -dY, it should be +dY\n    const bottomCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] - dY];\n    const topCanvas = <Types.Point2>[centerCanvas[0], centerCanvas[1] + dY];\n    const leftCanvas = <Types.Point2>[centerCanvas[0] - dX, centerCanvas[1]];\n    const rightCanvas = <Types.Point2>[centerCanvas[0] + dX, centerCanvas[1]];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { viewport } = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = viewport;\n\n    const {\n      annotation,\n      canvasWidth,\n      canvasHeight,\n      handleIndex,\n      centerWorld,\n      originalHandleCanvas,\n    } = this.editData;\n    const centerCanvas = viewport.worldToCanvas(centerWorld as Types.Point3);\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0 || handleIndex === 1) {\n      // Dragging top or bottom point\n      const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - dYCanvas,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n\n      const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n      const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + newHalfCanvasWidth,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n    } else {\n      // Dragging left or right point\n      const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n      const canvasLeft = <Types.Point2>[\n        centerCanvas[0] - dXCanvas,\n        centerCanvas[1],\n      ];\n      const canvasRight = <Types.Point2>[\n        centerCanvas[0] + dXCanvas,\n        centerCanvas[1],\n      ];\n\n      points[2] = canvasToWorld(canvasLeft);\n      points[3] = canvasToWorld(canvasRight);\n\n      const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n      const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n      const canvasBottom = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] - newHalfCanvasHeight,\n      ];\n      const canvasTop = <Types.Point2>[\n        centerCanvas[0],\n        centerCanvas[1] + newHalfCanvasHeight,\n      ];\n\n      points[0] = canvasToWorld(canvasBottom);\n      points[1] = canvasToWorld(canvasTop);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the ellipticalROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as EllipticalROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2, Types.Point2, Types.Point2];\n\n      const rotation = Math.abs(\n        viewport.getRotation() - (data.initialRotation || 0)\n      );\n      let canvasCorners;\n\n      if (rotation == 90 || rotation == 270) {\n        canvasCorners = <Array<Types.Point2>>getCanvasEllipseCorners([\n          canvasCoordinates[2], // bottom\n          canvasCoordinates[3], // top\n          canvasCoordinates[0], // left\n          canvasCoordinates[1], // right\n        ]);\n      } else {\n        canvasCorners = <Array<Types.Point2>>(\n          getCanvasEllipseCorners(canvasCoordinates) // bottom, top, left, right, keep as is\n        );\n      }\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-ellipse`;\n      const ellipseUID = '0';\n      drawEllipseSvg(\n        svgDrawingHelper,\n        annotationUID,\n        ellipseUID,\n        canvasCorners[0],\n        canvasCorners[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        const minRadius = Math.min(\n          Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, // horizontal radius\n          Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2 // vertical radius\n        );\n        if (minRadius > 3 * centerPointRadius) {\n          const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${ellipseUID}-center`,\n            centerPoint,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasEllipseCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const scale = getCalibratedScale(image);\n        const area =\n          Math.abs(Math.PI * (worldWidth / 2) * (worldHeight / 2)) /\n          scale /\n          scale;\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          max: stats[0]?.value,\n          stdDev: stats[2]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  /**\n   * This is a temporary function to use the old ellipse's canvas-based\n   * calculation for isPointNearTool, we should move the the world-based\n   * calculation to the tool's isPointNearTool function.\n   *\n   * @param ellipse - The ellipse object\n   * @param location - The location to check\n   * @returns True if the point is inside the ellipse\n   */\n  _pointInEllipseCanvas(ellipse, location: Types.Point2): boolean {\n    const xRadius = ellipse.width / 2;\n    const yRadius = ellipse.height / 2;\n\n    if (xRadius <= 0.0 || yRadius <= 0.0) {\n      return false;\n    }\n\n    const center = [ellipse.left + xRadius, ellipse.top + yRadius];\n    const normalized = [location[0] - center[0], location[1] - center[1]];\n\n    const inEllipse =\n      (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n        (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n      1.0;\n\n    return inEllipse;\n  }\n\n  /**\n   * It takes the canvas coordinates of the ellipse corners and returns the center point of it\n   *\n   * @param ellipseCanvasPoints - The coordinates of the ellipse in the canvas.\n   * @returns center point.\n   */\n  _getCanvasEllipseCenter(ellipseCanvasPoints: Types.Point2[]): Types.Point2 {\n    const [bottom, top, left, right] = ellipseCanvasPoints;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    return [\n      (topLeft[0] + bottomRight[0]) / 2,\n      (topLeft[1] + bottomRight[1]) / 2,\n    ] as Types.Point2;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit } =\n    cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nEllipticalROITool.toolName = 'EllipticalROI';\nexport default EllipticalROITool;\n","import { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleRadius(\n  circleCanvasPoints: canvasCoordinates\n): number {\n  const [center, end] = circleCanvasPoints;\n  return distanceToPoint(center, end);\n}\n","import type { Types } from '@cornerstonejs/core';\nimport { distanceToPoint } from '../point';\nimport { canvasCoordinates } from './_types';\n\n/**\n * It takes the canvas coordinates of the circle corners (wrapping square rectangle)\n * and returns the top left and bottom right\n * corners of it\n *\n * @param circleCanvasPoints - The coordinates of the circle in the canvas.\n * @returns An array of two points.\n */\nexport default function getCanvasCircleCorners(\n  circleCanvasPoints: canvasCoordinates\n): Array<Types.Point2> {\n  const [center, end] = circleCanvasPoints;\n  const radius = distanceToPoint(center, end);\n\n  const topLeft = <Types.Point2>[center[0] - radius, center[1] - radius];\n  const bottomRight = <Types.Point2>[center[0] + radius, center[1] + radius];\n\n  return [topLeft, bottomRight];\n}\n","import { AnnotationTool } from '../base';\n\nimport {\n  getEnabledElement,\n  VolumeViewport,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedAreaUnits,\n  getCalibratedScale,\n  getCalibratedAspect,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CircleROIAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { pointInShapeCallback } from '../../utilities';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport {\n  ModalityUnitOptions,\n  getModalityUnit,\n} from '../../utilities/getModalityUnit';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport {\n  getCanvasCircleCorners,\n  getCanvasCircleRadius,\n} from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * CircleROITool let you draw annotations that measures the statistics\n * such as area, max, mean and stdDev of an elliptical region of interest.\n * You can use CircleROITool in all perpendicular views (axial, sagittal, coronal).\n * Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference. Circle tool's text box lines are dynamically\n * generated based on the viewport's underlying Modality. For instance, if\n * the viewport is displaying CT, the text box will shown the statistics in Hounsfield units,\n * and if the viewport is displaying PET, the text box will show the statistics in\n * SUV units.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * Changing tool configuration (see below) you can make the tool to draw the center\n * point circle with a given radius.\n *\n * ```js\n * cornerstoneTools.addTool(CircleROITool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(CircleROITool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(CircleROITool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n *\n * // draw a circle at the center point with 4px radius.\n * toolGroup.setToolConfiguration(CircleROITool.toolName, {\n *   centerPointRadius: 4,\n * });\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass CircleROITool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        // Radius of the circle to draw  at the center point of the circle.\n        // Set this zero(0) in order not to draw the circle.\n        centerPointRadius: 0,\n        getTextLines: defaultGetTextLines,\n        statsCalculator: BasicStatsCalculator,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): CircleROIAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          points: [[...worldPos], [...worldPos]] as [\n            Types.Point3, // center\n            Types.Point3 // end\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CircleROIAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const radius = getCanvasCircleRadius(canvasCoordinates);\n    const radiusPoint = getCanvasCircleRadius([\n      canvasCoordinates[0],\n      canvasCoords,\n    ]);\n\n    if (Math.abs(radiusPoint - radius) < proximity / 2) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: CircleROIAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      const { points } = data.handles;\n\n      handleIndex = points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    // Circle ROI tool should reset its highlight to false on mouse up (as opposed\n    // to other tools that keep it highlighted until the user moves. The reason\n    // is that we use top-left and bottom-right handles to define the circle,\n    // and they are by definition not in the circle on mouse up.\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { data } = annotation;\n\n    data.handles.points = [\n      data.handles.points[0], // center stays\n      canvasToWorld(currentCanvasPoints), // end point moves (changing radius)\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n\n    const { annotation, handleIndex } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n\n    // Move current point in that direction.\n    // Move other points in opposite direction.\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    if (handleIndex === 0) {\n      // Dragging center, move the circle ROI\n      const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n      const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n\n      const canvasCenter = currentCanvasPoints as Types.Point2;\n      const canvasEnd = <Types.Point2>[\n        canvasCoordinates[1][0] + dXCanvas,\n        canvasCoordinates[1][1] + dYCanvas,\n      ];\n\n      points[0] = canvasToWorld(canvasCenter);\n      points[1] = canvasToWorld(canvasEnd);\n    } else {\n      // Dragging end point, center stays\n      points[1] = canvasToWorld(currentCanvasPoints);\n    }\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CircleROIAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2, Types.Point2];\n      const center = canvasCoordinates[0];\n      const radius = getCanvasCircleRadius(canvasCoordinates);\n      const canvasCorners = getCanvasCircleCorners(canvasCoordinates);\n\n      const { centerPointRadius } = this.configuration;\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].areaUnit == null\n      ) {\n        data.cachedStats[targetId] = {\n          Modality: null,\n          area: null,\n          max: null,\n          mean: null,\n          stdDev: null,\n          areaUnit: null,\n          radius: null,\n          radiusUnit: null,\n          perimeter: null,\n        };\n\n        this._calculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          viewport,\n          renderingEngine,\n          enabledElement\n        );\n        // If the invalidated data is as a result of volumeViewport manipulation\n        // of the tools, we need to invalidate the related viewports data, so that\n        // when scrolling to the related slice in which the tool were manipulated\n        // we re-render the correct tool position. This is due to stackViewport\n        // which doesn't have the full volume at each time, and we are only working\n        // on one slice at a time.\n        if (viewport instanceof VolumeViewport) {\n          const { referencedImageId } = annotation.metadata;\n\n          // invalidate all the relevant stackViewports if they are not\n          // at the referencedImageId\n          for (const targetId in data.cachedStats) {\n            if (targetId.startsWith('imageId')) {\n              const viewports = renderingEngine.getStackViewports();\n\n              const invalidatedStack = viewports.find((vp) => {\n                // The stack viewport that contains the imageId but is not\n                // showing it currently\n                const referencedImageURI =\n                  csUtils.imageIdToURI(referencedImageId);\n                const hasImageURI = vp.hasImageURI(referencedImageURI);\n                const currentImageURI = csUtils.imageIdToURI(\n                  vp.getCurrentImageId()\n                );\n                return hasImageURI && currentImageURI !== referencedImageURI;\n              });\n\n              if (invalidatedStack) {\n                delete data.cachedStats[targetId];\n              }\n            }\n          }\n        }\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-circle`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      // draw center point, if \"centerPointRadius\" configuration is valid.\n      if (centerPointRadius > 0) {\n        if (radius > 3 * centerPointRadius) {\n          drawCircleSvg(\n            svgDrawingHelper,\n            annotationUID,\n            `${circleUID}-center`,\n            center,\n            centerPointRadius,\n            {\n              color,\n              lineDash,\n              lineWidth,\n            }\n          );\n        }\n      }\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      // Poor man's cached?\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats = (\n    annotation,\n    viewport,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const { viewPlaneNormal, viewUp } = viewport.getCamera();\n\n    const [topLeftCanvas, bottomRightCanvas] = <Array<Types.Point2>>(\n      getCanvasCircleCorners(canvasCoordinates)\n    );\n\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const { cachedStats } = data;\n\n    const targetIds = Object.keys(cachedStats);\n    const worldPos1 = topLeftWorld;\n    const worldPos2 = bottomRightWorld;\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { dimensions, imageData, metadata, hasPixelSpacing } = image;\n\n      const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const boundsIJK = [\n          [iMin, iMax],\n          [jMin, jMax],\n          [kMin, kMax],\n        ] as [Types.Point2, Types.Point2, Types.Point2];\n\n        const center = [\n          (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n          (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n          (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n        ] as Types.Point3;\n\n        const ellipseObj = {\n          center,\n          xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n          yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n          zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n        };\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n        const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n        const scale = getCalibratedScale(image);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(\n          Math.PI *\n            (worldWidth / scale / 2) *\n            (worldHeight / aspect / scale / 2)\n        );\n\n        const modalityUnitOptions = {\n          isPreScaled: isViewportPreScaled(viewport, targetId),\n          isSuvScaled: this.isSuvScaled(\n            viewport,\n            targetId,\n            annotation.metadata.referencedImageId\n          ),\n        };\n\n        const modalityUnit = getModalityUnit(\n          metadata.Modality,\n          annotation.metadata.referencedImageId,\n          modalityUnitOptions\n        );\n\n        const pointsInShape = pointInShapeCallback(\n          imageData,\n          (pointLPS, pointIJK) => pointInEllipse(ellipseObj, pointLPS),\n          this.configuration.statsCalculator.statsCallback,\n          boundsIJK\n        );\n\n        const stats = this.configuration.statsCalculator.getStatistics();\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n          area,\n          mean: stats[1]?.value,\n          max: stats[0]?.value,\n          stdDev: stats[2]?.value,\n          statsArray: stats,\n          pointsInShape: pointsInShape,\n          isEmptyArea,\n          areaUnit: getCalibratedAreaUnits(null, image),\n          radius: worldWidth / 2 / scale,\n          radiusUnit: getCalibratedLengthUnits(null, image),\n          perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n          modalityUnit,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n\n        cachedStats[targetId] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const {\n    radius,\n    radiusUnit,\n    area,\n    mean,\n    stdDev,\n    max,\n    isEmptyArea,\n    Modality,\n    areaUnit,\n    modalityUnit,\n  } = cachedVolumeStats;\n\n  const textLines: string[] = [];\n\n  if (radius) {\n    const radiusLine = isEmptyArea\n      ? `Radius: Oblique not supported`\n      : `Radius: ${roundNumber(radius)} ${radiusUnit}`;\n    textLines.push(radiusLine);\n  }\n\n  if (area) {\n    const areaLine = isEmptyArea\n      ? `Area: Oblique not supported`\n      : `Area: ${roundNumber(area)} ${areaUnit}`;\n    textLines.push(areaLine);\n  }\n\n  if (mean) {\n    textLines.push(`Mean: ${roundNumber(mean)} ${modalityUnit}`);\n  }\n\n  if (max) {\n    textLines.push(`Max: ${roundNumber(max)} ${modalityUnit}`);\n  }\n\n  if (stdDev) {\n    textLines.push(`Std Dev: ${roundNumber(stdDev)} ${modalityUnit}`);\n  }\n\n  return textLines;\n}\n\nCircleROITool.toolName = 'CircleROI';\nexport default CircleROITool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  getCalibratedLengthUnits,\n  getCalibratedScale,\n} from '../../utilities/getCalibratedUnits';\nimport roundNumber from '../../utilities/roundNumber';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport {\n  drawLine as drawLineSvg,\n  drawHandles as drawHandlesSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { BidirectionalAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n  MouseDragEventType,\n  MouseMoveEventType,\n} from '../../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nconst { transformWorldToIndex } = csUtils;\n\n/**\n * BidirectionalTool let you draw annotations that measures the length and\n * width at the same time in `mm` unit. It is consisted of two perpendicular lines and\n * a text box. You can use the BidirectionalTool in all planes even in oblique\n * reconstructed planes. Note: annotation tools in cornerstone3DTools exists in the exact location\n * in the physical 3d space, as a result, by default, all annotations that are\n * drawing in the same frameOfReference will get shared between viewports that\n * are in the same frameOfReference.\n *\n * The resulting annotation's data (statistics) and metadata (the\n * state of the viewport while drawing was happening) will get added to the\n * ToolState manager and can be accessed from the ToolState by calling getAnnotations\n * or similar methods.\n *\n * ```js\n * cornerstoneTools.addTool(BidirectionalTool)\n *\n * const toolGroup = ToolGroupManager.createToolGroup('toolGroupId')\n *\n * toolGroup.addTool(BidirectionalTool.toolName)\n *\n * toolGroup.addViewport('viewportId', 'renderingEngineId')\n *\n * toolGroup.setToolActive(BidirectionalTool.toolName, {\n *   bindings: [\n *    {\n *       mouseButton: MouseBindings.Primary, // Left Click\n *     },\n *   ],\n * })\n * ```\n *\n * Read more in the Docs section of the website.\n */\n\nclass BidirectionalTool extends AnnotationTool {\n  static toolName;\n\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n  preventHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Bidirectional Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation(\n    evt: EventTypes.InteractionEventType\n  ): BidirectionalAnnotation {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: BidirectionalAnnotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [\n            // long\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            // short\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n          activeHandleIndex: null,\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  }\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: BidirectionalAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // Check long axis\n    let canvasPoint1 = viewport.worldToCanvas(points[0]);\n    let canvasPoint2 = viewport.worldToCanvas(points[1]);\n\n    let line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    let distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    // Check short axis\n    canvasPoint1 = viewport.worldToCanvas(points[2]);\n    canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Handles the toolSelected callback for bidirectional tool\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Executes the callback for when mouse has selected a handle (anchor point) of\n   * the bidirectional tool or when the text box has been selected.\n   *\n   * @param evt - EventTypes.MouseDownEventType\n   * @param annotation - Bidirectional annotation\n   * @param handle - Handle index or selected textBox information\n   * @param interactionType - interaction type (mouse, touch)\n   */\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: BidirectionalAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const data = annotation.data;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    hideElementCursor(element);\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  /**\n   * Handles the mouse up action for the bidirectional tool. It can be at the end\n   * of the annotation drawing (MouseUpEventType) or when the user clicks and release\n   * the mouse button instantly which let to the annotation to draw without holding\n   * the mouse button (MouseClickEventType).\n   *\n   * @param evt - mouse up or mouse click event types\n   */\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (this.editData.handleIndex !== undefined) {\n      const { points } = data.handles;\n      const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n      const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n\n      if (secondLineSegmentLength > firstLineSegmentLength) {\n        // Switch points so [0,1] is the long axis and [2,3] is the short axis.\n\n        const longAxis = [[...points[2]], [...points[3]]];\n\n        const shortAxisPoint0 = [...points[0]];\n        const shortAxisPoint1 = [...points[1]];\n\n        // shortAxis[0->1] should be perpendicular (counter-clockwise) to longAxis[0->1]\n        const longAxisVector = vec2.create();\n\n        vec2.set(\n          longAxisVector,\n          longAxis[1][0] - longAxis[0][0],\n          longAxis[1][1] - longAxis[1][0]\n        );\n\n        const counterClockWisePerpendicularToLongAxis = vec2.create();\n\n        vec2.set(\n          counterClockWisePerpendicularToLongAxis,\n          -longAxisVector[1],\n          longAxisVector[0]\n        );\n\n        const currentShortAxisVector = vec2.create();\n\n        vec2.set(\n          currentShortAxisVector,\n          shortAxisPoint1[0] - shortAxisPoint0[0],\n          shortAxisPoint1[1] - shortAxisPoint0[0]\n        );\n\n        let shortAxis;\n\n        if (\n          vec2.dot(\n            currentShortAxisVector,\n            counterClockWisePerpendicularToLongAxis\n          ) > 0\n        ) {\n          shortAxis = [shortAxisPoint0, shortAxisPoint1];\n        } else {\n          shortAxis = [shortAxisPoint1, shortAxisPoint0];\n        }\n\n        data.handles.points = [\n          longAxis[0],\n          longAxis[1],\n          shortAxis[0],\n          shortAxis[1],\n        ];\n      }\n    }\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * @param evt - mouse move event type or mouse drag\n   */\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    const worldPos = currentPoints.world;\n\n    // Update first move handle\n    data.handles.points[handleIndex] = [...worldPos];\n\n    const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n\n    const canvasCoords = {\n      longLineSegment: {\n        start: {\n          x: canvasCoordPoints[0][0],\n          y: canvasCoordPoints[0][1],\n        },\n        end: {\n          x: canvasCoordPoints[1][0],\n          y: canvasCoordPoints[1][1],\n        },\n      },\n      shortLineSegment: {\n        start: {\n          x: canvasCoordPoints[2][0],\n          y: canvasCoordPoints[2][1],\n        },\n        end: {\n          x: canvasCoordPoints[3][0],\n          y: canvasCoordPoints[3][1],\n        },\n      },\n    };\n\n    // ~~ calculate worldPos of our short axis handles\n    // short axis is perpendicular to long axis, and we set its length to be 2/3 of long axis\n    // (meaning each)\n    const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n\n    const shortAxisDistFromCenter = dist / 3;\n    // Calculate long line's incline\n    const dx =\n      canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n    const dy =\n      canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const vectorX = dx / length;\n    const vectorY = dy / length;\n    // middle point between long line segment's points\n    const xMid =\n      (canvasCoords.longLineSegment.start.x +\n        canvasCoords.longLineSegment.end.x) /\n      2;\n    const yMid =\n      (canvasCoords.longLineSegment.start.y +\n        canvasCoords.longLineSegment.end.y) /\n      2;\n    // short points 1/3 distance from center of long points\n    const startX = xMid + shortAxisDistFromCenter * vectorY;\n    const startY = yMid - shortAxisDistFromCenter * vectorX;\n    const endX = xMid - shortAxisDistFromCenter * vectorY;\n    const endY = yMid + shortAxisDistFromCenter * vectorX;\n\n    // Update perpendicular line segment's points\n    data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n    data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n\n    annotation.invalidated = true;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    this.editData.hasMoved = true;\n  };\n\n  /**\n   * Mouse drag to edit annotation callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n    if (movingTextBox) {\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragModifyHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  /**\n   * Mouse dragging a handle callback\n   * @param evt - mouse drag event\n   */\n  _dragModifyHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, handleIndex: movingHandleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle\n    const worldPos = currentPoints.world;\n    const canvasCoordHandlesCurrent = [\n      viewport.worldToCanvas(data.handles.points[0]),\n      viewport.worldToCanvas(data.handles.points[1]),\n      viewport.worldToCanvas(data.handles.points[2]),\n      viewport.worldToCanvas(data.handles.points[3]),\n    ];\n\n    const firstLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[0][0],\n        y: canvasCoordHandlesCurrent[0][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[1][0],\n        y: canvasCoordHandlesCurrent[1][1],\n      },\n    };\n    const secondLineSegment = {\n      start: {\n        x: canvasCoordHandlesCurrent[2][0],\n        y: canvasCoordHandlesCurrent[2][1],\n      },\n      end: {\n        x: canvasCoordHandlesCurrent[3][0],\n        y: canvasCoordHandlesCurrent[3][1],\n      },\n    };\n\n    // Handle we've selected's proposed point\n    const proposedPoint = <Types.Point3>[...worldPos];\n    const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n\n    if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n      const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n\n      const fixedHandleCanvasCoord =\n        canvasCoordHandlesCurrent[fixedHandleIndex];\n\n      const fixedHandleToProposedCoordVec = vec2.set(\n        vec2.create(),\n        proposedCanvasCoord[0] - fixedHandleCanvasCoord[0],\n        proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]\n      );\n\n      const fixedHandleToOldCoordVec = vec2.set(\n        vec2.create(),\n        canvasCoordHandlesCurrent[movingHandleIndex][0] -\n          fixedHandleCanvasCoord[0],\n        canvasCoordHandlesCurrent[movingHandleIndex][1] -\n          fixedHandleCanvasCoord[1]\n      );\n\n      // normalize vector\n      vec2.normalize(\n        fixedHandleToProposedCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n      vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n\n      // Check whether this\n      const proposedFirstLineSegment = {\n        start: {\n          x: fixedHandleCanvasCoord[0],\n          y: fixedHandleCanvasCoord[1],\n        },\n        end: {\n          x: proposedCanvasCoord[0],\n          y: proposedCanvasCoord[1],\n        },\n      };\n\n      // Note: this is the case when we are modifying the long axis line segment\n      // and we make it shorter and shorter until its second half size becomes zero\n      // which basically means that any more modification would make the long axis\n      // second half disappear. In this case, we just bail out and do not update\n      // since we don't want to disrupt the bidirectional shape.\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          proposedFirstLineSegment,\n          secondLineSegment\n        )\n      ) {\n        return;\n      }\n\n      const centerOfRotation = fixedHandleCanvasCoord;\n\n      const angle = this._getSignedAngle(\n        fixedHandleToOldCoordVec,\n        fixedHandleToProposedCoordVec\n      );\n\n      // rotate handles around the center of rotation, first translate to origin,\n      // then rotate, then translate back\n      let firstPointX = canvasCoordHandlesCurrent[2][0];\n      let firstPointY = canvasCoordHandlesCurrent[2][1];\n\n      let secondPointX = canvasCoordHandlesCurrent[3][0];\n      let secondPointY = canvasCoordHandlesCurrent[3][1];\n\n      // translate to origin\n      firstPointX -= centerOfRotation[0];\n      firstPointY -= centerOfRotation[1];\n\n      secondPointX -= centerOfRotation[0];\n      secondPointY -= centerOfRotation[1];\n\n      // rotate\n      const rotatedFirstPoint =\n        firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n      const rotatedFirstPointY =\n        firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n\n      const rotatedSecondPoint =\n        secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n      const rotatedSecondPointY =\n        secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n\n      // translate back\n      firstPointX = rotatedFirstPoint + centerOfRotation[0];\n      firstPointY = rotatedFirstPointY + centerOfRotation[1];\n\n      secondPointX = rotatedSecondPoint + centerOfRotation[0];\n      secondPointY = rotatedSecondPointY + centerOfRotation[1];\n\n      // update handles\n      const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n      const newSecondPoint = viewport.canvasToWorld([\n        secondPointX,\n        secondPointY,\n      ]);\n\n      // the fixed handle is the one that is not being moved so we\n      // don't need to update it\n      data.handles.points[movingHandleIndex] = proposedPoint;\n      data.handles.points[2] = newFirstPoint;\n      data.handles.points[3] = newSecondPoint;\n    } else {\n      // Translation manipulator\n      const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n\n      const canvasCoordsCurrent = {\n        longLineSegment: {\n          start: firstLineSegment.start,\n          end: firstLineSegment.end,\n        },\n        shortLineSegment: {\n          start: secondLineSegment.start,\n          end: secondLineSegment.end,\n        },\n      };\n\n      const longLineSegmentVec = vec2.subtract(\n        vec2.create(),\n        [\n          canvasCoordsCurrent.longLineSegment.end.x,\n          canvasCoordsCurrent.longLineSegment.end.y,\n        ],\n        [\n          canvasCoordsCurrent.longLineSegment.start.x,\n          canvasCoordsCurrent.longLineSegment.start.y,\n        ]\n      );\n\n      const longLineSegmentVecNormalized = vec2.normalize(\n        vec2.create(),\n        longLineSegmentVec\n      );\n\n      const proposedToCurrentVec = vec2.subtract(\n        vec2.create(),\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [\n          canvasCoordHandlesCurrent[movingHandleIndex][0],\n          canvasCoordHandlesCurrent[movingHandleIndex][1],\n        ]\n      );\n\n      const movementLength = vec2.length(proposedToCurrentVec);\n\n      const angle = this._getSignedAngle(\n        longLineSegmentVecNormalized,\n        proposedToCurrentVec\n      );\n\n      const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n\n      const newTranslatedPoint = vec2.scaleAndAdd(\n        vec2.create(),\n        [\n          canvasCoordHandlesCurrent[translateHandleIndex][0],\n          canvasCoordHandlesCurrent[translateHandleIndex][1],\n        ],\n        longLineSegmentVecNormalized,\n        movementAlongLineSegmentLength\n      );\n\n      // don't update if it passes through the other line segment\n      if (\n        this._movingLongAxisWouldPutItThroughShortAxis(\n          {\n            start: {\n              x: proposedCanvasCoord[0],\n              y: proposedCanvasCoord[1],\n            },\n            end: {\n              x: newTranslatedPoint[0],\n              y: newTranslatedPoint[1],\n            },\n          },\n          {\n            start: {\n              x: canvasCoordsCurrent.longLineSegment.start.x,\n              y: canvasCoordsCurrent.longLineSegment.start.y,\n            },\n            end: {\n              x: canvasCoordsCurrent.longLineSegment.end.x,\n              y: canvasCoordsCurrent.longLineSegment.end.y,\n            },\n          }\n        )\n      ) {\n        return;\n      }\n\n      const intersectionPoint = lineSegment.intersectLine(\n        [proposedCanvasCoord[0], proposedCanvasCoord[1]],\n        [newTranslatedPoint[0], newTranslatedPoint[1]],\n        [firstLineSegment.start.x, firstLineSegment.start.y],\n        [firstLineSegment.end.x, firstLineSegment.end.y]\n      );\n\n      // don't update if it doesn't intersect\n      if (!intersectionPoint) {\n        return;\n      }\n\n      data.handles.points[translateHandleIndex] = viewport.canvasToWorld(\n        newTranslatedPoint as Types.Point2\n      );\n      data.handles.points[movingHandleIndex] = proposedPoint;\n    }\n  };\n\n  /**\n   * Cancels an ongoing drawing of a bidirectional annotation\n   * @param element - HTML Element\n   */\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragDrawCallback as EventListener\n    );\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragModifyCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the bidirectional annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = true;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as BidirectionalAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n      // If cachedStats does not exist, or the unit is missing (as part of import/hydration etc.),\n      // force to recalculate the stats from the points\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].unit == null\n      ) {\n        data.cachedStats[targetId] = {\n          length: null,\n          width: null,\n          unit: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId1 = `${annotationUID}-line-1`;\n      const dataId2 = `${annotationUID}-line-2`;\n\n      const lineUID = '0';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId1\n      );\n\n      const secondLineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        secondLineUID,\n        canvasCoordinates[2],\n        canvasCoordinates[3],\n        {\n          color,\n          lineDash,\n          lineWidth,\n          shadow,\n        },\n        dataId2\n      );\n\n      renderStatus = true;\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n      if (!textLines || textLines.length === 0) {\n        continue;\n      }\n\n      let canvasTextBoxCoords;\n\n      if (!data.handles.textBox.hasMoved) {\n        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _movingLongAxisWouldPutItThroughShortAxis = (\n    firstLineSegment,\n    secondLineSegment\n  ) => {\n    const vectorInSecondLineDirection = vec2.create();\n\n    vec2.set(\n      vectorInSecondLineDirection,\n      secondLineSegment.end.x - secondLineSegment.start.x,\n      secondLineSegment.end.y - secondLineSegment.start.y\n    );\n\n    vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n\n    const extendedSecondLineSegment = {\n      start: {\n        x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n      },\n      end: {\n        x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n        y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n      },\n    };\n\n    // Add some buffer in the secondLineSegment when finding the proposedIntersectionPoint\n    // Of points to stop us getting stack when rotating quickly.\n\n    const proposedIntersectionPoint = lineSegment.intersectLine(\n      [extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y],\n      [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y],\n      [firstLineSegment.start.x, firstLineSegment.start.y],\n      [firstLineSegment.end.x, firstLineSegment.end.y]\n    );\n\n    const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n\n    return wouldPutThroughShortAxis;\n  };\n\n  _calculateLength(pos1, pos2) {\n    const dx = pos1[0] - pos2[0];\n    const dy = pos1[1] - pos2[1];\n    const dz = pos1[2] - pos2[2];\n\n    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n  }\n\n  _calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n    const { data } = annotation;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n    const worldPos4 = data.handles.points[3];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      const image = this.getTargetIdImage(targetId, renderingEngine);\n\n      // If image does not exists for the targetId, skip. This can be due\n      // to various reasons such as if the target was a volumeViewport, and\n      // the volumeViewport has been decached in the meantime.\n      if (!image) {\n        continue;\n      }\n\n      const { imageData, dimensions } = image;\n      const scale = getCalibratedScale(image);\n      const dist1 = this._calculateLength(worldPos1, worldPos2) / scale;\n      const dist2 = this._calculateLength(worldPos3, worldPos4) / scale;\n      const length = dist1 > dist2 ? dist1 : dist2;\n      const width = dist1 > dist2 ? dist2 : dist1;\n\n      const index1 = transformWorldToIndex(imageData, worldPos1);\n      const index2 = transformWorldToIndex(imageData, worldPos2);\n      const index3 = transformWorldToIndex(imageData, worldPos3);\n      const index4 = transformWorldToIndex(imageData, worldPos4);\n\n      this._isInsideVolume(index1, index2, index3, index4, dimensions)\n        ? (this.isHandleOutsideImage = false)\n        : (this.isHandleOutsideImage = true);\n\n      cachedStats[targetId] = {\n        length,\n        width,\n        unit: getCalibratedLengthUnits(null, image),\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, index3, index4, dimensions): boolean => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions) &&\n      csUtils.indexWithinDimensions(index3, dimensions) &&\n      csUtils.indexWithinDimensions(index4, dimensions)\n    );\n  };\n\n  _getSignedAngle = (vector1, vector2) => {\n    return Math.atan2(\n      vector1[0] * vector2[1] - vector1[1] * vector2[0],\n      vector1[0] * vector2[0] + vector1[1] * vector2[1]\n    );\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const { cachedStats } = data;\n  const { length, width, unit } = cachedStats[targetId];\n\n  if (length === undefined) {\n    return;\n  }\n\n  // spaceBetweenSlices & pixelSpacing &\n  // magnitude in each direction? Otherwise, this is \"px\"?\n  const textLines = [\n    `L: ${roundNumber(length)} ${unit}`,\n    `W: ${roundNumber(width)} ${unit}`,\n  ];\n\n  return textLines;\n}\n\nBidirectionalTool.toolName = 'Bidirectional';\nexport default BidirectionalTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawArrow as drawArrowSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { ArrowAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass ArrowAnnotateTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        getTextCallback,\n        changeTextCallback,\n        preventHandleOutsideImage: false,\n        arrowFirst: true,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): ArrowAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const { arrowFirst } = this.configuration;\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        text: '',\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          arrowFirst,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: ArrowAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line.start.x, line.start.y],\n      [line.end.x, line.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: ArrowAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId, renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    if (newAnnotation) {\n      this.configuration.getTextCallback((text) => {\n        if (!text) {\n          removeAnnotation(annotation.annotationUID);\n          triggerAnnotationRenderForViewportIds(\n            renderingEngine,\n            viewportIdsToRender\n          );\n          this.editData = null;\n          this.isDrawing = false;\n          return;\n        }\n        annotation.data.text = text;\n\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n\n        triggerAnnotationRenderForViewportIds(\n          renderingEngine,\n          viewportIdsToRender\n        );\n      });\n    } else {\n      const eventType = Events.ANNOTATION_MODIFIED;\n\n      const eventDetail: AnnotationModifiedEventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  touchTapCallback = (evt: EventTypes.TouchTapEventType) => {\n    if (evt.detail.taps == 2) {\n      this.doubleClickCallback(evt);\n    }\n  };\n\n  doubleClickCallback = (evt: EventTypes.TouchTapEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const clickedAnnotation = annotations.find((annotation) =>\n      this.isPointNearTool(\n        element,\n        annotation as ArrowAnnotation,\n        eventDetail.currentPoints.canvas,\n        6 // Todo: get from configuration\n      )\n    );\n\n    if (!clickedAnnotation) {\n      return;\n    }\n\n    const annotation = clickedAnnotation as ArrowAnnotation;\n\n    this.configuration.changeTextCallback(\n      clickedAnnotation,\n      evt.detail,\n      this._doneChangingTextCallback.bind(this, element, annotation)\n    );\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    // This double click was handled and the dialogue was displayed.\n    // No need for any other listener to handle it too - stopImmediatePropagation\n    // helps ensure this primarily so that no other listeners on the target element\n    // get called.\n    evt.stopImmediatePropagation();\n    evt.preventDefault();\n  };\n\n  _doneChangingTextCallback(element, annotation, updatedText): void {\n    annotation.data.text = updatedText;\n\n    const { renderingEngine, viewportId, renderingEngineId } =\n      getEnabledElement(element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    triggerEvent(eventTarget, eventType, {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    });\n  }\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ArrowAnnotation;\n      const { annotationUID, data } = annotation;\n      const { handles, text } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineWidth,\n          }\n        );\n      }\n\n      const arrowUID = '1';\n      if (this.configuration.arrowFirst) {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[1],\n          canvasCoordinates[0],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      } else {\n        drawArrowSvg(\n          svgDrawingHelper,\n          annotationUID,\n          arrowUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          {\n            color,\n            width: lineWidth,\n            lineDash: lineDash,\n          }\n        );\n      }\n\n      renderStatus = true;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!text) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      // Need to update to sync w/ annotation while unlinked/not moved\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the point that doesn't have the arrowhead by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        [text],\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _isInsideVolume(index1, index2, dimensions) {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  }\n}\n\nfunction getTextCallback(doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n  return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\n\nArrowAnnotateTool.toolName = 'ArrowAnnotate';\nexport default ArrowAnnotateTool;\n","import { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport roundNumber from '../../utilities/roundNumber';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { AngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass AngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.InteractionEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n    const [point1, point2, point3] = data.handles.points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n    if (!point3) {\n      return false;\n    }\n\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n\n    const line2 = {\n      start: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n      end: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n    };\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    if (distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.InteractionEventType,\n    annotation: AngleAnnotation,\n    handle: ToolHandle\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n      // adds the last point to the measurement\n      this.editData.handleIndex = 2;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex, movingTextBox } =\n      this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (handleIndex === undefined) {\n      // Drag mode - moving handle\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      // Move mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this._deactivateDraw(element);\n      this._deactivateModify(element);\n      resetElementCursor(element);\n\n      const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n      const { data } = annotation;\n\n      annotation.highlighted = false;\n      data.handles.activeHandleIndex = null;\n\n      const enabledElement = getEnabledElement(element);\n      const { renderingEngine } = enabledElement;\n\n      triggerAnnotationRenderForViewportIds(\n        renderingEngine,\n        viewportIdsToRender\n      );\n\n      if (newAnnotation) {\n        const eventType = Events.ANNOTATION_COMPLETED;\n\n        const eventDetail: AnnotationCompletedEventDetail = {\n          annotation,\n        };\n\n        triggerEvent(eventTarget, eventType, eventDetail);\n      }\n\n      this.editData = null;\n      this.angleStartedNotYetCompleted = false;\n      return annotation.annotationUID;\n    }\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._endCallback as EventListener\n    );\n\n    element.removeEventListener(\n      Events.TOUCH_TAP,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._endCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      let lineUID = '1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[0],\n        canvasCoordinates[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add textBox until annotation has 3 anchor points (actually 4 because of the center point)\n      if (canvasCoordinates.length !== 3) {\n        return renderStatus;\n      }\n\n      lineUID = '2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCoordinates[1],\n        canvasCoordinates[2],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        // linked to the vertex by default\n        const canvasTextBoxCoords = canvasCoordinates[1];\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = '1';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all three anchors bail out\n    if (data.handles.points.length !== 3) {\n      return;\n    }\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[1];\n    const worldPos3 = data.handles.points[2];\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n      const angle = angleBetweenLines(\n        [worldPos1, worldPos2],\n        [worldPos2, worldPos3]\n      );\n\n      cachedStats[targetId] = {\n        angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${roundNumber(angle)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nAngleTool.toolName = 'Angle';\nexport default AngleTool;\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Return the midpoint (think average) of all the provided points.\n */\nconst midPoint = (\n  ...args: (Types.Point2 | Types.Point3)[]\n): Types.Point2 | Types.Point3 => {\n  const ret =\n    args[0].length === 2 ? <Types.Point2>[0, 0] : <Types.Point3>[0, 0, 0];\n  const len = args.length;\n  for (const arg of args) {\n    ret[0] += arg[0] / len;\n    ret[1] += arg[1] / len;\n    if (ret.length === 3) {\n      ret[2] += arg[2] / len;\n    }\n  }\n  return ret;\n};\n\nconst midPoint2 = midPoint as (...args: Types.Point2[]) => Types.Point2;\n\nexport default midPoint;\n\nexport { midPoint2 };\n","import { vec3 } from 'gl-matrix';\nimport { Events } from '../../enums';\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\n\nimport {\n  drawHandles as drawHandlesSvg,\n  drawLine as drawLineSvg,\n  drawLinkedTextBox as drawLinkedTextBoxSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  AnnotationCompletedEventDetail,\n  AnnotationModifiedEventDetail,\n} from '../../types/EventTypes';\n\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport {\n  EventTypes,\n  ToolHandle,\n  TextBoxHandle,\n  PublicToolProps,\n  ToolProps,\n  InteractionTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { CobbAngleAnnotation } from '../../types/ToolSpecificAnnotationTypes';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\n\nclass CobbAngleTool extends AnnotationTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  angleStartedNotYetCompleted: boolean;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox?: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    isNearFirstLine?: boolean;\n    isNearSecondLine?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        getTextLines: defaultGetTextLines,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      25,\n      { trailing: true }\n    );\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a Length Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.MouseDownActivateEventType\n  ): CobbAngleAnnotation => {\n    if (this.angleStartedNotYetCompleted) {\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    hideElementCursor(element);\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        handles: {\n          points: [<Types.Point3>[...worldPos], <Types.Point3>[...worldPos]],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n        label: '',\n        cachedStats: {},\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex: 1,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided length annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: CobbAngleAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { data } = annotation;\n\n    const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n      viewport,\n      points: data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    interactionType: InteractionTypes,\n    canvasCoords: Types.Point2,\n    proximity = 6\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n\n    const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n      viewport,\n      points: annotation.data.handles.points,\n      canvasCoords,\n      proximity,\n    });\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      movingTextBox: false,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback(\n    evt: EventTypes.MouseDownEventType,\n    annotation: CobbAngleAnnotation,\n    handle: ToolHandle,\n    interactionType = 'mouse'\n  ): void {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if ((handle as TextBoxHandle).worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  }\n\n  _mouseUpCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation, hasMoved } =\n      this.editData;\n\n    const { data } = annotation;\n    if (newAnnotation && !hasMoved) {\n      // when user starts the drawing by click, and moving the mouse, instead\n      // of click and drag\n      return;\n    }\n\n    // If preventing new measurement means we are in the middle of an existing measurement\n    // we shouldn't deactivate modify or draw\n    if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n      resetElementCursor(element);\n\n      // adds the first point of the second line\n      this.editData.handleIndex = data.handles.points.length;\n      return;\n    }\n\n    this.angleStartedNotYetCompleted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.isDrawing = false;\n  };\n\n  /**\n   * Handles the mouse down for all points that follow the very first mouse down.\n   * The very first mouse down is handled by addAnnotation.\n   * This method ensures that the state of the tool is correct for the drawing of the second line segment.\n   * In particular it ensures that the second segment can be created via a mouse down and drag.\n   */\n  _mouseDownCallback = (\n    evt: EventTypes.MouseUpEventType | EventTypes.MouseClickEventType\n  ) => {\n    const { annotation, handleIndex } = this.editData;\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const worldPos = currentPoints.world;\n    const { data } = annotation;\n\n    if (handleIndex === 1) {\n      // This is the mouse down for the second point of the first segment.\n      // The mouse up takes care of adding the first point of the second segment.\n      data.handles.points[1] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[1][0] !== data.handles.points[0][0] ||\n        data.handles.points[1][1] !== data.handles.points[0][0];\n      return;\n    }\n\n    if (handleIndex === 3) {\n      // This is the mouse down for the second point of the second segment (i.e. the last point)\n      data.handles.points[3] = worldPos;\n      this.editData.hasMoved =\n        data.handles.points[3][0] !== data.handles.points[2][0] ||\n        data.handles.points[3][1] !== data.handles.points[2][0];\n\n      this.angleStartedNotYetCompleted = false;\n      return;\n    }\n\n    // This is the first mouse down of the first point of the second line segment.\n    // It is as if we have not moved yet because Cobb Angle has two, disjoint sections, each with its own move.\n    this.editData.hasMoved = false;\n    hideElementCursor(element);\n\n    // Add the last segment points for the subsequent drag/mouse move.\n    data.handles.points[2] = data.handles.points[3] = worldPos;\n    this.editData.handleIndex = data.handles.points.length - 1;\n  };\n\n  _mouseDragCallback = (\n    evt: EventTypes.MouseDragEventType | EventTypes.MouseMoveEventType\n  ) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n      movingTextBox,\n      isNearFirstLine,\n      isNearSecondLine,\n    } = this.editData;\n    const { data } = annotation;\n\n    if (movingTextBox) {\n      // Drag mode - moving text box\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const { textBox } = data.handles;\n      const { worldPosition } = textBox;\n\n      worldPosition[0] += worldPosDelta[0];\n      worldPosition[1] += worldPosDelta[1];\n      worldPosition[2] += worldPosDelta[2];\n\n      textBox.hasMoved = true;\n    } else if (\n      handleIndex === undefined &&\n      (isNearFirstLine || isNearSecondLine)\n    ) {\n      // select tool mode - moving annotation\n      const { deltaPoints } = eventDetail as EventTypes.MouseDragEventDetail;\n      const worldPosDelta = deltaPoints.world;\n      const points = data.handles.points;\n\n      // separate the logic for moving handles to move them separately\n      if (isNearFirstLine) {\n        const firstLinePoints = [points[0], points[1]];\n        firstLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      } else if (isNearSecondLine) {\n        const secondLinePoints = [points[2], points[3]];\n        secondLinePoints.forEach((point) => {\n          point[0] += worldPosDelta[0];\n          point[1] += worldPosDelta[1];\n          point[2] += worldPosDelta[2];\n        });\n      }\n\n      annotation.invalidated = true;\n    } else {\n      // Drag handle mode - after double click, and mouse move to draw\n      const { currentPoints } = eventDetail;\n      const worldPos = currentPoints.world;\n\n      data.handles.points[handleIndex] = [...worldPos];\n      annotation.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    if (data.handles.points.length < 4) {\n      // If it is mid-draw\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    this.angleStartedNotYetCompleted = false;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateModify = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.addEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._mouseUpCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DOWN,\n      this._mouseDownCallback as EventListener\n    );\n\n    // element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback)\n    // element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback)\n  };\n\n  /**\n   * it is used to draw the length annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    // Draw SVG\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as CobbAngleAnnotation;\n      const { annotationUID, data } = annotation;\n      const { points, activeHandleIndex } = data.handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      // WE HAVE TO CACHE STATS BEFORE FETCHING TEXT\n      if (\n        !data.cachedStats[targetId] ||\n        data.cachedStats[targetId].angle == null\n      ) {\n        data.cachedStats[targetId] = {\n          angle: null,\n          arc1Angle: null,\n          arc2Angle: null,\n          points: {\n            world: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n            canvas: {\n              arc1Start: null,\n              arc1End: null,\n              arc2Start: null,\n              arc2End: null,\n              arc1Angle: null,\n              arc2Angle: null,\n            },\n          },\n        };\n\n        this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n      } else if (annotation.invalidated) {\n        this._throttledCalculateCachedStats(\n          annotation,\n          renderingEngine,\n          enabledElement\n        );\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          canvasCoordinates,\n          {\n            color,\n            lineDash,\n            lineWidth,\n          }\n        );\n      }\n\n      const firstLine = [canvasCoordinates[0], canvasCoordinates[1]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n      const secondLine = [canvasCoordinates[2], canvasCoordinates[3]] as [\n        Types.Point2,\n        Types.Point2\n      ];\n\n      let lineUID = 'line1';\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        firstLine[0],\n        firstLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      renderStatus = true;\n\n      // Don't add the stats until annotation has 4 anchor points\n      if (canvasCoordinates.length < 4) {\n        return renderStatus;\n      }\n\n      lineUID = 'line2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        secondLine[0],\n        secondLine[1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n        }\n      );\n\n      lineUID = 'linkLine';\n      const mid1 = midPoint2(firstLine[0], firstLine[1]);\n      const mid2 = midPoint2(secondLine[0], secondLine[1]);\n      drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n        color,\n        lineWidth: '1',\n        lineDash: '1,4',\n      });\n\n      // Calculating the arcs\n\n      const { arc1Start, arc1End, arc2End, arc2Start } =\n        data.cachedStats[targetId].points.canvas;\n      const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n\n      lineUID = 'arc1';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        arc1Start as Types.Point2,\n        arc1End as Types.Point2,\n        {\n          color,\n          lineWidth: '1',\n        }\n      );\n\n      lineUID = 'arc2';\n\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        arc2Start as Types.Point2,\n        arc2End as Types.Point2,\n        {\n          color,\n          lineWidth: '1',\n        }\n      );\n\n      if (!data.cachedStats[targetId]?.angle) {\n        continue;\n      }\n\n      const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n      if (!options.visibility) {\n        data.handles.textBox = {\n          hasMoved: false,\n          worldPosition: <Types.Point3>[0, 0, 0],\n          worldBoundingBox: {\n            topLeft: <Types.Point3>[0, 0, 0],\n            topRight: <Types.Point3>[0, 0, 0],\n            bottomLeft: <Types.Point3>[0, 0, 0],\n            bottomRight: <Types.Point3>[0, 0, 0],\n          },\n        };\n        continue;\n      }\n\n      const textLines = this.configuration.getTextLines(data, targetId);\n\n      if (!data.handles.textBox.hasMoved) {\n        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n\n        data.handles.textBox.worldPosition =\n          viewport.canvasToWorld(canvasTextBoxCoords);\n      }\n\n      const textBoxPosition = viewport.worldToCanvas(\n        data.handles.textBox.worldPosition\n      );\n\n      const textBoxUID = 'cobbAngleText';\n      const boundingBox = drawLinkedTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        textBoxUID,\n        textLines,\n        textBoxPosition,\n        canvasCoordinates,\n        {},\n        options\n      );\n\n      const { x: left, y: top, width, height } = boundingBox;\n\n      data.handles.textBox.worldBoundingBox = {\n        topLeft: viewport.canvasToWorld([left, top]),\n        topRight: viewport.canvasToWorld([left + width, top]),\n        bottomLeft: viewport.canvasToWorld([left, top + height]),\n        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n      };\n\n      const arc1TextBoxUID = 'arcAngle1';\n\n      const arc1TextLine = [\n        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n      ];\n\n      const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        arc1TextBoxUID,\n        arc1TextLine,\n        arch1TextPosCanvas,\n        {\n          ...options,\n          padding: 3,\n        }\n      );\n\n      const arc2TextBoxUID = 'arcAngle2';\n\n      const arc2TextLine = [\n        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n      ];\n\n      const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n\n      drawTextBoxSvg(\n        svgDrawingHelper,\n        annotationUID,\n        arc2TextBoxUID,\n        arc2TextLine,\n        arch2TextPosCanvas,\n        {\n          ...options,\n          padding: 3,\n        }\n      );\n    }\n\n    return renderStatus;\n  };\n\n  _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n    const data = annotation.data;\n    const { viewportId, renderingEngineId } = enabledElement;\n\n    // Until we have all four anchors bail out\n    if (data.handles.points.length !== 4) {\n      return;\n    }\n\n    const seg1: [Types.Point3, Types.Point3] = [null, null];\n    const seg2: [Types.Point3, Types.Point3] = [null, null];\n    let minDist = Number.MAX_VALUE;\n\n    // Order the endpoints of each line segment such that seg1[1] and seg2[0]\n    // are the closest (Euclidean distance-wise) to each other. Thus\n    // the angle formed between the vectors seg1[1]->seg1[0] and seg2[0]->seg[1]\n    // is calculated.\n    // The assumption here is that the Cobb angle line segments are drawn\n    // such that the segments intersect nearest the segment endpoints\n    // that are closest AND those closest endpoints are the tails of the\n    // vectors used to calculate the angle between the vectors/line segments.\n    for (let i = 0; i < 2; i += 1) {\n      for (let j = 2; j < 4; j += 1) {\n        const dist = vec3.distance(\n          data.handles.points[i],\n          data.handles.points[j]\n        );\n        if (dist < minDist) {\n          minDist = dist;\n          seg1[1] = data.handles.points[i];\n          seg1[0] = data.handles.points[(i + 1) % 2];\n          seg2[0] = data.handles.points[j];\n          seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n        }\n      }\n    }\n    const { viewport } = enabledElement;\n\n    const canvasPoints = data.handles.points.map((p) =>\n      viewport.worldToCanvas(p)\n    );\n\n    const firstLine = [canvasPoints[0], canvasPoints[1]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n    const secondLine = [canvasPoints[2], canvasPoints[3]] as [\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const mid1 = midPoint2(firstLine[0], firstLine[1]);\n    const mid2 = midPoint2(secondLine[0], secondLine[1]);\n\n    const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } =\n      this.getArcsStartEndPoints({\n        firstLine,\n        secondLine,\n        mid1,\n        mid2,\n      });\n\n    const { cachedStats } = data;\n    const targetIds = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetIds.length; i++) {\n      const targetId = targetIds[i];\n\n      cachedStats[targetId] = {\n        angle: angleBetweenLines(seg1, seg2),\n        arc1Angle,\n        arc2Angle,\n        points: {\n          canvas: {\n            arc1Start,\n            arc1End,\n            arc2End,\n            arc2Start,\n          },\n          world: {\n            arc1Start: viewport.canvasToWorld(arc1Start),\n            arc1End: viewport.canvasToWorld(arc1End),\n            arc2End: viewport.canvasToWorld(arc2End),\n            arc2Start: viewport.canvasToWorld(arc2Start),\n          },\n        },\n      };\n    }\n\n    annotation.invalidated = false;\n\n    // Dispatching annotation modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail: AnnotationModifiedEventDetail = {\n      annotation,\n      viewportId,\n      renderingEngineId,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  }\n\n  distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n    const [point1, point2, point3, point4] = points;\n    const canvasPoint1 = viewport.worldToCanvas(point1);\n    const canvasPoint2 = viewport.worldToCanvas(point2);\n    const canvasPoint3 = viewport.worldToCanvas(point3);\n    const canvasPoint4 = viewport.worldToCanvas(point4);\n\n    const line1 = {\n      start: {\n        x: canvasPoint1[0],\n        y: canvasPoint1[1],\n      },\n      end: {\n        x: canvasPoint2[0],\n        y: canvasPoint2[1],\n      },\n    };\n\n    const line2 = {\n      start: {\n        x: canvasPoint3[0],\n        y: canvasPoint3[1],\n      },\n      end: {\n        x: canvasPoint4[0],\n        y: canvasPoint4[1],\n      },\n    };\n\n    const distanceToPoint = lineSegment.distanceToPoint(\n      [line1.start.x, line1.start.y],\n      [line1.end.x, line1.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    const distanceToPoint2 = lineSegment.distanceToPoint(\n      [line2.start.x, line2.start.y],\n      [line2.end.x, line2.end.y],\n      [canvasCoords[0], canvasCoords[1]]\n    );\n\n    let isNearFirstLine = false;\n    let isNearSecondLine = false;\n\n    if (distanceToPoint <= proximity) {\n      isNearFirstLine = true;\n    } else if (distanceToPoint2 <= proximity) {\n      isNearSecondLine = true;\n    }\n    return {\n      distanceToPoint,\n      distanceToPoint2,\n      isNearFirstLine,\n      isNearSecondLine,\n    };\n  };\n\n  getArcsStartEndPoints = ({\n    firstLine,\n    secondLine,\n    mid1,\n    mid2,\n  }): {\n    arc1Start: Types.Point2;\n    arc1End: Types.Point2;\n    arc2Start: Types.Point2;\n    arc2End: Types.Point2;\n    arc1Angle: number;\n    arc2Angle: number;\n  } => {\n    const linkLine = [mid1, mid2] as [Types.Point2, Types.Point2];\n\n    const arc1Angle = angleBetweenLines(firstLine, linkLine);\n    const arc2Angle = angleBetweenLines(secondLine, linkLine);\n\n    const arc1Side = arc1Angle > 90 ? 1 : 0;\n    const arc2Side = arc2Angle > 90 ? 0 : 1;\n\n    const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n\n    const linkLineLength = Math.sqrt(\n      (linkLine[1][0] - linkLine[0][0]) ** 2 +\n        (linkLine[1][1] - linkLine[0][1]) ** 2\n    );\n    const ratio = 0.1; // 10% of the line length\n\n    const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n    const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n\n    // For arc1Start\n    const directionVectorStartArc1 = [\n      firstLine[arc1Side][0] - midFirstLine[0],\n      firstLine[arc1Side][1] - midFirstLine[1],\n    ];\n    const magnitudeStartArc1 = Math.sqrt(\n      directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2\n    );\n    const normalizedDirectionStartArc1 = [\n      directionVectorStartArc1[0] / magnitudeStartArc1,\n      directionVectorStartArc1[1] / magnitudeStartArc1,\n    ];\n    const arc1Start = [\n      midFirstLine[0] +\n        normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n      midFirstLine[1] +\n        normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Existing logic for arc1End\n    const directionVectorEndArc1 = [\n      midLinkLine[0] - mid1[0],\n      midLinkLine[1] - mid1[1],\n    ];\n    const magnitudeEndArc1 = Math.sqrt(\n      directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2\n    );\n    const normalizedDirectionEndArc1 = [\n      directionVectorEndArc1[0] / magnitudeEndArc1,\n      directionVectorEndArc1[1] / magnitudeEndArc1,\n    ];\n    const arc1End = [\n      mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n      mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2Start\n    const directionVectorStartArc2 = [\n      secondLine[arc2Side][0] - midSecondLine[0],\n      secondLine[arc2Side][1] - midSecondLine[1],\n    ];\n    const magnitudeStartArc2 = Math.sqrt(\n      directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2\n    );\n    const normalizedDirectionStartArc2 = [\n      directionVectorStartArc2[0] / magnitudeStartArc2,\n      directionVectorStartArc2[1] / magnitudeStartArc2,\n    ];\n    const arc2Start = [\n      midSecondLine[0] +\n        normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n      midSecondLine[1] +\n        normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    // Similar logic for arc2End\n    const directionVectorEndArc2 = [\n      midLinkLine[0] - mid2[0],\n      midLinkLine[1] - mid2[1],\n    ];\n    const magnitudeEndArc2 = Math.sqrt(\n      directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2\n    );\n    const normalizedDirectionEndArc2 = [\n      directionVectorEndArc2[0] / magnitudeEndArc2,\n      directionVectorEndArc2[1] / magnitudeEndArc2,\n    ];\n    const arc2End = [\n      mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n      mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n    ] as Types.Point2;\n\n    return {\n      arc1Start,\n      arc1End,\n      arc2Start,\n      arc2End,\n      arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n      arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n    };\n  };\n}\n\nfunction defaultGetTextLines(data, targetId): string[] {\n  const cachedVolumeStats = data.cachedStats[targetId];\n  const { angle } = cachedVolumeStats;\n\n  if (angle === undefined) {\n    return;\n  }\n\n  const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n\n  return textLines;\n}\n\nCobbAngleTool.toolName = 'CobbAngle';\nexport default CobbAngleTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\n\nimport { getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { EventTypes, PublicToolProps, ToolProps } from '../types';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store';\nimport { Enums } from '@cornerstonejs/core';\n\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { IPoints } from '../types';\n\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\n\nclass MagnifyTool extends BaseTool {\n  static toolName;\n  _bounds: any;\n  editData: {\n    referencedImageId: string;\n    viewportIdsToRender: string[];\n    enabledElement: Types.IEnabledElement;\n    renderingEngine: Types.IRenderingEngine;\n    currentPoints: IPoints;\n  } | null;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        magnifySize: 10, // parallel scale , higher more zoom\n        magnifyWidth: 250, //px\n        magnifyHeight: 250, //px\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _getReferencedImageId(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): string {\n    const targetId = this.getTargetId(viewport);\n\n    let referencedImageId;\n\n    if (viewport instanceof StackViewport) {\n      referencedImageId = targetId.split('imageId:')[1];\n    }\n\n    return referencedImageId;\n  }\n\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element, currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    if (!(viewport instanceof StackViewport)) {\n      throw new Error('MagnifyTool only works on StackViewports');\n    }\n\n    const referencedImageId = this._getReferencedImageId(viewport);\n\n    if (!referencedImageId) {\n      throw new Error(\n        'MagnifyTool: No referenced image id found, reconstructed planes not supported yet'\n      );\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      referencedImageId,\n      viewportIdsToRender,\n      enabledElement,\n      renderingEngine,\n      currentPoints,\n    };\n\n    this._createMagnificationViewport();\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  preTouchStartCallback = (evt: EventTypes.InteractionEventType) => {\n    this.preMouseDownCallback(evt);\n  };\n\n  _createMagnificationViewport = () => {\n    const {\n      enabledElement,\n      referencedImageId,\n      viewportIdsToRender,\n      renderingEngine,\n      currentPoints,\n    } = this.editData;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n    const viewportProperties = viewport.getProperties();\n\n    const { canvas: canvasPos, world: worldPos } = currentPoints;\n\n    let magnifyToolElement: HTMLDivElement;\n\n    magnifyToolElement = element.querySelector('.magnifyTool');\n    if (magnifyToolElement === null) {\n      const magnifyElement = document.createElement('div');\n\n      magnifyElement.classList.add('magnifyTool');\n\n      magnifyElement.style.display = 'block';\n      magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n      magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n      magnifyElement.style.position = 'absolute';\n\n      magnifyToolElement = magnifyElement;\n\n      const viewportElement = element.querySelector('.viewport-element');\n      viewportElement.appendChild(magnifyElement);\n\n      const viewportInput = {\n        viewportId: MAGNIFY_VIEWPORT_ID,\n        type: Enums.ViewportType.STACK,\n        element: magnifyToolElement as HTMLDivElement,\n      };\n\n      renderingEngine.enableElement(viewportInput);\n    }\n\n    // Todo: use CSS transform instead of setting top and left for better performance\n    magnifyToolElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyToolElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const magnifyViewport = renderingEngine.getViewport(\n      MAGNIFY_VIEWPORT_ID\n    ) as Types.IStackViewport;\n\n    magnifyViewport.setStack([referencedImageId]).then(() => {\n      // match the original viewport voi range\n      magnifyViewport.setProperties(viewportProperties);\n\n      // Use the original viewport for the base for parallelScale\n      const { parallelScale } = viewport.getCamera();\n\n      const { focalPoint, position, viewPlaneNormal } =\n        magnifyViewport.getCamera();\n\n      const distance = Math.sqrt(\n        Math.pow(focalPoint[0] - position[0], 2) +\n          Math.pow(focalPoint[1] - position[1], 2) +\n          Math.pow(focalPoint[2] - position[2], 2)\n      );\n\n      const updatedFocalPoint = <Types.Point3>[\n        worldPos[0],\n        worldPos[1],\n        worldPos[2],\n      ];\n\n      const updatedPosition = <Types.Point3>[\n        updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n        updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n        updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n      ];\n\n      magnifyViewport.setCamera({\n        parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n        focalPoint: updatedFocalPoint,\n        position: updatedPosition,\n      });\n      magnifyViewport.render();\n    });\n\n    magnifyToolElement.style.display = 'block';\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n\n    const { deltaPoints, element, currentPoints } = eventDetail;\n    const deltaPointsWorld = deltaPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n\n    const magnifyElement = element.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    if (!magnifyElement) {\n      return;\n    }\n\n    magnifyElement.style.top = `${\n      canvasPos[1] - this.configuration.magnifyHeight / 2\n    }px`;\n    magnifyElement.style.left = `${\n      canvasPos[0] - this.configuration.magnifyWidth / 2\n    }px`;\n\n    const { focalPoint, position } = magnifyViewport.getCamera();\n\n    const updatedPosition = <Types.Point3>[\n      position[0] + deltaPointsWorld[0],\n      position[1] + deltaPointsWorld[1],\n      position[2] + deltaPointsWorld[2],\n    ];\n\n    const updatedFocalPoint = <Types.Point3>[\n      focalPoint[0] + deltaPointsWorld[0],\n      focalPoint[1] + deltaPointsWorld[1],\n      focalPoint[2] + deltaPointsWorld[2],\n    ];\n\n    magnifyViewport.setCamera({\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n\n    magnifyViewport.render();\n  };\n\n  _dragEndCallback = (evt: EventTypes.InteractionEventType) => {\n    const { element } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n\n    const viewportElement = element.querySelector('.viewport-element');\n\n    const magnifyToolElement = viewportElement.querySelector(\n      '.magnifyTool'\n    ) as HTMLDivElement;\n\n    viewportElement.removeChild(magnifyToolElement);\n\n    this._deactivateDraw(element);\n    resetElementCursor(element);\n  };\n\n  _activateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.addEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n\n    element.addEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.addEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n\n  _deactivateDraw = (element: HTMLDivElement) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(\n      Events.MOUSE_UP,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_DRAG,\n      this._dragCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.MOUSE_CLICK,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_END,\n      this._dragEndCallback as EventListener\n    );\n    element.removeEventListener(\n      Events.TOUCH_DRAG,\n      this._dragCallback as EventListener\n    );\n  };\n}\n\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport {\n  getEnabledElement,\n  eventTarget,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  SegmentationRepresentations,\n  ToolModes,\n  Events as cstEvents,\n} from '../enums';\nimport { ToolGroupManager, state } from '../store';\nimport { debounce } from '../utilities';\nimport { ToolModeChangedEventType } from '../types/EventTypes';\nimport { segmentation } from '..';\nimport { EventTypes, IToolGroup } from '../types';\nimport {\n  AnnotationTool,\n  AdvancedMagnifyTool,\n  SegmentationDisplayTool,\n} from './';\nimport { distanceToPoint } from '../utilities/math/point';\n\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\n\n// TODO: find a better to identify segmentation actors\nconst isSegmentation = (actor) => actor.uid !== actor.referenceId;\n\nexport type AutoPanCallbackData = {\n  points: {\n    currentPosition: {\n      canvas: Types.Point2;\n      world: Types.Point3;\n    };\n    newPosition: {\n      canvas: Types.Point2;\n      world: Types.Point3;\n    };\n  };\n  delta: {\n    canvas: Types.Point2;\n    world: Types.Point3;\n  };\n};\n\nexport type AutoPanCallback = (data: AutoPanCallbackData) => void;\n\nclass AdvancedMagnifyViewport {\n  private _viewportId: string;\n  private _sourceEnabledElement: Types.IEnabledElement;\n  private _enabledElement: Types.IEnabledElement = null;\n  private _sourceToolGroup: IToolGroup = null;\n  private _magnifyToolGroup: IToolGroup = null;\n  private _isViewportReady = false;\n  private _radius = 0;\n  private _resized = false;\n  private _resizeViewportAsync: () => void;\n  private _canAutoPan = false;\n  private _autoPan: {\n    enabled: boolean;\n    padding: number;\n    callback: AutoPanCallback;\n  };\n  public position: Types.Point2;\n  public zoomFactor: number;\n  public visible: boolean;\n\n  constructor({\n    magnifyViewportId,\n    sourceEnabledElement,\n    radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS,\n    position = [0, 0],\n    zoomFactor,\n    autoPan,\n  }: {\n    magnifyViewportId?: string;\n    sourceEnabledElement: Types.IEnabledElement;\n    radius?: number;\n    position?: Types.Point2;\n    zoomFactor: number;\n    autoPan: {\n      enabled: boolean;\n      padding: number;\n      callback: AutoPanCallback;\n    };\n  }) {\n    // Private properties\n    this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n    this._sourceEnabledElement = sourceEnabledElement;\n    this._autoPan = autoPan;\n\n    // Pulic properties\n    this.radius = radius;\n    this.position = position;\n    this.zoomFactor = zoomFactor;\n    this.visible = true;\n\n    this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n    this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n    this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n    this._mouseDragCallback = this._mouseDragCallback.bind(this);\n    this._resizeViewportAsync = <() => void>(\n      debounce(this._resizeViewport.bind(this), 1)\n    );\n\n    this._initialize();\n  }\n\n  public get sourceEnabledElement() {\n    return this._sourceEnabledElement;\n  }\n\n  public get viewportId() {\n    return this._viewportId;\n  }\n\n  public get radius() {\n    return this._radius;\n  }\n\n  public set radius(radius: number) {\n    // Just moving the magnifying glass around may change its radius\n    // by very small amount due to floating number precision\n    if (Math.abs(this._radius - radius) > 0.00001) {\n      this._radius = radius;\n      this._resized = true;\n    }\n  }\n\n  public update() {\n    const { radius, position, visible } = this;\n    const { viewport } = this._enabledElement;\n    const { element } = viewport;\n    const size = 2 * radius;\n    const [x, y] = position;\n\n    if (this._resized) {\n      this._resizeViewportAsync();\n      this._resized = false;\n    }\n\n    Object.assign(element.style, {\n      display: visible ? 'block' : 'hidden',\n      width: `${size}px`,\n      height: `${size}px`,\n      left: `${-radius}px`,\n      top: `${-radius}px`,\n      transform: `translate(${x}px, ${y}px)`,\n    });\n\n    if (this._isViewportReady) {\n      this._syncViewports();\n      viewport.render();\n    }\n  }\n\n  public dispose() {\n    const { viewport } = this._enabledElement;\n    const { element } = viewport;\n    const renderingEngine = viewport.getRenderingEngine();\n\n    this._removeEventListeners(element);\n    renderingEngine.disableElement(viewport.id);\n\n    if (element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  }\n\n  private _handleToolModeChanged(evt: ToolModeChangedEventType) {\n    const { _magnifyToolGroup: magnifyToolGroup } = this;\n    const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n\n    if (this._sourceToolGroup?.id !== toolGroupId) {\n      return;\n    }\n\n    switch (mode) {\n      case ToolModes.Active:\n        magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n        break;\n      case ToolModes.Passive:\n        magnifyToolGroup.setToolPassive(toolName);\n        break;\n      case ToolModes.Enabled:\n        magnifyToolGroup.setToolEnabled(toolName);\n        break;\n      case ToolModes.Disabled:\n        magnifyToolGroup.setToolDisabled(toolName);\n        break;\n      default:\n        throw new Error(`Unknow tool mode (${mode})`);\n    }\n  }\n\n  // Children elements need to inherit border-radius otherwise the canvas will\n  // trigger events when moving/dragging/clicking on the corners outside of the\n  // border (circle) region.\n  private _inheritBorderRadius(magnifyElement) {\n    const viewport = magnifyElement.querySelector('.viewport-element');\n    const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n\n    viewport.style.borderRadius = 'inherit';\n    canvas.style.borderRadius = 'inherit';\n  }\n\n  private _createViewportNode(): HTMLDivElement {\n    const magnifyElement = document.createElement('div');\n    const { radius } = this;\n    const size = radius * 2;\n\n    magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n\n    // Update the style and move the element out of the screen with \"transforms\"\n    // to make it \"invisible\" and preserving its size because when \"display\" is\n    // set to \"none\" both \"offsetWidth\" and \"offsetHeight\" returns zero. Another\n    // way would be setting \"visibility\" to \"hidden\" but \"transforms\" is used\n    // because it is already being updated when update() is called\n    Object.assign(magnifyElement.style, {\n      display: 'block',\n      width: `${size}px`,\n      height: `${size}px`,\n      position: 'absolute',\n      overflow: 'hidden',\n      borderRadius: '50%',\n      boxSizing: 'border-box',\n      left: `${-radius}px`,\n      top: `${-radius}px`,\n      transform: `translate(-1000px, -1000px)`,\n    });\n\n    return magnifyElement;\n  }\n\n  private _convertZoomFactorToParalellScale(\n    viewport,\n    magnifyViewport,\n    zoomFactor\n  ) {\n    const { parallelScale } = viewport.getCamera();\n    const canvasRatio =\n      magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n\n    return parallelScale * (1 / zoomFactor) * canvasRatio;\n  }\n\n  private _isStackViewport(\n    viewport: Types.IViewport\n  ): viewport is Types.IStackViewport {\n    return 'setStack' in viewport;\n  }\n\n  private _isVolumeViewport(\n    viewport: Types.IViewport\n  ): viewport is Types.IVolumeViewport {\n    return 'addVolumes' in viewport;\n  }\n\n  private _cloneToolGroups(\n    sourceViewport: Types.IViewport,\n    magnifyViewport: Types.IViewport\n  ) {\n    const sourceActors = sourceViewport.getActors();\n    const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n    const sourceToolGroup = ToolGroupManager.getToolGroupForViewport(\n      sourceViewport.id,\n      sourceViewport.renderingEngineId\n    );\n\n    const magnifyToolGroup = sourceToolGroup.clone(\n      magnifyToolGroupId,\n      (toolName) => {\n        const toolInstance = sourceToolGroup.getToolInstance(toolName);\n        const isAnnotationTool =\n          toolInstance instanceof AnnotationTool &&\n          !(toolInstance instanceof AdvancedMagnifyTool);\n\n        return (\n          isAnnotationTool || toolName === SegmentationDisplayTool.toolName\n        );\n      }\n    );\n\n    magnifyToolGroup.addViewport(\n      magnifyViewport.id,\n      magnifyViewport.renderingEngineId\n    );\n\n    sourceActors.filter(isSegmentation).forEach((actor) => {\n      segmentation.addSegmentationRepresentations(magnifyToolGroupId, [\n        {\n          segmentationId: actor.referenceId,\n          type: SegmentationRepresentations.Labelmap,\n        },\n      ]);\n    });\n\n    return { sourceToolGroup, magnifyToolGroup };\n  }\n\n  private _cloneStack(\n    sourceViewport: Types.IStackViewport,\n    magnifyViewport: Types.IStackViewport\n  ): void {\n    const imageIds = sourceViewport.getImageIds();\n\n    magnifyViewport.setStack(imageIds).then(() => {\n      this._isViewportReady = true;\n      this.update();\n    });\n  }\n\n  private _cloneVolumes(\n    sourceViewport: Types.IVolumeViewport,\n    magnifyViewport: Types.IVolumeViewport\n  ): Types.IVolumeViewport {\n    const actors = sourceViewport.getActors();\n    const volumeInputArray: Types.IVolumeInput[] = actors\n      .filter((actor) => !isSegmentation(actor))\n      .map((actor) => ({ volumeId: actor.uid }));\n\n    magnifyViewport.setVolumes(volumeInputArray).then(() => {\n      this._isViewportReady = true;\n      this.update();\n    });\n\n    return magnifyViewport;\n  }\n\n  private _cloneViewport(sourceViewport, magnifyElement) {\n    const { viewportId: magnifyViewportId } = this;\n    const renderingEngine =\n      sourceViewport.getRenderingEngine() as Types.IRenderingEngine;\n\n    const { options: sourceViewportOptions } = sourceViewport;\n    const viewportInput = {\n      element: magnifyElement,\n      viewportId: magnifyViewportId,\n      type: sourceViewport.type,\n      defaultOptions: { ...sourceViewportOptions },\n    };\n\n    renderingEngine.enableElement(viewportInput);\n\n    const magnifyViewport = <Types.IViewport>(\n      renderingEngine.getViewport(magnifyViewportId)\n    );\n\n    if (this._isStackViewport(sourceViewport)) {\n      this._cloneStack(sourceViewport, magnifyViewport as Types.IStackViewport);\n    } else if (this._isVolumeViewport(sourceViewport)) {\n      this._cloneVolumes(\n        sourceViewport,\n        magnifyViewport as Types.IVolumeViewport\n      );\n    }\n\n    // Prevent handling events outside of the magnifying glass because it has rounded border\n    this._inheritBorderRadius(magnifyElement);\n\n    const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n\n    this._sourceToolGroup = toolGroups.sourceToolGroup;\n    this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n  }\n\n  private _cancelMouseEventCallback(evt): void {\n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n\n  private _browserMouseUpCallback(evt) {\n    const { element } = this._enabledElement.viewport;\n\n    document.removeEventListener('mouseup', this._browserMouseUpCallback);\n\n    // Restrict the scope of magnifying glass events again\n    element.addEventListener('mouseup', this._cancelMouseEventCallback);\n    element.addEventListener('mousemove', this._cancelMouseEventCallback);\n  }\n\n  private _browserMouseDownCallback(evt) {\n    const { element } = this._enabledElement.viewport;\n\n    // Enable auto pan only when user clicks inside of the magnifying glass\n    // viewport otherwise it can move when interacting with annotations outside\n    // of the magnifying glass or when trying to move/resize it.\n    this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n\n    // Wait for the mouseup event to restrict the scope of magnifying glass events again\n    document.addEventListener('mouseup', this._browserMouseUpCallback);\n\n    // Allow mouseup and mousemove events to make it possible to manipulate the\n    // tool when passing the mouse over the magnifying glass (dragging a handle).\n    // Just relying on state.isInteractingWithTool does not work because there\n    // is a 400ms delay to handle double click (see mouseDownListener) which\n    // makes the magnifying glass unresponsive for that amount of time.\n    element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n    element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n  }\n\n  private _mouseDragCallback(evt: EventTypes.InteractionEventType) {\n    if (!state.isInteractingWithTool) {\n      return;\n    }\n\n    const { _autoPan: autoPan } = this;\n\n    if (!autoPan.enabled || !this._canAutoPan) {\n      return;\n    }\n\n    const { currentPoints } = evt.detail;\n    const { viewport } = this._enabledElement;\n    const { canvasToWorld } = viewport;\n    const { canvas: canvasCurrent } = currentPoints;\n    const { radius: magnifyRadius } = this;\n    const canvasCenter: Types.Point2 = [magnifyRadius, magnifyRadius];\n    const dist = distanceToPoint(canvasCenter, canvasCurrent);\n    const maxDist = magnifyRadius - autoPan.padding;\n\n    // No need to pan if it is not close to the border\n    if (dist <= maxDist) {\n      return;\n    }\n\n    const panDist = dist - maxDist;\n    const canvasDeltaPos = vec2.sub(\n      vec2.create(),\n      canvasCurrent,\n      canvasCenter\n    ) as Types.Point2;\n\n    vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n    vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n\n    const newCanvasPosition = vec2.add(\n      vec2.create(),\n      this.position,\n      canvasDeltaPos\n    ) as Types.Point2;\n    const currentWorldPos = canvasToWorld(this.position);\n    const newWorldPos = canvasToWorld(newCanvasPosition);\n    const worldDeltaPos = vec3.sub(\n      vec3.create(),\n      newWorldPos,\n      currentWorldPos\n    ) as Types.Point3;\n\n    const autoPanCallbackData: AutoPanCallbackData = {\n      points: {\n        currentPosition: {\n          canvas: this.position,\n          world: currentWorldPos,\n        },\n        newPosition: {\n          canvas: newCanvasPosition,\n          world: newWorldPos,\n        },\n      },\n      delta: {\n        canvas: canvasDeltaPos,\n        world: worldDeltaPos,\n      },\n    };\n\n    autoPan.callback(autoPanCallbackData);\n  }\n\n  private _addBrowserEventListeners(element) {\n    // mousedown on document is handled in the capture phase because the other\n    // mousedown event listener added to the magnifying glass element does not\n    // allow the event to buble up and reach the document.\n    document.addEventListener(\n      'mousedown',\n      this._browserMouseDownCallback,\n      true\n    );\n\n    // All mouse events should not buble up avoiding the source viewport from\n    // handling those events resulting in unexpected behaviors.\n    element.addEventListener('mousedown', this._cancelMouseEventCallback);\n    element.addEventListener('mouseup', this._cancelMouseEventCallback);\n    element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    element.addEventListener('dblclick', this._cancelMouseEventCallback);\n  }\n\n  private _removeBrowserEventListeners(element) {\n    document.removeEventListener(\n      'mousedown',\n      this._browserMouseDownCallback,\n      true\n    );\n    document.removeEventListener('mouseup', this._browserMouseUpCallback);\n\n    element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n    element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n    element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n  }\n\n  private _addEventListeners(element) {\n    eventTarget.addEventListener(\n      cstEvents.TOOL_MODE_CHANGED,\n      this._handleToolModeChanged\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n\n    this._addBrowserEventListeners(element);\n  }\n\n  private _removeEventListeners(element) {\n    eventTarget.removeEventListener(\n      cstEvents.TOOL_MODE_CHANGED,\n      this._handleToolModeChanged\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_MOVE,\n      this._mouseDragCallback as EventListener\n    );\n\n    element.addEventListener(\n      cstEvents.MOUSE_DRAG,\n      this._mouseDragCallback as EventListener\n    );\n\n    this._removeBrowserEventListeners(element);\n  }\n\n  private _initialize() {\n    const { _sourceEnabledElement: sourceEnabledElement } = this;\n    const { viewport: sourceViewport } = sourceEnabledElement;\n    const { canvas: sourceCanvas } = sourceViewport;\n    const magnifyElement = this._createViewportNode();\n\n    sourceCanvas.parentNode.appendChild(magnifyElement);\n\n    this._addEventListeners(magnifyElement);\n    this._cloneViewport(sourceViewport, magnifyElement);\n    this._enabledElement = getEnabledElement(magnifyElement);\n  }\n\n  private _syncViewportsCameras(sourceViewport, magnifyViewport) {\n    const worldPos = sourceViewport.canvasToWorld(this.position);\n\n    // Use the original viewport for the base for parallelScale\n    const parallelScale = this._convertZoomFactorToParalellScale(\n      sourceViewport,\n      magnifyViewport,\n      this.zoomFactor\n    );\n\n    const { focalPoint, position, viewPlaneNormal } =\n      magnifyViewport.getCamera();\n\n    const distance = Math.sqrt(\n      Math.pow(focalPoint[0] - position[0], 2) +\n        Math.pow(focalPoint[1] - position[1], 2) +\n        Math.pow(focalPoint[2] - position[2], 2)\n    );\n\n    const updatedFocalPoint = <Types.Point3>[\n      worldPos[0],\n      worldPos[1],\n      worldPos[2],\n    ];\n\n    const updatedPosition = <Types.Point3>[\n      updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n      updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n      updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n    ];\n\n    magnifyViewport.setCamera({\n      parallelScale,\n      focalPoint: updatedFocalPoint,\n      position: updatedPosition,\n    });\n  }\n\n  private _syncStackViewports(\n    sourceViewport: Types.IStackViewport,\n    magnifyViewport: Types.IStackViewport\n  ) {\n    magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n  }\n\n  private _syncViewports() {\n    const { viewport: sourceViewport } = this._sourceEnabledElement;\n    const { viewport: magnifyViewport } = this._enabledElement;\n    const sourceProperties = sourceViewport.getProperties();\n\n    magnifyViewport.setProperties(sourceProperties);\n    this._syncViewportsCameras(sourceViewport, magnifyViewport);\n\n    if (this._isStackViewport(sourceViewport)) {\n      this._syncStackViewports(\n        sourceViewport as Types.IStackViewport,\n        magnifyViewport as Types.IStackViewport\n      );\n    }\n  }\n\n  private _resizeViewport() {\n    const { viewport } = this._enabledElement;\n    const renderingEngine = viewport.getRenderingEngine();\n\n    renderingEngine.resize();\n  }\n}\n\nexport { AdvancedMagnifyViewport as default, AdvancedMagnifyViewport };\n","import { vec3 } from 'gl-matrix';\nimport {\n  eventTarget,\n  Enums,\n  getRenderingEngine,\n  CONSTANTS,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationRemovedEventType } from '../types/EventTypes';\nimport { Events as cstEvents } from '../enums';\nimport {\n  AdvancedMagnifyViewport,\n  AutoPanCallback,\n} from './AdvancedMagnifyViewport';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\n// Defined the tool name internally instead of importing\n// AdvangedMagnifyTool due to cyclic dependency\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\n\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nconst { Events } = Enums;\n\nexport type MagnifyViewportInfo = {\n  // Viewport id to be used or new v4 compliant GUID is used instead\n  magnifyViewportId?: string;\n  // Enabled element where the magnifying glass shall be added to\n  sourceEnabledElement: Types.IEnabledElement;\n  // Magnifying glass position (center)\n  position: Types.Point2;\n  // Magnifying glass radius (pixels)\n  radius: number;\n  // Amount of magnification applied to the magnifying glass image compared to the source viewport.\n  zoomFactor: number;\n  // Allow panning the viewport when moving an annotation point close to the border of the magnifying glass\n  autoPan: {\n    // Enable or disable auto pan\n    enabled: boolean;\n    // Minimum distance to the border before start auto panning\n    padding: number;\n    // Callback function responsible for updating the annotation (circle)\n    // that contains the magnifying viewport\n    callback: AutoPanCallback;\n  };\n};\n\ntype MagnifyViewportsMapEntry = {\n  annotation: AdvancedMagnifyAnnotation;\n  magnifyViewport: AdvancedMagnifyViewport;\n};\n\n/**\n * Manager responsible for creating, storing and destroying magnifying glass\n * viewports. There are no restrictions to create a new instance of it but it\n * should be accessed through getInstance() method.\n */\nclass AdvancedMagnifyViewportManager {\n  private static _singleton: AdvancedMagnifyViewportManager;\n  private _magnifyViewportsMap: Map<string, MagnifyViewportsMapEntry>;\n\n  constructor() {\n    this._magnifyViewportsMap = new Map();\n    this._initialize();\n  }\n\n  /**\n   * Creates a new magnifying glass viewport manager instance when this method is\n   * called for the first time or return the instance previously created for\n   * any subsequent call (singleton pattern).\n   * @returns A magnifying viewport manager instance\n   */\n  public static getInstance(): AdvancedMagnifyViewportManager {\n    AdvancedMagnifyViewportManager._singleton =\n      AdvancedMagnifyViewportManager._singleton ??\n      new AdvancedMagnifyViewportManager();\n\n    return AdvancedMagnifyViewportManager._singleton;\n  }\n\n  /**\n   * Creates a new magnifying glass viewport instance\n   * @param viewportInfo - Viewport data used when creating a new magnifying glass viewport\n   * @returns A magnifying glass viewport instance\n   */\n  public createViewport = (\n    annotation: AdvancedMagnifyAnnotation,\n    viewportInfo: MagnifyViewportInfo\n  ): AdvancedMagnifyViewport => {\n    const {\n      magnifyViewportId,\n      sourceEnabledElement,\n      position,\n      radius,\n      zoomFactor,\n      autoPan,\n    } = viewportInfo;\n    const { viewport: sourceViewport } = sourceEnabledElement;\n    const { element: sourceElement } = sourceViewport;\n\n    const magnifyViewport = new AdvancedMagnifyViewport({\n      magnifyViewportId,\n      sourceEnabledElement,\n      radius,\n      position,\n      zoomFactor,\n      autoPan,\n    });\n\n    this._addSourceElementEventListener(sourceElement);\n    this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n      annotation,\n      magnifyViewport,\n    });\n\n    return magnifyViewport;\n  };\n\n  /**\n   * Find and return a magnifying glass viewport based on its id\n   * @param magnifyViewportId - Magnifying glass viewport id\n   * @returns A magnifying glass viewport instance\n   */\n  public getViewport(magnifyViewportId: string): AdvancedMagnifyViewport {\n    return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n  }\n\n  /**\n   * Release all magnifying glass viewport instances and remove all event\n   * listeners making all objects available to be garbage collected.\n   */\n  public dispose() {\n    this._removeEventListeners();\n    this._destroyViewports();\n  }\n\n  private _destroyViewport(magnifyViewportId: string) {\n    const magnifyViewportMapEntry =\n      this._magnifyViewportsMap.get(magnifyViewportId);\n\n    if (magnifyViewportMapEntry) {\n      const { magnifyViewport } = magnifyViewportMapEntry;\n      const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n      const { element: sourceElement } = sourceViewport;\n\n      this._removeSourceElementEventListener(sourceElement);\n\n      magnifyViewport.dispose();\n      this._magnifyViewportsMap.delete(magnifyViewportId);\n    }\n  }\n\n  private _destroyViewports() {\n    const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n\n    magnifyViewportIds.forEach((magnifyViewportId) =>\n      this._destroyViewport(magnifyViewportId)\n    );\n  }\n\n  private _annotationRemovedCallback = (evt: AnnotationRemovedEventType) => {\n    const { annotation } = evt.detail;\n\n    if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n      return;\n    }\n\n    this._destroyViewport(annotation.data.magnifyViewportId);\n  };\n\n  private _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n    const magnifyViewportsMapEntries = Array.from(\n      this._magnifyViewportsMap.values()\n    );\n\n    return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n      const { viewport } = magnifyViewport.sourceEnabledElement;\n      return viewport.id === sourceViewportId;\n    });\n  }\n\n  private _newStackImageCallback = (\n    evt: Types.EventTypes.StackNewImageEvent\n  ) => {\n    const { viewportId: sourceViewportId, imageId } = evt.detail;\n    const magnifyViewportsMapEntries =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    magnifyViewportsMapEntries.forEach(({ annotation }) => {\n      annotation.metadata.referencedImageId = imageId;\n      annotation.invalidated = true;\n    });\n  };\n\n  private _newVolumeImageCallback = (\n    evt: Types.EventTypes.VolumeNewImageEvent\n  ) => {\n    const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n    const renderingEngine = getRenderingEngine(renderingEngineId);\n    const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n    const { viewPlaneNormal: currentViewPlaneNormal } =\n      sourceViewport.getCamera();\n\n    const magnifyViewportsMapEntries =\n      this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n\n    magnifyViewportsMapEntries.forEach(({ annotation }) => {\n      const { viewPlaneNormal } = annotation.metadata;\n\n      // Compare the normal to make sure the volume is not rotate in 3D space\n      const isParallel =\n        Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n        PARALLEL_THRESHOLD;\n\n      if (!isParallel) {\n        return;\n      }\n\n      const { handles } = annotation.data;\n      const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n      const vecHandleToImagePlane = vec3.sub(\n        vec3.create(),\n        worldImagePlanePoint,\n        handles.points[0]\n      );\n      const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n      const worldDelta = vec3.scale(\n        vec3.create(),\n        currentViewPlaneNormal,\n        worldDist\n      );\n\n      // Move all handle points to the image plane to make the annotation visible\n      for (let i = 0, len = handles.points.length; i < len; i++) {\n        const point = handles.points[i];\n\n        point[0] += worldDelta[0];\n        point[1] += worldDelta[1];\n        point[2] += worldDelta[2];\n      }\n\n      annotation.invalidated = true;\n    });\n  };\n\n  private _addEventListeners() {\n    eventTarget.addEventListener(\n      cstEvents.ANNOTATION_REMOVED,\n      this._annotationRemovedCallback\n    );\n  }\n\n  private _removeEventListeners() {\n    eventTarget.removeEventListener(\n      cstEvents.ANNOTATION_REMOVED,\n      this._annotationRemovedCallback\n    );\n  }\n\n  private _addSourceElementEventListener(element) {\n    element.addEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._newStackImageCallback\n    );\n\n    element.addEventListener(\n      Events.VOLUME_NEW_IMAGE,\n      this._newVolumeImageCallback\n    );\n  }\n\n  private _removeSourceElementEventListener(element) {\n    element.removeEventListener(\n      Events.STACK_NEW_IMAGE,\n      this._newStackImageCallback\n    );\n\n    element.removeEventListener(\n      Events.VOLUME_NEW_IMAGE,\n      this._newVolumeImageCallback\n    );\n  }\n\n  private _initialize() {\n    this._addEventListeners();\n  }\n}\n\nexport {\n  AdvancedMagnifyViewportManager as default,\n  AdvancedMagnifyViewportManager,\n};\n","import { AnnotationTool } from './base';\n\nimport {\n  getEnabledElement,\n  eventTarget,\n  triggerEvent,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport {\n  drawCircle as drawCircleSvg,\n  drawHandles as drawHandlesSvg,\n} from '../drawingSvg';\nimport { state } from '../store';\nimport { Events, MouseBindings, KeyboardBindings } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../cursors/elementCursor';\nimport {\n  EventTypes,\n  ToolHandle,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { AdvancedMagnifyAnnotation } from '../types/ToolSpecificAnnotationTypes';\n\nimport { AnnotationCompletedEventDetail } from '../types/EventTypes';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport AdvancedMagnifyViewportManager from './AdvancedMagnifyViewportManager';\nimport type { AutoPanCallbackData } from './AdvancedMagnifyViewport';\n\nclass AdvancedMagnifyTool extends AnnotationTool {\n  static toolName;\n\n  magnifyViewportManager: AdvancedMagnifyViewportManager;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  editData: {\n    annotation: any;\n    viewportIdsToRender: Array<string>;\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        magnifyingGlass: {\n          radius: 125, // px\n          zoomFactor: 2.5,\n          zoomFactorList: [2.5, 3, 3.5, 4, 4.5, 5],\n          autoPan: {\n            enabled: true,\n            padding: 10, // px\n          },\n        },\n        actions: [\n          {\n            method: 'showZoomFactorsList',\n            bindings: [\n              {\n                mouseButton: MouseBindings.Secondary,\n                modifierKey: KeyboardBindings.Shift,\n              },\n            ],\n          },\n        ],\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n  }\n\n  /**\n   * Based on the current position of the mouse and the current imageId to create\n   * a CircleROI Annotation and stores it in the annotationManager\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): AdvancedMagnifyAnnotation => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const { magnifyingGlass: config } = this.configuration;\n    const { radius, zoomFactor, autoPan } = config;\n\n    const worldHandlesPoints = this._getWorldHandlesPoints(\n      viewport,\n      canvasPos,\n      radius\n    );\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const annotationUID = csUtils.uuidv4();\n    const magnifyViewportId = csUtils.uuidv4();\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation: AdvancedMagnifyAnnotation = {\n      annotationUID,\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        sourceViewportId: viewport.id,\n        magnifyViewportId,\n        zoomFactor,\n        handles: {\n          points: worldHandlesPoints,\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    this.magnifyViewportManager.createViewport(annotation, {\n      magnifyViewportId,\n      sourceEnabledElement: enabledElement,\n      position: canvasPos,\n      radius,\n      zoomFactor,\n      autoPan: {\n        enabled: autoPan.enabled,\n        padding: autoPan.padding,\n        callback: (data: AutoPanCallbackData) => {\n          const annotationPoints = annotation.data.handles.points;\n          const { world: worldDelta } = data.delta;\n\n          for (let i = 0, len = annotationPoints.length; i < len; i++) {\n            annotationPoints[i][0] += worldDelta[0];\n            annotationPoints[i][1] += worldDelta[1];\n            annotationPoints[i][2] += worldDelta[2];\n          }\n        },\n      },\n    });\n\n    addAnnotation(annotation, element);\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    evt.preventDefault();\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return annotation;\n  };\n\n  /**\n   * It returns if the canvas point is near the provided annotation in the provided\n   * element or not. A proximity is passed to the function to determine the\n   * proximity of the point to the annotation in number of pixels.\n   *\n   * @param element - HTML Element\n   * @param annotation - Annotation\n   * @param canvasCoords - Canvas coordinates\n   * @param proximity - Proximity to tool to consider\n   * @returns Boolean, whether the canvas point is near tool\n   */\n  public isPointNearTool = (\n    element: HTMLDivElement,\n    annotation: AdvancedMagnifyAnnotation,\n    canvasCoords: Types.Point2,\n    proximity: number\n  ): boolean => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    // For some reason Typescript doesn't understand this, so we need to be\n    // more specific about the type\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p)) as [\n      Types.Point2,\n      Types.Point2,\n      Types.Point2,\n      Types.Point2\n    ];\n\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const center = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ] as Types.Point2;\n    const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n\n    if (Math.abs(radiusPoint - radius) < proximity * 1.5) {\n      return true;\n    }\n\n    return false;\n  };\n\n  toolSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    annotation.highlighted = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n    };\n\n    hideElementCursor(element);\n\n    this._activateModify(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation,\n    handle: ToolHandle\n  ): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { data } = annotation;\n\n    annotation.highlighted = true;\n\n    const { points } = data.handles;\n    const handleIndex = points.findIndex((p) => p === handle);\n\n    // Find viewports to render on drag.\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      viewportIdsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    evt.preventDefault();\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n  };\n\n  _dragDrawCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element, deltaPoints } = eventDetail;\n    const worldPosDelta = deltaPoints?.world ?? [0, 0, 0];\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    const { annotation, viewportIdsToRender } = this.editData;\n    const { points } = annotation.data.handles;\n\n    points.forEach((point) => {\n      point[0] += worldPosDelta[0];\n      point[1] += worldPosDelta[1];\n      point[2] += worldPosDelta[2];\n    });\n\n    annotation.invalidated = true;\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragModifyCallback = (evt: EventTypes.InteractionEventType): void => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool\n      const { deltaPoints } = eventDetail;\n      const worldPosDelta = deltaPoints.world;\n\n      const points = data.handles.points;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      annotation.invalidated = true;\n    } else {\n      this._dragHandle(evt);\n      annotation.invalidated = true;\n    }\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _dragHandle = (evt: EventTypes.InteractionEventType): void => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { worldToCanvas } = viewport;\n\n    const { annotation } = this.editData;\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasCoordinates = points.map((p) => worldToCanvas(p));\n    const canvasTop = canvasCoordinates[0];\n    const canvasBottom = canvasCoordinates[2];\n    const canvasLeft = canvasCoordinates[3];\n    const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n    const canvasCenter: Types.Point2 = [\n      canvasLeft[0] + radius,\n      canvasTop[1] + radius,\n    ];\n\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n\n    const newRadius = getCanvasCircleRadius([\n      canvasCenter,\n      currentCanvasPoints,\n    ]);\n    const newWorldHandlesPoints = this._getWorldHandlesPoints(\n      viewport,\n      canvasCenter,\n      newRadius\n    );\n\n    points[0] = newWorldHandlesPoints[0];\n    points[1] = newWorldHandlesPoints[1];\n    points[2] = newWorldHandlesPoints[2];\n    points[3] = newWorldHandlesPoints[3];\n  };\n\n  cancel = (element: HTMLDivElement) => {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n\n    this.isDrawing = false;\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n    const { data } = annotation;\n\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    if (newAnnotation) {\n      const eventType = Events.ANNOTATION_COMPLETED;\n\n      const eventDetail: AnnotationCompletedEventDetail = {\n        annotation,\n      };\n\n      triggerEvent(eventTarget, eventType, eventDetail);\n    }\n\n    this.editData = null;\n    return annotation.annotationUID;\n  };\n\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleROI annotation in each\n   * request animation frame. It calculates the updated cached statistics if\n   * data is invalidated and cache it.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    annotations = annotations?.filter(\n      (annotation) =>\n        (<AdvancedMagnifyAnnotation>annotation).data.sourceViewportId ===\n        viewport.id\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as AdvancedMagnifyAnnotation;\n      const { annotationUID, data } = annotation;\n      const { magnifyViewportId, zoomFactor, handles } = data;\n      const { points, activeHandleIndex } = handles;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as Types.Point2[];\n      const canvasTop = canvasCoordinates[0];\n      const canvasBottom = canvasCoordinates[2];\n      const canvasLeft = canvasCoordinates[3];\n      const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n      const center = [\n        canvasLeft[0] + radius,\n        canvasTop[1] + radius,\n      ] as Types.Point2;\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      if (\n        !isAnnotationLocked(annotation) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const dataId = `${annotationUID}-advancedMagnify`;\n      const circleUID = '0';\n      drawCircleSvg(\n        svgDrawingHelper,\n        annotationUID,\n        circleUID,\n        center,\n        radius,\n        {\n          color,\n          lineDash,\n          lineWidth,\n        },\n        dataId\n      );\n\n      const magnifyViewport =\n        this.magnifyViewportManager.getViewport(magnifyViewportId);\n\n      magnifyViewport.position = center;\n      magnifyViewport.radius = radius;\n      magnifyViewport.zoomFactor = zoomFactor;\n      magnifyViewport.update();\n\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  // Basic dropdown component that allows the user to select a different zoom factor.\n  // configurations.actions may be changed to use a customized dropdown.\n  public showZoomFactorsList(\n    evt: EventTypes.InteractionEventType,\n    annotation: AdvancedMagnifyAnnotation\n  ) {\n    const { element, currentPoints } = evt.detail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { canvas: canvasPoint } = currentPoints;\n    const viewportElement = element.querySelector(':scope .viewport-element');\n    const currentZoomFactor = annotation.data.zoomFactor;\n    const remove = () => dropdown.parentElement.removeChild(dropdown);\n\n    const dropdown = this._getZoomFactorsListDropdown(\n      currentZoomFactor,\n      (newZoomFactor) => {\n        if (newZoomFactor !== undefined) {\n          annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n          annotation.invalidated = true;\n        }\n\n        remove();\n        viewport.render();\n      }\n    );\n\n    Object.assign(dropdown.style, {\n      left: `${canvasPoint[0]}px`,\n      top: `${canvasPoint[1]}px`,\n    });\n\n    viewportElement.appendChild(dropdown);\n    dropdown.focus();\n  }\n\n  private _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n    const { zoomFactorList } = this.configuration.magnifyingGlass;\n    const dropdown = document.createElement('select');\n\n    dropdown.size = 5;\n    Object.assign(dropdown.style, {\n      width: '50px',\n      position: 'absolute',\n    });\n\n    ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n      dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n    });\n\n    dropdown.addEventListener('change', (evt) => {\n      evt.stopPropagation();\n      onChangeCallback(dropdown.value);\n    });\n\n    dropdown.addEventListener('keydown', (evt) => {\n      const shouldCancel =\n        (evt.keyCode ?? evt.which === 27) ||\n        evt.key?.toLowerCase() === 'escape';\n\n      if (shouldCancel) {\n        evt.stopPropagation();\n        onChangeCallback();\n      }\n    });\n\n    zoomFactorList.forEach((zoomFactor) => {\n      const option = document.createElement('option');\n\n      option.label = zoomFactor;\n      option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n      option.value = zoomFactor;\n      option.defaultSelected = zoomFactor === currentZoomFactor;\n\n      dropdown.add(option);\n    });\n\n    return dropdown;\n  }\n\n  private _getWorldHandlesPoints = (\n    viewport,\n    canvasCenterPos,\n    canvasRadius\n  ): Types.Point3[] => {\n    const canvasHandlesPoints = [\n      [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius], // top\n      [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1]], // right\n      [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius], // bottom\n      [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1]], // left\n    ];\n\n    const worldHandlesPoints = canvasHandlesPoints.map((p) =>\n      viewport.canvasToWorld(p)\n    ) as Types.Point3[];\n\n    return worldHandlesPoints;\n  };\n}\n\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\n\nexport { AdvancedMagnifyTool as default };\n","import {\n  getEnabledElement,\n  StackViewport,\n  VolumeViewport,\n  utilities,\n  getEnabledElementByIds,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n  Annotation,\n  Annotations,\n} from '../types';\nimport { ReferenceCursor } from '../types/ToolSpecificAnnotationTypes';\n\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport {\n  hideElementCursor,\n  resetElementCursor,\n} from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\n/**\n * ReferenceCursors is a tool that will show your cursors position in all other elements in the toolGroup if they have a matching FrameOfReference relative to its position in world space.\n * Also when positionSync is enabled, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n *\n * Configuration:\n * - positionSync: boolean, if true, it will try to sync viewports so that the cursor can be displayed in the correct position in all viewports.\n * - disableCursor: boolean, if true, it will hide the cursor in all viewports. You need to disable and reactivate the tool for this to apply.\n * - displayThreshold: number, if the distance of the cursor in a viewport is bigger than this threshold the cursor will not be displayed.\n *\n * Only uses Active and Disabled state\n */\nclass ReferenceCursors extends AnnotationDisplayTool {\n  static toolName;\n  touchDragCallback: any;\n  mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  isDrawing = false;\n  isHandleOutsideImage = false;\n  _elementWithCursor: null | HTMLDivElement = null;\n  _currentCursorWorldPosition: null | Types.Point3 = null;\n  _currentCanvasPosition: null | Types.Point2 = null;\n  //need to keep track if this was enabled when tool was enabled because we need to know if we should reset cursors\n  _disableCursorEnabled = false;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        shadow: true,\n        preventHandleOutsideImage: false,\n        displayThreshold: 5,\n        positionSync: true,\n        disableCursor: false,\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this._disableCursorEnabled = this.configuration.disableCursor;\n  }\n\n  /**\n   * Overwritten mouseMoveCallback since we want to keep track of the current mouse position and redraw on mouseMove\n   * @virtual Event handler for Cornerstone MOUSE_MOVE event.\n   *\n   *\n   * @param evt - The normalized mouse event\n   * @param filteredAnnotations - The annotations to check for hover interactions\n   * @returns True if the annotation needs to be re-drawn by the annotationRenderingEngine.\n   */\n  mouseMoveCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const { detail } = evt;\n    const { element, currentPoints } = detail;\n\n    //save current positions and current element the curser is hovering over\n    this._currentCursorWorldPosition = currentPoints.world;\n    this._currentCanvasPosition = currentPoints.canvas;\n    this._elementWithCursor = element;\n\n    const annotation = this.getActiveAnnotation(element);\n    if (annotation === null) {\n      this.createInitialAnnotation(currentPoints.world, element);\n      return false;\n    }\n    this.updateAnnotationPosition(element, annotation);\n    return false;\n  };\n\n  onSetToolActive(): void {\n    this._disableCursorEnabled = this.configuration.disableCursor;\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    enabledElements.forEach((element) => {\n      if (element) {\n        hideElementCursor(element.viewport.element);\n      }\n    });\n  }\n  onSetToolDisabled(): void {\n    if (!this._disableCursorEnabled) {\n      return;\n    }\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n    if (!viewportIds) {\n      return;\n    }\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n    enabledElements.forEach((element) => {\n      if (element) {\n        resetElementCursor(element.viewport.element);\n      }\n    });\n  }\n\n  createInitialAnnotation = (\n    worldPos: Types.Point3,\n    element: HTMLDivElement\n  ): void => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      throw new Error('No enabled element found');\n    }\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    if (!viewPlaneNormal || !viewUp) {\n      throw new Error('Camera not found');\n    }\n\n    const referencedImageId = this.getReferencedImageId(\n      viewport,\n      worldPos,\n      viewPlaneNormal,\n      viewUp\n    );\n\n    const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        toolName: this.getToolName(),\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID,\n        referencedImageId,\n      },\n      data: {\n        label: '',\n        handles: {\n          points: [[...worldPos]] as [Types.Point3],\n          activeHandleIndex: null,\n          textBox: {\n            hasMoved: false,\n            worldPosition: <Types.Point3>[0, 0, 0],\n            worldBoundingBox: {\n              topLeft: <Types.Point3>[0, 0, 0],\n              topRight: <Types.Point3>[0, 0, 0],\n              bottomLeft: <Types.Point3>[0, 0, 0],\n              bottomRight: <Types.Point3>[0, 0, 0],\n            },\n          },\n        },\n      },\n    };\n\n    const annotations = getAnnotations(this.getToolName(), element);\n\n    if (annotations.length > 0) {\n      return null;\n    }\n    const annotationId = addAnnotation(annotation, element);\n\n    if (annotationId === null) {\n      return;\n    }\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  getActiveAnnotation(element: HTMLDivElement): null | Annotation {\n    const annotations = getAnnotations(this.getToolName(), element);\n    if (!annotations.length) {\n      return null;\n    }\n    const targetAnnotation = annotations[0];\n    return targetAnnotation;\n  }\n\n  /**\n   * updates the position of the annotation to match the currently set world position\n   */\n  updateAnnotationPosition(\n    element: HTMLDivElement,\n    annotation: Annotation\n  ): void {\n    const worldPos = this._currentCursorWorldPosition;\n    if (!worldPos) {\n      return;\n    }\n    if (!annotation.data?.handles?.points) {\n      return;\n    }\n    annotation.data.handles.points = [[...worldPos]];\n    annotation.invalidated = true;\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n      return;\n    }\n    const { renderingEngine } = enabledElement;\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  }\n\n  //checks if we need to update the annotation position due to camera changes\n  onCameraModified = (evt: any): void => {\n    const eventDetail = evt.detail;\n    const { element, previousCamera, camera } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const viewport = enabledElement.viewport as\n      | Types.IVolumeViewport\n      | Types.IStackViewport;\n\n    //only react to changes for element with cursor, otherwise would cause infinite loop\n    if (element !== this._elementWithCursor) {\n      return;\n    }\n    //check if camera moved along its normal\n    const oldFocalPoint = previousCamera.focalPoint;\n    const cameraNormal = camera.viewPlaneNormal;\n    const newFocalPoint = camera.focalPoint;\n\n    const deltaCameraFocalPoint: Types.Point3 = [0, 0, 0];\n    vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n    //check if focal point changed\n    if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n      return;\n    }\n    //if nomrmal is perpendicular to focal point change, then we are not moving along the normal\n    const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n    //dot product is 0 -> perpendicular\n    if (Math.abs(dotProduct) < 1e-2) {\n      return;\n    }\n\n    //need to update the position of the annotation since camera changed\n    if (!this._currentCanvasPosition) {\n      return;\n    }\n\n    const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n    this._currentCursorWorldPosition = newWorldPos;\n    this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n  };\n\n  //display annotation if current viewing plane has a max distance of \"displayThreshold\" from the annotation\n  filterInteractableAnnotationsForElement(\n    element: HTMLDivElement,\n    annotations: Annotations\n  ): Annotations {\n    //calculate distance of current viewport to annotation\n    if (!(annotations instanceof Array) || annotations.length === 0) {\n      return [];\n    }\n    const annotation = annotations[0];\n    const viewport = getEnabledElement(element)?.viewport;\n    if (!viewport) {\n      return [];\n    }\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, focalPoint } = camera;\n    if (!viewPlaneNormal || !focalPoint) {\n      return [];\n    }\n    const points = annotation.data?.handles?.points;\n    if (!(points instanceof Array) || points.length !== 1) {\n      return [];\n    }\n    const worldPos = points[0];\n    const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n    const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n    return distance < this.configuration.displayThreshold ? [annotation] : [];\n  }\n\n  /**\n   * Draws the cursor representation on the enabledElement\n   * Checks if a stack change has happened and updates annotation in that case\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    const { viewport, FrameOfReferenceUID } = enabledElement;\n\n    const isElementWithCursor = this._elementWithCursor === viewport.element;\n\n    //update stack position if position sync is enabled\n    if (this.configuration.positionSync && !isElementWithCursor) {\n      this.updateViewportImage(viewport);\n    }\n\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    //the viewport change from updateStackPosition might not be applied yet, so sometimes the annotation might not be immediately visible\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    ) as Annotations;\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i] as ReferenceCursor;\n      const { annotationUID, data } = annotation;\n      const { handles } = data;\n      const { points } = handles;\n\n      if (!annotationUID) {\n        return renderStatus;\n      }\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidthBase = parseFloat(\n        this.getStyle('lineWidth', styleSpecifier, annotation) as string\n      );\n\n      const lineWidth =\n        typeof lineWidthBase === 'number' && isElementWithCursor\n          ? lineWidthBase\n          : lineWidthBase;\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n\n      if (points[0].some((e) => isNaN(e))) {\n        return renderStatus;\n      }\n      const canvasCoordinates = points.map((p) =>\n        viewport.worldToCanvas(p)\n      ) as [Types.Point2];\n\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return renderStatus;\n      }\n\n      if (!isAnnotationVisible(annotationUID)) {\n        continue;\n      }\n\n      const crosshairUIDs = {\n        upper: 'upper',\n        right: 'right',\n        lower: 'lower',\n        left: 'left',\n      };\n      const [x, y] = canvasCoordinates[0];\n      const centerSpace = isElementWithCursor ? 20 : 7;\n      const lineLength = isElementWithCursor ? 5 : 7;\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.upper,\n        [x, y - (centerSpace / 2 + lineLength)],\n        [x, y - centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.lower,\n        [x, y + (centerSpace / 2 + lineLength)],\n        [x, y + centerSpace / 2],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.right,\n        [x + (centerSpace / 2 + lineLength), y],\n        [x + centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      drawLine(\n        svgDrawingHelper,\n        annotationUID,\n        crosshairUIDs.left,\n        [x - (centerSpace / 2 + lineLength), y],\n        [x - centerSpace / 2, y],\n        { color, lineDash, lineWidth }\n      );\n      renderStatus = true;\n    }\n\n    return renderStatus;\n  };\n\n  updateViewportImage(\n    viewport: Types.IStackViewport | Types.IVolumeViewport\n  ): void {\n    const currentMousePosition = this._currentCursorWorldPosition;\n\n    if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n      return;\n    }\n\n    if (viewport instanceof StackViewport) {\n      const closestIndex = utilities.getClosestStackImageIndexForPoint(\n        currentMousePosition,\n        viewport\n      );\n\n      if (closestIndex === null) {\n        return;\n      }\n      if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n        viewport.setImageIdIndex(closestIndex);\n      }\n    } else if (viewport instanceof VolumeViewport) {\n      const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n      if (!focalPoint || !viewPlaneNormal) {\n        return;\n      }\n      const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n      const currentDistance = utilities.planar.planeDistanceToPoint(\n        plane,\n        currentMousePosition,\n        true\n      );\n\n      if (Math.abs(currentDistance) < 0.5) {\n        return;\n      }\n      const normalizedViewPlane = vec3.normalize(\n        vec3.create(),\n        vec3.fromValues(...viewPlaneNormal)\n      );\n      const scaledPlaneNormal = vec3.scale(\n        vec3.create(),\n        normalizedViewPlane,\n        currentDistance\n      );\n      const newFocalPoint = vec3.add(\n        vec3.create(),\n        vec3.fromValues(...focalPoint),\n        scaledPlaneNormal\n      ) as Types.Point3;\n      //TODO: make check if new focal point is within bounds of volume\n      const isInBounds = true;\n      if (isInBounds) {\n        viewport.setCamera({ focalPoint: newFocalPoint });\n        const renderingEngine = viewport.getRenderingEngine();\n        if (renderingEngine) {\n          renderingEngine.renderViewport(viewport.id);\n        }\n      }\n    }\n  }\n}\n\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport {\n  getEnabledElementByIds,\n  getRenderingEngines,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport { ScaleOverlayAnnotation } from '../types/ToolSpecificAnnotationTypes';\nimport type { Types } from '@cornerstonejs/core';\nimport {\n  addAnnotation,\n  getAnnotations,\n} from '../stateManagement/annotation/annotationState';\nimport {\n  drawLine as drawLineSvg,\n  drawTextBox as drawTextBoxSvg,\n} from '../drawingSvg';\nimport {\n  EventTypes,\n  PublicToolProps,\n  ToolProps,\n  SVGDrawingHelper,\n} from '../types';\nimport { StyleSpecifier } from '../types/AnnotationStyle';\nimport { getToolGroup } from '../store/ToolGroupManager';\n\nconst SCALEOVERLAYTOOL_ID = 'scaleoverlay-viewport';\nconst viewportsWithAnnotations = [];\n\n/**\n * @public\n * @class ScaleOverlayTool\n * @memberof Tools\n *\n * @classdesc Tool for displaying a scale overlay on the image.\n * @extends Tools.Base.BaseTool\n */\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n  static toolName;\n\n  public touchDragCallback: any;\n  public mouseDragCallback: any;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    renderingEngine: any;\n    viewport: any;\n    annotation: ScaleOverlayAnnotation;\n  } | null = {} as any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      configuration: {\n        viewportId: '',\n        scaleLocation: 'bottom',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _init = (): void => {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    // get viewports with tool enabled\n    const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n\n    if (!viewportIds) {\n      return;\n    }\n\n    // get enabled elements\n    const enabledElements = viewportIds.map((e) =>\n      getEnabledElementByIds(e.viewportId, e.renderingEngineId)\n    );\n\n    let { viewport } = enabledElements[0];\n    const { FrameOfReferenceUID } = enabledElements[0];\n\n    // onCameraModified, configuration.viewportId is set to the active\n    // viewport Id, here we are setting the viewport variable to the\n    // viewport with the matching Id\n    if (this.configuration.viewportId) {\n      enabledElements.forEach((element) => {\n        if (element.viewport.id == this.configuration.viewportId) {\n          viewport = element.viewport;\n        }\n      });\n    }\n\n    if (!viewport) {\n      return;\n    }\n\n    const { viewUp, viewPlaneNormal } = viewport.getCamera();\n\n    const viewportCanvasCornersInWorld =\n      csUtils.getViewportImageCornersInWorld(viewport);\n\n    let annotation = this.editData.annotation;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n\n    // if annotations have been created, get the annotation for the\n    // current viewport Id\n    if (annotations.length) {\n      annotation = annotations.filter(\n        (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n      )[0] as ScaleOverlayAnnotation;\n    }\n\n    // viewportsWithAnnotations stores which viewports have an annotation,\n    // if the viewport does not have an annotation, create a new one\n    if (!viewportsWithAnnotations.includes(viewport.id)) {\n      const newAnnotation: ScaleOverlayAnnotation = {\n        metadata: {\n          toolName: this.getToolName(),\n          viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n          viewUp: <Types.Point3>[...viewUp],\n          FrameOfReferenceUID,\n          referencedImageId: null,\n        },\n        data: {\n          handles: {\n            points: viewportCanvasCornersInWorld,\n          },\n          viewportId: viewport.id,\n        },\n      };\n\n      viewportsWithAnnotations.push(viewport.id);\n\n      addAnnotation(newAnnotation, viewport.element);\n      annotation = newAnnotation;\n    } else if (this.editData.annotation.data.viewportId == viewport.id) {\n      this.editData.annotation.data.handles.points =\n        viewportCanvasCornersInWorld;\n      this.editData.annotation.data.viewportId = viewport.id;\n    }\n\n    this.editData = {\n      viewport,\n      renderingEngine,\n      annotation,\n    };\n  };\n\n  onSetToolEnabled = (): void => {\n    this._init();\n  };\n\n  onCameraModified = (evt: Types.EventTypes.CameraModifiedEvent): void => {\n    // If the camera is modified, we need to update the viewport\n    // that the camera was modified on\n    this.configuration.viewportId = evt.detail.viewportId;\n    this._init();\n  };\n\n  /**\n   * Used to draw the scale annotation in each request animation\n   * frame.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   * @returns\n   */\n\n  renderAnnotation(\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ) {\n    if (!this.editData.viewport) {\n      return;\n    }\n    const location = this.configuration.scaleLocation;\n    const { viewport } = enabledElement;\n\n    const annotations = getAnnotations(this.getToolName(), viewport.element);\n    const annotation = annotations.filter(\n      (thisAnnotation) => thisAnnotation.data.viewportId == viewport.id\n    )[0];\n    const canvas = enabledElement.viewport.canvas;\n\n    const renderStatus = false;\n\n    if (!viewport) {\n      return renderStatus;\n    }\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    const canvasSize = {\n      width: canvas.width,\n      height: canvas.height,\n    };\n\n    const topLeft = annotation.data.handles.points[0];\n    const topRight = annotation.data.handles.points[1];\n    const bottomLeft = annotation.data.handles.points[2];\n    const bottomRight = annotation.data.handles.points[3];\n\n    const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n\n    const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n    const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n\n    // hscaleBounds and vscaleBounds compute the max bound for scales on the image\n    const hscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    const vscaleBounds = this.computeScaleBounds(\n      canvasSize,\n      0.05,\n      0.05,\n      location\n    );\n\n    // Computes which scale size to use, ex: 100mm, 50mm\n    const scaleSize = this.computeScaleSize(\n      worldWidthViewport,\n      worldHeightViewport,\n      location\n    );\n\n    // Applies the scale with the predetermined size to the image in\n    // world coordinates, then converts them to canvas coordinates\n    const canvasCoordinates = this.computeWorldScaleCoordinates(\n      scaleSize,\n      location,\n      pointSet1\n    ).map((world) => viewport.worldToCanvas(world));\n\n    // Uses the bounds and canvas size to center the scale\n    // based on the location\n    const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(\n      canvasSize,\n      canvasCoordinates,\n      vscaleBounds,\n      hscaleBounds,\n      location\n    );\n\n    // Computes the end scale ticks coordinates\n    const scaleTicks = this.computeEndScaleTicks(\n      scaleCanvasCoordinates,\n      location\n    );\n\n    const { annotationUID } = annotation;\n\n    styleSpecifier.annotationUID = annotationUID;\n    const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n    const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n    const color = this.getStyle('color', styleSpecifier, annotation);\n    const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n\n    const scaleId = `${annotationUID}-scaleline`;\n    const scaleLineUID = '1';\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      scaleLineUID,\n      scaleCanvasCoordinates[0],\n      scaleCanvasCoordinates[1],\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      scaleId\n    );\n    const leftTickId = `${annotationUID}-left`;\n    const leftTickUID = '2';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      leftTickUID,\n      scaleTicks.endTick1[0] as Types.Point2,\n      scaleTicks.endTick1[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      leftTickId\n    );\n    const rightTickId = `${annotationUID}-right`;\n    const rightTickUID = '3';\n\n    drawLineSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rightTickUID,\n      scaleTicks.endTick2[0] as Types.Point2,\n      scaleTicks.endTick2[1] as Types.Point2,\n      {\n        color,\n        width: lineWidth,\n        lineDash,\n        shadow,\n      },\n      rightTickId\n    );\n\n    const locationTextOffest = {\n      bottom: [-10, -42],\n      top: [-12, -35],\n      left: [-40, -20],\n      right: [-50, -20],\n    };\n\n    const textCanvasCoordinates = [\n      scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n      scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n    ];\n    const textBoxLines = this._getTextLines(scaleSize);\n\n    const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(\n      scaleSize,\n      location,\n      annotationUID,\n      scaleTicks.endTick1,\n      scaleTicks.endTick2\n    );\n\n    // draws inner ticks for scale\n    for (let i = 0; i < tickUIDs.length; i++) {\n      drawLineSvg(\n        svgDrawingHelper,\n        annotationUID,\n        tickUIDs[i],\n        tickCoordinates[i][0],\n        tickCoordinates[i][1],\n        {\n          color,\n          width: lineWidth,\n          lineDash,\n          shadow,\n        },\n        tickIds[i]\n      );\n    }\n\n    const textUID = 'text0';\n    drawTextBoxSvg(\n      svgDrawingHelper,\n      annotationUID,\n      textUID,\n      textBoxLines,\n      [textCanvasCoordinates[0], textCanvasCoordinates[1]],\n      {\n        fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        lineDash: '2,3',\n        lineWidth: '1',\n        shadow: true,\n        color: color,\n      }\n    );\n\n    return renderStatus;\n  }\n\n  _getTextLines(scaleSize: number): string[] | undefined {\n    let scaleSizeDisplayValue;\n    let scaleSizeUnits;\n    if (scaleSize >= 50) {\n      scaleSizeDisplayValue = scaleSize / 10; //convert to cm\n      scaleSizeUnits = ' cm';\n    } else {\n      scaleSizeDisplayValue = scaleSize; //convert to cm\n      scaleSizeUnits = ' mm';\n    }\n\n    const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n\n    return textLines;\n  }\n\n  /**\n   *\n   * @param worldWidthViewport\n   * @returns currentScaleSize\n   */\n  computeScaleSize = (\n    worldWidthViewport: number,\n    worldHeightViewport: number,\n    location: any\n  ) => {\n    const scaleSizes = [\n      16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n    ];\n    let currentScaleSize;\n    if (location == 'top' || location == 'bottom') {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldWidthViewport * 0.6 &&\n          scaleSize > worldWidthViewport * 0.2\n      );\n    } else {\n      currentScaleSize = scaleSizes.filter(\n        (scaleSize) =>\n          scaleSize < worldHeightViewport * 0.6 &&\n          scaleSize > worldHeightViewport * 0.2\n      );\n    }\n\n    return currentScaleSize[0];\n  };\n\n  /**\n   *  calculates scale ticks for ends of the scale\n   * @param canvasCoordinates\n   * @returns leftTick, rightTick\n   */\n  computeEndScaleTicks = (canvasCoordinates, location) => {\n    const locationTickOffset = {\n      bottom: [\n        [0, -10],\n        [0, -10],\n      ],\n      top: [\n        [0, 10],\n        [0, 10],\n      ],\n      left: [\n        [0, 0],\n        [10, 0],\n      ],\n      right: [\n        [0, 0],\n        [-10, 0],\n      ],\n    };\n\n    const endTick1 = [\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n    const endTick2 = [\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n      ],\n      [\n        canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n        canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n      ],\n    ];\n\n    return {\n      endTick1: endTick1,\n      endTick2: endTick2,\n    };\n  };\n\n  computeInnerScaleTicks = (\n    scaleSize: number,\n    location: string,\n    annotationUID: string,\n    leftTick: any[][],\n    rightTick: any[][]\n  ) => {\n    let canvasScaleSize;\n    if (location == 'bottom' || location == 'top') {\n      canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n    } else if (location == 'left' || location == 'right') {\n      canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n    }\n    const tickIds = [];\n    const tickUIDs = [];\n    const tickCoordinates = [];\n    let numberSmallTicks = scaleSize;\n\n    if (scaleSize >= 50) {\n      numberSmallTicks = scaleSize / 10;\n    }\n\n    const tickSpacing = canvasScaleSize / numberSmallTicks;\n\n    for (let i = 0; i < numberSmallTicks - 1; i++) {\n      const locationOffset = {\n        bottom: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), 5],\n        ],\n        top: [\n          [tickSpacing * (i + 1), 0],\n          [tickSpacing * (i + 1), -5],\n        ],\n        left: [\n          [0, tickSpacing * (i + 1)],\n          [-5, tickSpacing * (i + 1)],\n        ],\n        right: [\n          [0, tickSpacing * (i + 1)],\n          [5, tickSpacing * (i + 1)],\n        ],\n      };\n      tickIds.push(`${annotationUID}-tick${i}`);\n      tickUIDs.push(`tick${i}`);\n      if ((i + 1) % 5 == 0) {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][0][0],\n            leftTick[1][1] + locationOffset[location][0][1],\n          ],\n        ]);\n      } else {\n        tickCoordinates.push([\n          [\n            leftTick[0][0] + locationOffset[location][0][0],\n            leftTick[0][1] + locationOffset[location][0][1],\n          ],\n          [\n            leftTick[1][0] + locationOffset[location][1][0],\n            leftTick[1][1] + locationOffset[location][1][1],\n          ],\n        ]);\n      }\n    }\n\n    return { tickIds, tickUIDs, tickCoordinates };\n  };\n\n  computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n    let worldCoordinates;\n    let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n    topBottomVec = vec3.normalize(vec3.create(), topBottomVec) as Types.Point3;\n\n    let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n    topRightVec = vec3.normalize(vec3.create(), topRightVec);\n\n    const midpointLocation = {\n      bottom: [pointSet[1], pointSet[2]],\n      top: [pointSet[0], pointSet[3]],\n      right: [pointSet[2], pointSet[3]],\n      left: [pointSet[0], pointSet[1]],\n    };\n\n    const midpoint = vec3\n      .add(\n        vec3.create(),\n        midpointLocation[location][0],\n        midpointLocation[location][0]\n      )\n      .map((i) => i / 2) as Types.Point3;\n\n    const offset =\n      scaleSize /\n      2 /\n      Math.sqrt(\n        Math.pow(topBottomVec[0], 2) +\n          Math.pow(topBottomVec[1], 2) +\n          Math.pow(topBottomVec[2], 2)\n      );\n\n    if (location == 'top' || location == 'bottom') {\n      worldCoordinates = [\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topRightVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    } else if (location == 'left' || location == 'right') {\n      worldCoordinates = [\n        vec3.add(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n        vec3.subtract(\n          vec3.create(),\n          midpoint,\n          topBottomVec.map((i) => i * offset) as Types.Point3\n        ),\n      ];\n    }\n\n    return worldCoordinates;\n  };\n\n  /**\n   * Computes the centered canvas coordinates for scale\n   * @param canvasSize\n   * @param canvasCoordinates\n   * @param vscaleBounds\n   * @returns scaleCanvasCoordinates\n   */\n  computeCanvasScaleCoordinates = (\n    canvasSize,\n    canvasCoordinates,\n    vscaleBounds,\n    hscaleBounds,\n    location\n  ) => {\n    let scaleCanvasCoordinates;\n    if (location == 'top' || location == 'bottom') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][0] - canvasCoordinates[1][0];\n      scaleCanvasCoordinates = [\n        [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n        [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n      ];\n    } else if (location == 'left' || location == 'right') {\n      const worldDistanceOnCanvas =\n        canvasCoordinates[0][1] - canvasCoordinates[1][1];\n      scaleCanvasCoordinates = [\n        [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n        [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n      ];\n    }\n\n    return scaleCanvasCoordinates;\n  };\n\n  /**\n   * Computes the max bound for scales on the image\n   * @param  {{width: number, height: number}} canvasSize\n   * @param  {number} horizontalReduction\n   * @param  {number} verticalReduction\n   * @returns {Object.<string, { x:number, y:number }>}\n   */\n  computeScaleBounds = (\n    canvasSize,\n    horizontalReduction,\n    verticalReduction,\n    location\n  ) => {\n    const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n    const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n    const locationBounds = {\n      bottom: [-vReduction, -hReduction],\n      top: [vReduction, hReduction],\n      left: [vReduction, hReduction],\n      right: [-vReduction, -hReduction],\n    };\n    const canvasBounds = {\n      bottom: [canvasSize.height, canvasSize.width],\n      top: [0, canvasSize.width],\n      left: [canvasSize.height, 0],\n      right: [canvasSize.height, canvasSize.width],\n    };\n\n    return {\n      height: canvasBounds[location][0] + locationBounds[location][0],\n      width: canvasBounds[location][1] + locationBounds[location][1],\n    };\n  };\n}\n\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { ImageVolume, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { pointInShapeCallback } from '../../../utilities';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype OperationData = {\n  segmentationId: string;\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n  volume: ImageVolume;\n  constraintFn: (x: [number, number, number]) => boolean;\n  segmentIndex: number;\n  segmentsLocked: number[];\n};\n\n/**\n * For each point in the bounding box around the rectangle, if the point is inside\n * the rectangle, set the scalar value to the segmentIndex\n * @param toolGroupId - string\n * @param operationData - OperationData\n * @param constraintFn - can be used to perform threshold segmentation\n * @param inside - boolean\n */\n// Todo: why we have another constraintFn? in addition to the one in the operationData?\nfunction fillRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData,\n  inside = true\n): void {\n  const {\n    volume: segmentation,\n    points,\n    segmentsLocked,\n    segmentIndex,\n    segmentationId,\n    constraintFn,\n  } = operationData;\n  const { imageData, dimensions } = segmentation;\n  const scalarData = segmentation.getScalarData();\n\n  let rectangleCornersIJK = points.map((world) => {\n    return transformWorldToIndex(imageData, world);\n  });\n\n  // math round\n  rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n    return point.map((coord) => {\n      return Math.round(coord);\n    });\n  });\n\n  const boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n\n  // Since always all points inside the boundsIJK is inside the rectangle...\n  const pointInRectangle = () => true;\n\n  const callback = ({ value, index, pointIJK }) => {\n    if (segmentsLocked.includes(value)) {\n      return;\n    }\n\n    if (!constraintFn) {\n      scalarData[index] = segmentIndex;\n      return;\n    }\n\n    if (constraintFn(pointIJK)) {\n      scalarData[index] = segmentIndex;\n    }\n  };\n\n  pointInShapeCallback(imageData, pointInRectangle, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationId);\n}\n\n/**\n * Fill the inside of a rectangle\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n * @param constraintFn - can be used to perform threshold segmentation\n */\nexport function fillInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Fill the area outside of a rectangle for the toolGroupId and segmentationRepresentationUID.\n * @param toolGroupId - The unique identifier of the tool group.\n * @param operationData - The data that will be used to create the\n * new rectangle.\n * @param constraintFn - can be used to perform threshold segmentation\n */\nexport function fillOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: OperationData\n): void {\n  fillRectangle(enabledElement, operationData, false);\n}\n","import { ImageVolume, utilities as csUtils } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { getBoundingBoxAroundShape } from '../../../utilities/boundingBox';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { pointInShapeCallback } from '../../../utilities';\n\nconst { transformWorldToIndex } = csUtils;\n\ntype EraseOperationData = {\n  segmentationId: string;\n  points: [Types.Point3, Types.Point3, Types.Point3, Types.Point3];\n  volume: ImageVolume;\n  constraintFn: (x: [number, number, number]) => boolean;\n  segmentsLocked: number[];\n};\n\nfunction eraseRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: EraseOperationData,\n  inside = true\n): void {\n  const {\n    volume: segmentation,\n    points,\n    segmentsLocked,\n    segmentationId,\n  } = operationData;\n  const { imageData, dimensions } = segmentation;\n  const scalarData = segmentation.getScalarData();\n\n  const rectangleCornersIJK = points.map((world) => {\n    return transformWorldToIndex(imageData, world);\n  });\n\n  const boundsIJK = getBoundingBoxAroundShape(rectangleCornersIJK, dimensions);\n\n  // Since always all points inside the boundsIJK is inside the rectangle...\n  const pointInShape = () => true;\n\n  const callback = ({ value, index }) => {\n    if (segmentsLocked.includes(value)) {\n      return;\n    }\n    scalarData[index] = 0;\n  };\n\n  pointInShapeCallback(imageData, pointInShape, callback, boundsIJK);\n\n  triggerSegmentationDataModified(segmentationId);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels inside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function eraseInsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: EraseOperationData\n): void {\n  eraseRectangle(enabledElement, operationData, true);\n}\n\n/**\n * Erase the rectangle region segment inside the segmentation defined by the operationData.\n * It erases the segmentation pixels outside the defined rectangle.\n * @param enabledElement - The element for which the segment is being erased.\n * @param operationData - EraseOperationData\n */\nexport function eraseOutsideRectangle(\n  enabledElement: Types.IEnabledElement,\n  operationData: EraseOperationData\n): void {\n  eraseRectangle(enabledElement, operationData, false);\n}\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\n\nimport { Events } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\n/**\n * Tool for manipulating segmentation data by drawing a rectangle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass RectangleScissorsTool extends BaseTool {\n  static toolName;\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    segmentationId: string;\n    segmentation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideRectangle,\n          ERASE_INSIDE: eraseInsideRectangle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      highlighted: true,\n      invalidated: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n      },\n    };\n\n    const viewportIdsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName()\n    );\n\n    this.editData = {\n      annotation,\n      segmentation,\n      segmentIndex,\n      segmentsLocked,\n      segmentColor,\n      segmentationId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    // Moving handle.\n    const { currentPoints } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n    const worldPos = currentPoints.world;\n\n    const { points } = data.handles;\n\n    // Move this handle.\n    points[handleIndex] = [...worldPos];\n\n    let bottomLeftCanvas;\n    let bottomRightCanvas;\n    let topLeftCanvas;\n    let topRightCanvas;\n\n    let bottomLeftWorld;\n    let bottomRightWorld;\n    let topLeftWorld;\n    let topRightWorld;\n\n    switch (handleIndex) {\n      case 0:\n      case 3:\n        // Moving bottomLeft or topRight\n\n        bottomLeftCanvas = worldToCanvas(points[0]);\n        topRightCanvas = worldToCanvas(points[3]);\n\n        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n        topLeftWorld = canvasToWorld(topLeftCanvas);\n\n        points[1] = bottomRightWorld;\n        points[2] = topLeftWorld;\n\n        break;\n      case 1:\n      case 2:\n        // Moving bottomRight or topLeft\n        bottomRightCanvas = worldToCanvas(points[1]);\n        topLeftCanvas = worldToCanvas(points[2]);\n\n        bottomLeftCanvas = <Types.Point2>[\n          topLeftCanvas[0],\n          bottomRightCanvas[1],\n        ];\n        topRightCanvas = <Types.Point2>[bottomRightCanvas[0], topLeftCanvas[1]];\n\n        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n        topRightWorld = canvasToWorld(topRightCanvas);\n\n        points[0] = bottomLeftWorld;\n        points[3] = topRightWorld;\n\n        break;\n    }\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentation,\n      segmentationId,\n      segmentIndex,\n      segmentsLocked,\n    } = this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation,\n      segmentationId,\n      segmentIndex,\n      segmentsLocked,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * it is used to draw the rectangleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const rectangleUID = '0';\n    drawRectSvg(\n      svgDrawingHelper,\n      annotationUID,\n      rectangleUID,\n      canvasCoordinates[0],\n      canvasCoordinates[3],\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n  config as segmentationConfig,\n} from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\n/**\n * Tool for manipulating segmentation data by drawing a circle. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex.\n */\nclass CircleScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentation: any;\n    segmentIndex: number;\n    segmentationId: string;\n    segmentsLocked: number[];\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideCircle,\n          // ERASE_INSIDE: eraseInsideCircle,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n\n    // Todo: Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      invalidated: true,\n      highlighted: true,\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        isDrawing: true,\n        cachedStats: {},\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      segmentation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentationId,\n      segmentsLocked,\n      segmentColor,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    // Center of circle in canvas Coordinates\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentation,\n      segmentIndex,\n      segmentsLocked,\n      segmentationId,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation,\n      segmentIndex,\n      segmentsLocked,\n      viewPlaneNormal,\n      segmentationId,\n      viewUp,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the circleScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n    return renderStatus;\n  };\n}\n\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { cache, getEnabledElement, StackViewport } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport {\n  PublicToolProps,\n  ToolProps,\n  EventTypes,\n  SVGDrawingHelper,\n} from '../../types';\n\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\n\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport {\n  config as segmentationConfig,\n  segmentLocking,\n  segmentIndex as segmentIndexController,\n  activeSegmentation,\n} from '../../stateManagement/segmentation';\n\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\n/**\n * Tool for manipulating segmentation data by drawing a sphere in 3d space. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will use the activeSegmentIndex\n * for the segmentation to modify. You can use SegmentationModule to set the active\n * segmentation and segmentIndex. Todo: sphere scissor has some memory problem which\n * lead to ui blocking behavior that needs to be fixed.\n */\nclass SphereScissorsTool extends BaseTool {\n  static toolName;\n  editData: {\n    annotation: any;\n    segmentation: any;\n    segmentIndex: number;\n    segmentsLocked: number[];\n    segmentationId: string;\n    toolGroupId: string;\n    segmentColor: [number, number, number, number];\n    viewportIdsToRender: string[];\n    handleIndex?: number;\n    movingTextBox: boolean;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n    centerCanvas?: Array<number>;\n  } | null;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: {\n        strategies: {\n          FILL_INSIDE: fillInsideSphere,\n        },\n        defaultStrategy: 'FILL_INSIDE',\n        activeStrategy: 'FILL_INSIDE',\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): true => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal, viewUp } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationRepresentationUID, segmentationId, type } =\n      activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked = segmentLocking.getLockedSegments(segmentationId);\n\n    const segmentColor = segmentationConfig.color.getColorForSegmentIndex(\n      toolGroupId,\n      segmentationRepresentationUID,\n      segmentIndex\n    );\n\n    const { representationData } = getSegmentation(segmentationId);\n\n    // Todo: are we going to support contour editing with rectangle scissors?\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n\n    this.isDrawing = true;\n\n    // Used for drawing the svg only, we might not need it at all\n    const annotation = {\n      metadata: {\n        viewPlaneNormal: <Types.Point3>[...viewPlaneNormal],\n        viewUp: <Types.Point3>[...viewUp],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: '',\n        toolName: this.getToolName(),\n        segmentColor,\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [[...worldPos], [...worldPos], [...worldPos], [...worldPos]],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        highlighted: true,\n      },\n    };\n\n    const viewportIdsToRender = [viewport.id];\n\n    this.editData = {\n      annotation,\n      segmentation,\n      centerCanvas: canvasPos,\n      segmentIndex,\n      segmentsLocked,\n      segmentColor,\n      segmentationId,\n      toolGroupId,\n      viewportIdsToRender,\n      handleIndex: 3,\n      movingTextBox: false,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n\n    return true;\n  };\n\n  _dragCallback = (evt: EventTypes.InteractionEventType) => {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { currentPoints } = eventDetail;\n    const currentCanvasPoints = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { canvasToWorld } = viewport;\n\n    //////\n    const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n    const { data } = annotation;\n\n    const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n    const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n    const radius = Math.sqrt(dX * dX + dY * dY);\n\n    const bottomCanvas: Types.Point2 = [\n      centerCanvas[0],\n      centerCanvas[1] + radius,\n    ];\n    const topCanvas: Types.Point2 = [centerCanvas[0], centerCanvas[1] - radius];\n    const leftCanvas: Types.Point2 = [\n      centerCanvas[0] - radius,\n      centerCanvas[1],\n    ];\n    const rightCanvas: Types.Point2 = [\n      centerCanvas[0] + radius,\n      centerCanvas[1],\n    ];\n\n    data.handles.points = [\n      canvasToWorld(bottomCanvas),\n      canvasToWorld(topCanvas),\n      canvasToWorld(leftCanvas),\n      canvasToWorld(rightCanvas),\n    ];\n\n    annotation.invalidated = true;\n\n    this.editData.hasMoved = true;\n\n    triggerAnnotationRenderForViewportIds(renderingEngine, viewportIdsToRender);\n  };\n\n  _endCallback = (evt: EventTypes.InteractionEventType) => {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n\n    const {\n      annotation,\n      newAnnotation,\n      hasMoved,\n      segmentation,\n      segmentIndex,\n      segmentsLocked,\n      segmentationId,\n    } = this.editData;\n    const { data } = annotation;\n    const { viewPlaneNormal, viewUp } = annotation.metadata;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n    annotation.highlighted = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (viewport instanceof StackViewport) {\n      throw new Error('Not implemented yet');\n    }\n\n    const operationData = {\n      points: data.handles.points,\n      volume: segmentation,\n      segmentIndex,\n      segmentsLocked,\n      segmentationId,\n      viewPlaneNormal,\n      viewUp,\n    };\n\n    this.applyActiveStrategy(enabledElement, operationData);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event propagation.\n   */\n  _activateDraw = (element) => {\n    element.addEventListener(Events.MOUSE_UP, this._endCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._endCallback);\n    element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._endCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n  };\n\n  /**\n   * it is used to draw the sphereScissor annotation in each\n   * request animation frame. Note that the annotation are disappeared\n   * after the segmentation modification.\n   *\n   * @param enabledElement - The Cornerstone's enabledElement.\n   * @param svgDrawingHelper - The svgDrawingHelper providing the context for drawing.\n   */\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    let renderStatus = false;\n    if (!this.editData) {\n      return renderStatus;\n    }\n\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender } = this.editData;\n\n    if (!viewportIdsToRender.includes(viewport.id)) {\n      return renderStatus;\n    }\n\n    const { annotation } = this.editData;\n\n    // Todo: rectangle color based on segment index\n    const toolMetadata = annotation.metadata;\n    const annotationUID = annotation.annotationUID;\n\n    const data = annotation.data;\n    const { points } = data.handles;\n    const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n    const bottom = canvasCoordinates[0];\n    const top = canvasCoordinates[1];\n\n    const center = [\n      Math.floor((bottom[0] + top[0]) / 2),\n      Math.floor((bottom[1] + top[1]) / 2),\n    ];\n\n    const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n\n    const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n\n    // If rendering engine has been destroyed while rendering\n    if (!viewport.getRenderingEngine()) {\n      console.warn('Rendering Engine has been destroyed');\n      return renderStatus;\n    }\n\n    const circleUID = '0';\n    drawCircleSvg(\n      svgDrawingHelper,\n      annotationUID,\n      circleUID,\n      center as Types.Point2,\n      radius,\n      {\n        color,\n      }\n    );\n\n    renderStatus = true;\n\n    return renderStatus;\n  };\n}\n\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\n\nimport { BaseTool } from './base';\nimport { getRenderingEngines } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\n\nconst OverlayMarkerType = {\n  ANNOTATED_CUBE: 1,\n  AXES: 2,\n  CUSTOM: 3,\n};\n\n/**\n * The OrientationMarker is a tool that includes an orientation marker in viewports\n * when activated\n */\nclass OrientationMarkerTool extends BaseTool {\n  static toolName;\n  static CUBE = 1;\n  static AXIS = 2;\n  static VTPFILE = 3;\n  orientationMarkers;\n  polyDataURL;\n\n  static OVERLAY_MARKER_TYPES = OverlayMarkerType;\n\n  configuration_invalidated = true;\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {\n        orientationWidget: {\n          enabled: true,\n          viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n          viewportSize: 0.15,\n          minPixelSize: 100,\n          maxPixelSize: 300,\n        },\n        overlayMarkerType:\n          OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n        overlayConfiguration: {\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n            faceProperties: {\n              xPlus: { text: 'R', faceColor: '#ffff00', faceRotation: 90 },\n              xMinus: { text: 'L', faceColor: '#ffff00', faceRotation: 270 },\n              yPlus: {\n                text: 'P',\n                faceColor: '#00ffff',\n                fontColor: 'white',\n                faceRotation: 180,\n              },\n              yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n              zPlus: { text: 'S' },\n              zMinus: { text: 'I' },\n            },\n            defaultStyle: {\n              fontStyle: 'bold',\n              fontFamily: 'Arial',\n              fontColor: 'black',\n              fontSizeScale: (res) => res / 2,\n              faceColor: '#0000ff',\n              edgeThickness: 0.1,\n              edgeColor: 'black',\n              resolution: 400,\n            },\n          },\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n          [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n            polyDataURL:\n              'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n          },\n        },\n      },\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n    this.orientationMarkers = {};\n    this.configuration_invalidated = true;\n  }\n\n  onSetToolEnabled = (): void => {\n    this.initViewports();\n    this.configuration_invalidated = true;\n  };\n\n  onSetToolActive = (): void => {\n    this.initViewports();\n  };\n\n  onSetToolDisabled = (): void => {\n    this.cleanUpData();\n  };\n\n  private cleanUpData() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n    const viewports = renderingEngine.getViewports();\n\n    viewports.forEach((viewport) => {\n      const orientationMarker = this.orientationMarkers[viewport.id];\n      if (!orientationMarker) {\n        return;\n      }\n\n      const { actor, orientationWidget } = orientationMarker;\n      orientationWidget?.setEnabled(false);\n      orientationWidget?.delete();\n      actor?.delete();\n\n      const renderWindow = viewport\n        .getRenderingEngine()\n        .offscreenMultiRenderWindow.getRenderWindow();\n      renderWindow.render();\n      viewport.getRenderingEngine().render();\n\n      delete this.orientationMarkers[viewport.id];\n    });\n  }\n\n  private initViewports() {\n    const renderingEngines = getRenderingEngines();\n    const renderingEngine = renderingEngines[0];\n\n    if (!renderingEngine) {\n      return;\n    }\n\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n    viewports.forEach((viewport) => this.addAxisActorInViewport(viewport));\n  }\n\n  async addAxisActorInViewport(viewport) {\n    const viewportId = viewport.id;\n    const type = this.configuration.overlayMarkerType;\n\n    const overlayConfiguration = this.configuration.overlayConfiguration[type];\n\n    if (this.orientationMarkers[viewportId]) {\n      const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n      // remove the previous one\n      viewport.getRenderer().removeActor(actor);\n      orientationWidget.setEnabled(false);\n    }\n\n    let actor;\n    if (type === 1) {\n      actor = this.createAnnotationCube(overlayConfiguration);\n    } else if (type === 2) {\n      actor = vtkAxesActor.newInstance();\n    } else if (type === 3) {\n      actor = await this.createCustomActor();\n    }\n\n    const renderer = viewport.getRenderer();\n    const renderWindow = viewport\n      .getRenderingEngine()\n      .offscreenMultiRenderWindow.getRenderWindow();\n\n    const {\n      enabled,\n      viewportCorner,\n      viewportSize,\n      minPixelSize,\n      maxPixelSize,\n    } = this.configuration.orientationWidget;\n\n    const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n      actor,\n      interactor: renderWindow.getInteractor(),\n      parentRenderer: renderer,\n    });\n\n    orientationWidget.setEnabled(enabled);\n    orientationWidget.setViewportCorner(viewportCorner);\n    orientationWidget.setViewportSize(viewportSize);\n    orientationWidget.setMinPixelSize(minPixelSize);\n    orientationWidget.setMaxPixelSize(maxPixelSize);\n\n    orientationWidget.updateMarkerOrientation();\n    this.orientationMarkers[viewportId] = {\n      orientationWidget,\n      actor,\n    };\n    renderWindow.render();\n    viewport.getRenderingEngine().render();\n\n    this.configuration_invalidated = false;\n  }\n\n  private async createCustomActor() {\n    const url =\n      this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n        .polyDataURL;\n\n    const response = await fetch(url);\n    const arrayBuffer = await response.arrayBuffer();\n    const vtpReader = vtkXMLPolyDataReader.newInstance();\n    vtpReader.parseAsArrayBuffer(arrayBuffer);\n    vtpReader.update();\n\n    const polyData = vtkPolyData.newInstance();\n    polyData.shallowCopy(vtpReader.getOutputData());\n    polyData.getPointData().setActiveScalars('Color');\n    const mapper = vtkMapper.newInstance();\n    mapper.setInputData(polyData);\n    mapper.setColorModeToDirectScalars();\n\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.rotateZ(180);\n    return actor;\n  }\n\n  private createAnnotationCube(overlayConfiguration: any) {\n    const actor = vtkAnnotatedCubeActor.newInstance();\n    actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n    actor.setXPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.xPlus,\n    });\n    actor.setXMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.xMinus,\n    });\n    actor.setYPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.yPlus,\n    });\n    actor.setYMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.yMinus,\n    });\n    actor.setZPlusFaceProperty({\n      ...overlayConfiguration.faceProperties.zPlus,\n    });\n    actor.setZMinusFaceProperty({\n      ...overlayConfiguration.faceProperties.zMinus,\n    });\n    return actor;\n  }\n\n  async createAnnotatedCubeActor() {\n    const axes = vtkAnnotatedCubeActor.newInstance();\n    const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n\n    axes.setDefaultStyle(defaultStyle);\n\n    Object.keys(faceProperties).forEach((key) => {\n      const methodName = `set${\n        key.charAt(0).toUpperCase() + key.slice(1)\n      }FaceProperty`;\n      axes[methodName](faceProperties[key]);\n    });\n\n    return axes;\n  }\n}\n\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import {\n  cache,\n  getEnabledElement,\n  utilities as csUtils,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nimport { BaseTool } from '../base';\nimport { PublicToolProps, ToolProps, EventTypes } from '../../types';\n\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport {\n  segmentLocking,\n  activeSegmentation,\n  segmentIndex as segmentIndexController,\n} from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport { FloodFillResult, FloodFillGetter } from '../../types';\nimport { LabelmapSegmentationData } from '../../types/LabelmapTypes';\n\nconst { transformWorldToIndex, isEqual } = csUtils;\n\ntype PaintFillToolHelpers = {\n  getScalarDataPositionFromPlane: (x: number, y: number) => number;\n  getLabelValue: (x: number, y: number, z: number) => number;\n  floodFillGetter: FloodFillGetter;\n  inPlaneSeedPoint: Types.Point2;\n  fixedDimensionValue: number;\n};\n\n/**\n * Tool for manipulating segmentation data by filling in regions. It acts on the\n * active Segmentation on the viewport (enabled element) and requires an active\n * segmentation to be already present. By default it will fill a given labelled\n * or empty region with the the activeSegmentIndex label. You can use the\n * SegmentationModule to set the active segmentation and segmentIndex.\n */\nclass PaintFillTool extends BaseTool {\n  static toolName;\n\n  constructor(\n    toolProps: PublicToolProps = {},\n    defaultToolProps: ToolProps = {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  /**\n   * Based on the current position of the mouse and the enabledElement, it\n   * finds the active segmentation info and use it for the current tool.\n   *\n   * @param evt -  EventTypes.NormalizedMouseEventType\n   * @returns The annotation object.\n   *\n   */\n  preMouseDownCallback = (evt: EventTypes.InteractionEventType): boolean => {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal } = camera;\n    const toolGroupId = this.toolGroupId;\n\n    const activeSegmentationRepresentation =\n      activeSegmentation.getActiveSegmentationRepresentation(toolGroupId);\n    if (!activeSegmentationRepresentation) {\n      throw new Error(\n        'No active segmentation detected, create one before using scissors tool'\n      );\n    }\n\n    const { segmentationId, type } = activeSegmentationRepresentation;\n    const segmentIndex =\n      segmentIndexController.getActiveSegmentIndex(segmentationId);\n    const segmentsLocked: number[] =\n      segmentLocking.getLockedSegments(segmentationId);\n    const { representationData } = getSegmentation(segmentationId);\n\n    const { volumeId } = representationData[type] as LabelmapSegmentationData;\n    const segmentation = cache.getVolume(volumeId);\n    const { dimensions, direction } = segmentation;\n    const scalarData = segmentation.getScalarData();\n\n    const index = transformWorldToIndex(segmentation.imageData, worldPos);\n\n    const fixedDimension = this.getFixedDimension(\n      viewPlaneNormal,\n      direction as number[]\n    );\n\n    if (fixedDimension === undefined) {\n      console.warn('Oblique paint fill not yet supported');\n      return;\n    }\n\n    const {\n      floodFillGetter,\n      getLabelValue,\n      getScalarDataPositionFromPlane,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    } = this.generateHelpers(scalarData, dimensions, index, fixedDimension);\n\n    // Check if within volume\n    if (\n      index[0] < 0 ||\n      index[0] >= dimensions[0] ||\n      index[1] < 0 ||\n      index[1] >= dimensions[1] ||\n      index[2] < 0 ||\n      index[2] >= dimensions[2]\n    ) {\n      // Clicked outside segmentation volume, no good way to fill.\n      return;\n    }\n    //@ts-ignore // todo type\n    const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n\n    if (segmentsLocked.includes(clickedLabelValue)) {\n      // Label is locked, cannot fill.\n      return;\n    }\n\n    const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n\n    const { flooded } = floodFillResult;\n\n    flooded.forEach((index) => {\n      const scalarDataPosition = getScalarDataPositionFromPlane(\n        index[0],\n        index[1]\n      );\n\n      scalarData[scalarDataPosition] = segmentIndex;\n    });\n\n    const framesModified = this.getFramesModified(\n      fixedDimension,\n      fixedDimensionValue,\n      floodFillResult\n    );\n\n    triggerSegmentationDataModified(segmentationId, framesModified);\n\n    return true;\n  };\n\n  private getFramesModified = (\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    floodFillResult: FloodFillResult\n  ): number[] => {\n    const { boundaries } = floodFillResult;\n\n    if (fixedDimension === 2) {\n      return [fixedDimensionValue];\n    }\n\n    // For both the fixedDimensions being 0 and 1, the Z (stack) direction is j,\n    // so we don't need to find min/max i.\n\n    let minJ = Infinity;\n    let maxJ = -Infinity;\n\n    for (let b = 0; b < boundaries.length; b++) {\n      const j = boundaries[b][1];\n\n      if (j < minJ) {\n        minJ = j;\n      }\n      if (j > maxJ) {\n        maxJ = j;\n      }\n    }\n\n    const framesModified = [];\n\n    for (let frame = minJ; frame <= maxJ; frame++) {\n      framesModified.push(frame);\n    }\n\n    return framesModified;\n  };\n\n  private generateHelpers = (\n    scalarData: Float32Array | Uint8Array | Uint16Array | Int16Array,\n    dimensions: Types.Point3,\n    seedIndex3D: Types.Point3,\n    fixedDimension = 2\n  ): PaintFillToolHelpers => {\n    let fixedDimensionValue: number;\n    let inPlaneSeedPoint: Types.Point2;\n\n    switch (fixedDimension) {\n      case 0:\n        fixedDimensionValue = seedIndex3D[0]; // X\n        inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]]; // Y,Z\n        break;\n      case 1:\n        fixedDimensionValue = seedIndex3D[1]; // Y\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]]; // X,Z\n        break;\n      case 2:\n        fixedDimensionValue = seedIndex3D[2]; // Z\n        inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]]; // X, Y\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    const getScalarDataPosition = (x: number, y: number, z: number): number => {\n      return z * dimensions[1] * dimensions[0] + y * dimensions[0] + x;\n    };\n\n    const getLabelValue = (x: number, y: number, z: number): number => {\n      return scalarData[getScalarDataPosition(x, y, z)];\n    };\n\n    const floodFillGetter = this.generateFloodFillGetter(\n      dimensions,\n      fixedDimension,\n      fixedDimensionValue,\n      getLabelValue\n    );\n\n    const getScalarDataPositionFromPlane =\n      this.generateGetScalarDataPositionFromPlane(\n        getScalarDataPosition,\n        fixedDimension,\n        fixedDimensionValue\n      );\n\n    return {\n      getScalarDataPositionFromPlane,\n      getLabelValue,\n      floodFillGetter,\n      inPlaneSeedPoint,\n      fixedDimensionValue,\n    };\n  };\n\n  private getFixedDimension(\n    viewPlaneNormal: Types.Point3,\n    direction: number[]\n  ): number | undefined {\n    const xDirection = direction.slice(0, 3);\n    const yDirection = direction.slice(3, 6);\n    const zDirection = direction.slice(6, 9);\n\n    const absoluteOfViewPlaneNormal = [\n      Math.abs(viewPlaneNormal[0]),\n      Math.abs(viewPlaneNormal[1]),\n      Math.abs(viewPlaneNormal[2]),\n    ];\n\n    const absoluteOfXDirection = [\n      Math.abs(xDirection[0]),\n      Math.abs(xDirection[1]),\n      Math.abs(xDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n      return 0;\n    }\n\n    const absoluteOfYDirection = [\n      Math.abs(yDirection[0]),\n      Math.abs(yDirection[1]),\n      Math.abs(yDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n      return 1;\n    }\n\n    const absoluteOfZDirection = [\n      Math.abs(zDirection[0]),\n      Math.abs(zDirection[1]),\n      Math.abs(zDirection[2]),\n    ];\n\n    if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n      return 2;\n    }\n  }\n\n  // Define a getter for the fill routine to access the working label map.\n  private generateFloodFillGetter = (\n    dimensions: Types.Point3,\n    fixedDimension: number,\n    fixedDimensionValue: number,\n    getLabelValue: PaintFillToolHelpers['getLabelValue']\n  ): FloodFillGetter => {\n    let floodFillGetter;\n\n    // In each helper we first check if out of bounds, as the flood filler\n    // doesn't know about the dimensions of the data structure that sits on top\n    // of the scalarData. E.g. if cols is 10, (0,1) and (10, 0) would point to\n    // the same position in these getters.\n\n    switch (fixedDimension) {\n      case 0:\n        floodFillGetter = (y, z) => {\n          if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(fixedDimensionValue, y, z);\n        };\n        break;\n\n      case 1:\n        floodFillGetter = (x, z) => {\n          if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n            return;\n          }\n\n          return getLabelValue(x, fixedDimensionValue, z);\n        };\n        break;\n\n      case 2:\n        floodFillGetter = (x, y) => {\n          if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n            return;\n          }\n\n          return getLabelValue(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return floodFillGetter;\n  };\n\n  private generateGetScalarDataPositionFromPlane = (\n    getScalarDataPosition: (x: number, y: number, z: number) => number,\n    fixedDimension: number,\n    fixedDimensionValue: number\n  ): PaintFillToolHelpers['getScalarDataPositionFromPlane'] => {\n    let getScalarDataPositionFromPlane;\n\n    switch (fixedDimension) {\n      case 0:\n        getScalarDataPositionFromPlane = (y, z) => {\n          return getScalarDataPosition(fixedDimensionValue, y, z);\n        };\n        break;\n      case 1:\n        getScalarDataPositionFromPlane = (x, z) => {\n          return getScalarDataPosition(x, fixedDimensionValue, z);\n        };\n        break;\n      case 2:\n        getScalarDataPositionFromPlane = (x, y) => {\n          return getScalarDataPosition(x, y, fixedDimensionValue);\n        };\n        break;\n      default:\n        throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n    }\n\n    return getScalarDataPositionFromPlane;\n  };\n}\n\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import { vec3, vec2 } from 'gl-matrix';\n\nimport {\n  getEnabledElement,\n  triggerEvent,\n  eventTarget,\n  utilities as csUtils,\n  cache,\n} from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\n\nimport throttle from '../../utilities/throttle';\nimport {\n  addAnnotation,\n  getAnnotations,\n  removeAnnotation,\n} from '../../stateManagement';\nimport {\n  drawHandles as drawHandlesSvg,\n  drawRedactionRect as drawRedactionRectSvg,\n} from '../../drawingSvg';\nimport { state } from '../../store';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport {\n  resetElementCursor,\n  hideElementCursor,\n} from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\n\nimport { EventTypes, SVGDrawingHelper } from '../../types';\nimport { StyleSpecifier } from '../../types/AnnotationStyle';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { VideoRedactionAnnotation } from '../../types/ToolSpecificAnnotationTypes';\n\nclass VideoRedactionTool extends AnnotationTool {\n  _throttledCalculateCachedStats: any;\n  editData: {\n    annotation: any;\n    viewportUIDsToRender: string[];\n    handleIndex?: number;\n    newAnnotation?: boolean;\n    hasMoved?: boolean;\n  } | null;\n  _configuration: any;\n  isDrawing: boolean;\n  isHandleOutsideImage: boolean;\n\n  constructor(toolConfiguration = {}) {\n    super(toolConfiguration, {\n      supportedInteractionTypes: ['Mouse', 'Touch'],\n      configuration: { shadow: true, preventHandleOutsideImage: false },\n    });\n\n    this._throttledCalculateCachedStats = throttle(\n      this._calculateCachedStats,\n      100,\n      { trailing: true }\n    );\n  }\n\n  addNewAnnotation = (\n    evt: EventTypes.InteractionEventType\n  ): VideoRedactionAnnotation => {\n    const eventData = evt.detail;\n    const { currentPoints, element } = eventData;\n    const worldPos = currentPoints.world;\n\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n\n    this.isDrawing = true;\n\n    const annotation = {\n      metadata: {\n        // We probably just want a different type of data here, hacking this\n        // together for now.\n        viewPlaneNormal: <Types.Point3>[0, 0, 1],\n        viewUp: <Types.Point3>[0, 1, 0],\n        FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n        referencedImageId: viewport.getFrameOfReferenceUID(),\n        toolName: this.getToolName(),\n      },\n      data: {\n        invalidated: true,\n        handles: {\n          points: [\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n            <Types.Point3>[...worldPos],\n          ],\n          activeHandleIndex: null,\n        },\n        cachedStats: {},\n        active: true,\n      },\n    };\n\n    addAnnotation(annotation, element);\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex: 3,\n      newAnnotation: true,\n      hasMoved: false,\n    };\n    this._activateDraw(element);\n\n    hideElementCursor(element);\n\n    evt.preventDefault();\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    return annotation;\n  };\n\n  getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n\n      const near =\n        vec2.distance(canvasCoords, <vec2>toolDataCanvasCoordinate) < proximity;\n\n      if (near === true) {\n        data.handles.activeHandleIndex = i;\n        return point;\n      }\n    }\n\n    data.handles.activeHandleIndex = null;\n  };\n\n  isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n\n    const { data } = annotation;\n    const { points } = data.handles;\n\n    const canvasPoint1 = viewport.worldToCanvas(points[0]);\n    const canvasPoint2 = viewport.worldToCanvas(points[3]);\n\n    const rect = this._getRectangleImageCoordinates([\n      canvasPoint1,\n      canvasPoint2,\n    ]);\n\n    const point = [canvasCoords[0], canvasCoords[1]] as Types.Point2;\n    const { left, top, width, height } = rect;\n\n    const distanceToPoint = rectangle.distanceToPoint(\n      [left, top, width, height],\n      point\n    );\n\n    if (distanceToPoint <= proximity) {\n      return true;\n    }\n  };\n\n  toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { data } = annotation;\n\n    data.active = true;\n\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n    };\n\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  handleSelectedCallback = (\n    evt,\n    annotation,\n    handle,\n    interactionType = 'mouse'\n  ) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n    const { data } = annotation;\n\n    data.active = true;\n\n    let movingTextBox = false;\n    let handleIndex;\n\n    if (handle.worldPosition) {\n      movingTextBox = true;\n    } else {\n      handleIndex = data.handles.points.findIndex((p) => p === handle);\n    }\n\n    // Find viewports to render on drag.\n    const viewportUIDsToRender = getViewportIdsWithToolToRender(\n      element,\n      this.getToolName(),\n      false\n    );\n\n    this.editData = {\n      annotation,\n      viewportUIDsToRender,\n      handleIndex,\n    };\n    this._activateModify(element);\n\n    hideElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    evt.preventDefault();\n  };\n\n  _mouseUpCallback = (evt) => {\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } =\n      this.editData;\n    const { data } = annotation;\n\n    if (newAnnotation && !hasMoved) {\n      return;\n    }\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    this._deactivateModify(element);\n    this._deactivateDraw(element);\n\n    resetElementCursor(element);\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    this.editData = null;\n    this.isDrawing = false;\n\n    if (\n      this.isHandleOutsideImage &&\n      this.configuration.preventHandleOutsideImage\n    ) {\n      removeAnnotation(annotation.annotationUID);\n    }\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  _mouseDragCallback = (evt) => {\n    this.isDrawing = true;\n\n    const eventData = evt.detail;\n    const { element } = eventData;\n\n    const { annotation, viewportUIDsToRender, handleIndex } = this.editData;\n    const { data } = annotation;\n\n    if (handleIndex === undefined) {\n      // Moving tool, so move all points by the world points delta\n      const { deltaPoints } = eventData;\n      const worldPosDelta = deltaPoints.world;\n\n      const { points } = data.handles;\n\n      points.forEach((point) => {\n        point[0] += worldPosDelta[0];\n        point[1] += worldPosDelta[1];\n        point[2] += worldPosDelta[2];\n      });\n      data.invalidated = true;\n    } else {\n      // Moving handle.\n      const { currentPoints } = eventData;\n      const enabledElement = getEnabledElement(element);\n      const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n      const worldPos = currentPoints.world;\n\n      const { points } = data.handles;\n\n      // Move this handle.\n      points[handleIndex] = [...worldPos];\n\n      let bottomLeftCanvas;\n      let bottomRightCanvas;\n      let topLeftCanvas;\n      let topRightCanvas;\n\n      let bottomLeftWorld;\n      let bottomRightWorld;\n      let topLeftWorld;\n      let topRightWorld;\n\n      switch (handleIndex) {\n        case 0:\n        case 3:\n          // Moving bottomLeft or topRight\n\n          bottomLeftCanvas = worldToCanvas(points[0]);\n          topRightCanvas = worldToCanvas(points[3]);\n\n          bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n          topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n\n          bottomRightWorld = canvasToWorld(bottomRightCanvas);\n          topLeftWorld = canvasToWorld(topLeftCanvas);\n\n          points[1] = bottomRightWorld;\n          points[2] = topLeftWorld;\n\n          break;\n        case 1:\n        case 2:\n          // Moving bottomRight or topLeft\n          bottomRightCanvas = worldToCanvas(points[1]);\n          topLeftCanvas = worldToCanvas(points[2]);\n\n          bottomLeftCanvas = <Types.Point2>[\n            topLeftCanvas[0],\n            bottomRightCanvas[1],\n          ];\n          topRightCanvas = <Types.Point2>[\n            bottomRightCanvas[0],\n            topLeftCanvas[1],\n          ];\n\n          bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n          topRightWorld = canvasToWorld(topRightCanvas);\n\n          points[0] = bottomLeftWorld;\n          points[3] = topRightWorld;\n\n          break;\n      }\n      data.invalidated = true;\n    }\n\n    this.editData.hasMoved = true;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n  };\n\n  cancel(element) {\n    // If it is mid-draw or mid-modify\n    if (!this.isDrawing) {\n      return;\n    }\n    this.isDrawing = false;\n    this._deactivateDraw(element);\n    this._deactivateModify(element);\n    resetElementCursor(element);\n\n    const { annotation, viewportUIDsToRender } = this.editData;\n\n    const { data } = annotation;\n\n    data.active = false;\n    data.handles.activeHandleIndex = null;\n\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine } = enabledElement;\n\n    triggerAnnotationRenderForViewportIds(\n      renderingEngine,\n      viewportUIDsToRender\n    );\n\n    this.editData = null;\n    return annotation.metadata.annotationUID;\n  }\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateDraw = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _deactivateDraw = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_MOVE, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Add event handlers for the modify event loop, and prevent default event prapogation.\n   */\n  _activateModify = (element) => {\n    state.isInteractingWithTool = true;\n\n    element.addEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.addEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  /**\n   * Remove event handlers for the modify event loop, and enable default event propagation.\n   */\n  _deactivateModify = (element) => {\n    state.isInteractingWithTool = false;\n\n    element.removeEventListener(Events.MOUSE_UP, this._mouseUpCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this._mouseDragCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this._mouseUpCallback);\n\n    element.removeEventListener(Events.TOUCH_END, this._mouseUpCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this._mouseDragCallback);\n  };\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: SVGDrawingHelper\n  ): boolean => {\n    const renderStatus = false;\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = getAnnotations(this.getToolName(), element);\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return renderStatus;\n    }\n\n    const targetId = this.getTargetId(viewport);\n    const renderingEngine = viewport.getRenderingEngine();\n\n    const styleSpecifier: StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < annotations.length; i++) {\n      const annotation = annotations[i];\n      const { annotationUID } = annotation;\n      const toolMetadata = annotation.metadata;\n\n      const data = annotation.data;\n      const { points, activeHandleIndex } = data.handles;\n      const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color = this.getStyle('color', styleSpecifier, annotation);\n      // If rendering engine has been destroyed while rendering\n      if (!viewport.getRenderingEngine()) {\n        console.warn('Rendering Engine has been destroyed');\n        return;\n      }\n\n      let activeHandleCanvasCoords;\n\n      if (\n        // !isToolDataLocked(toolData) &&\n        !this.editData &&\n        activeHandleIndex !== null\n      ) {\n        // Not locked or creating and hovering over handle, so render handle.\n        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n      }\n\n      if (activeHandleCanvasCoords) {\n        const handleGroupUID = '0';\n\n        drawHandlesSvg(\n          svgDrawingHelper,\n          annotationUID,\n          handleGroupUID,\n          activeHandleCanvasCoords,\n          {\n            color,\n          }\n        );\n      }\n\n      const rectangleUID = '0';\n      drawRedactionRectSvg(\n        svgDrawingHelper,\n        annotationUID,\n        rectangleUID,\n        canvasCoordinates[0],\n        canvasCoordinates[3],\n        {\n          color: 'black',\n          lineDash,\n          lineWidth,\n        }\n      );\n    }\n  };\n\n  _getRectangleImageCoordinates = (\n    points: Array<Types.Point2>\n  ): {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n  } => {\n    const [point0, point1] = points;\n\n    return {\n      left: Math.min(point0[0], point1[0]),\n      top: Math.min(point0[1], point1[1]),\n      width: Math.abs(point0[0] - point1[0]),\n      height: Math.abs(point0[1] - point1[1]),\n    };\n  };\n\n  _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n    let imageVolume, viewport;\n    if (targetUID.startsWith('stackTarget')) {\n      const coloneIndex = targetUID.indexOf(':');\n      const viewportUID = targetUID.substring(coloneIndex + 1);\n      const viewport = renderingEngine.getViewport(viewportUID);\n      imageVolume = viewport.getImageData();\n    } else {\n      imageVolume = cache.getVolume(targetUID);\n    }\n\n    return { imageVolume, viewport };\n  }\n\n  /**\n   * _calculateCachedStats - For each volume in the frame of reference that a\n   * tool instance in particular viewport defines as its target volume, find the\n   * volume coordinates (i,j,k) being probed by the two corners. One of i,j or k\n   * will be constant across the two points. In the other two directions iterate\n   * over the voxels and calculate the first and second-order statistics.\n   *\n   * @param {object} data - The toolData tool-specific data.\n   * @param {Array<number>} viewPlaneNormal The normal vector of the camera.\n   * @param {Array<number>} viewUp The viewUp vector of the camera.\n   */\n  _calculateCachedStats = (\n    annotation,\n    viewPlaneNormal,\n    viewUp,\n    renderingEngine,\n    enabledElement\n  ) => {\n    const { data } = annotation;\n    const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n\n    const worldPos1 = data.handles.points[0];\n    const worldPos2 = data.handles.points[3];\n    const { cachedStats } = data;\n\n    const targetUIDs = Object.keys(cachedStats);\n\n    for (let i = 0; i < targetUIDs.length; i++) {\n      const targetUID = targetUIDs[i];\n\n      const { imageVolume } = this._getImageVolumeFromTargetUID(\n        targetUID,\n        renderingEngine\n      );\n\n      const {\n        dimensions,\n        scalarData,\n        vtkImageData: imageData,\n        metadata,\n      } = imageVolume;\n      const worldPos1Index = vec3.fromValues(0, 0, 0);\n      const worldPos2Index = vec3.fromValues(0, 0, 0);\n\n      imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n\n      worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n      worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n      worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n\n      imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n\n      worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n      worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n      worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n\n      // Check if one of the indexes are inside the volume, this then gives us\n      // Some area to do stats over.\n\n      if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n        this.isHandleOutsideImage = false;\n\n        // Calculate index bounds to iterate over\n\n        const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n        const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n\n        const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n        const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n\n        const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n        const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(\n          viewPlaneNormal,\n          viewUp,\n          worldPos1,\n          worldPos2\n        );\n\n        const area = worldWidth * worldHeight;\n\n        let count = 0;\n        let mean = 0;\n        let stdDev = 0;\n\n        const yMultiple = dimensions[0];\n        const zMultiple = dimensions[0] * dimensions[1];\n\n        // This is a triple loop, but one of these 3 values will be constant\n        // In the planar view.\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              count++;\n              mean += value;\n            }\n          }\n        }\n\n        mean /= count;\n\n        for (let k = kMin; k <= kMax; k++) {\n          for (let j = jMin; j <= jMax; j++) {\n            for (let i = iMin; i <= iMax; i++) {\n              const value = scalarData[k * zMultiple + j * yMultiple + i];\n\n              const valueMinusMean = value - mean;\n\n              stdDev += valueMinusMean * valueMinusMean;\n            }\n          }\n        }\n\n        stdDev /= count;\n        stdDev = Math.sqrt(stdDev);\n\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n          area,\n          mean,\n          stdDev,\n        };\n      } else {\n        this.isHandleOutsideImage = true;\n        cachedStats[targetUID] = {\n          Modality: metadata.Modality,\n        };\n      }\n    }\n\n    data.invalidated = false;\n\n    // Dispatching measurement modified\n    const eventType = Events.ANNOTATION_MODIFIED;\n\n    const eventDetail = {\n      annotation,\n      viewportUID,\n      renderingEngineUID,\n      sceneUID: sceneUID,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n\n    return cachedStats;\n  };\n\n  _isInsideVolume = (index1, index2, dimensions) => {\n    return (\n      csUtils.indexWithinDimensions(index1, dimensions) &&\n      csUtils.indexWithinDimensions(index2, dimensions)\n    );\n  };\n\n  _getTargetStackUID(viewport) {\n    return `stackTarget:${viewport.uid}`;\n  }\n\n  _getTargetVolumeUID = (scene) => {\n    if (this.configuration.volumeUID) {\n      return this.configuration.volumeUID;\n    }\n\n    const volumeActors = scene.getVolumeActors();\n\n    if (!volumeActors && !volumeActors.length) {\n      // No stack to scroll through\n      return;\n    }\n\n    return volumeActors[0].uid;\n  };\n}\n\nVideoRedactionTool.toolName = 'VideoRedaction';\nexport default VideoRedactionTool;\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__976__","__WEBPACK_EXTERNAL_MODULE__953__","__WEBPACK_EXTERNAL_MODULE__441__","__WEBPACK_EXTERNAL_MODULE__795__","__WEBPACK_EXTERNAL_MODULE__396__","__WEBPACK_EXTERNAL_MODULE__348__","__WEBPACK_EXTERNAL_MODULE__70__","__WEBPACK_EXTERNAL_MODULE__785__","__WEBPACK_EXTERNAL_MODULE__127__","__WEBPACK_EXTERNAL_MODULE__474__","__WEBPACK_EXTERNAL_MODULE__610__","__WEBPACK_EXTERNAL_MODULE__448__","__WEBPACK_EXTERNAL_MODULE__807__","__WEBPACK_EXTERNAL_MODULE__847__","__WEBPACK_EXTERNAL_MODULE__518__","__WEBPACK_EXTERNAL_MODULE__744__","__WEBPACK_EXTERNAL_MODULE__424__","__WEBPACK_EXTERNAL_MODULE__614__","HASH_UNDEFINED","MAX_SAFE_INTEGER","argsTag","boolTag","dateTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reFlags","reIsHostCtor","reIsUint","cloneableTags","freeGlobal","g","Object","freeSelf","Function","freeExports","nodeType","freeModule","moduleExports","addMapEntry","map","pair","set","addSetEntry","value","add","arrayReduce","array","iteratee","accumulator","initAccum","index","length","isHostObject","result","toString","e","mapToArray","Array","size","forEach","key","overArg","func","transform","arg","setToArray","uid","arrayProto","prototype","funcProto","objectProto","coreJsData","maskSrcKey","exec","keys","IE_PROTO","funcToString","hasOwnProperty","objectToString","reIsNative","RegExp","call","replace","Buffer","undefined","Symbol","Uint8Array","getPrototype","getPrototypeOf","objectCreate","create","propertyIsEnumerable","splice","nativeGetSymbols","getOwnPropertySymbols","nativeIsBuffer","isBuffer","nativeKeys","DataView","getNative","Map","Promise","Set","WeakMap","nativeCreate","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","Hash","entries","this","clear","entry","ListCache","MapCache","Stack","__data__","assignValue","object","objValue","eq","assocIndexOf","baseClone","isDeep","isFull","customizer","stack","isObject","isArr","isArray","constructor","input","initCloneArray","source","copyArray","tag","getTag","isFunc","buffer","slice","copy","cloneBuffer","isPrototype","proto","initCloneObject","copyObject","getSymbols","copySymbols","baseAssign","cloneFunc","symbol","Ctor","cloneArrayBuffer","dataView","byteOffset","byteLength","cloneDataView","typedArray","cloneTypedArray","cloneMap","regexp","lastIndex","cloneRegExp","cloneSet","initCloneByTag","stacked","get","props","keysFunc","symbolsFunc","values","offset","arrayPush","baseGetAllKeys","getAllKeys","arrayEach","subValue","arrayBuffer","newValue","getMapData","type","data","getValue","isFunction","test","baseIsNative","has","pop","push","cache","pairs","LARGE_ARRAY_SIZE","isIndex","other","ArrayBuffer","resolve","ctorString","isArrayLike","isLength","inherited","isObjectLike","isArrayLikeObject","isArguments","n","baseTimes","String","skipIndexes","arrayLikeKeys","baseKeys","INFINITY","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","symbolToString","pattern","stringToPath","memoize","string","isSymbol","baseToString","match","number","quote","toKey","resolver","TypeError","memoized","args","arguments","apply","Cache","path","defaultValue","isKey","baseGet","_typeof","_regeneratorRuntime","__esModule","Op","hasOwn","defineProperty","obj","desc","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","enumerable","configurable","writable","err","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","makeInvokeMethod","tryCatch","fn","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","defineIteratorMethods","method","_invoke","AsyncIterator","PromiseImpl","invoke","reject","record","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","state","Error","done","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","methodName","info","resultName","next","nextLoc","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","val","reverse","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","runtime","regeneratorRuntime","accidentalStrictMode","globalThis","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","id","loaded","__webpack_modules__","getter","d","a","definition","o","window","prop","r","nmd","paths","children","Events","_toPropertyKey","hint","prim","toPrimitive","res","_defineProperties","target","descriptor","_createClass","Constructor","protoProps","staticProps","_classCallCheck","instance","_defineProperty","globalLockedAnnotationsSet","setAnnotationLocked","annotation","locked","detail","makeEventDetail","lockedAnnotationsSet","added","lock","unlock","publish","unlockAllAnnotations","clearLockedAnnotationsSet","getAnnotationsLocked","from","isAnnotationLocked","getAnnotationsLockedCount","checkAndDefineIsLockedProperty","isLocked","getOwnPropertyDescriptor","setIsLocked","getIsLocked","isExtensible","shouldDefineIsLockedProperty","freeze","removed","delete","item","triggerEvent","eventTarget","selectedAnnotationUIDs","setAnnotationSelected","annotationUID","deselectAnnotation","preserveSelected","clearSelectionSet","selectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","toolName","filter","getAnnotation","metadata","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","lastHidden","hide","showAllAnnotations","isAnnotationVisible","checkAndDefineIsVisibleProperty","_annotation$isVisible","isVisible","setIsVisible","getIsVisible","shouldDefineIsVisibleProperty","lastVisible","hidden","FrameOfReferenceSpecificAnnotationManager","_this","annotationGroupSelector","element","enabledElement","getEnabledElement","FrameOfReferenceUID","evt","frameOfReferenceSpecificAnnotations","annotations","invalidated","groupKey","frameOfReferenceUID","frameOfReferenceAnnotations","_step","_iterator","_createForOfIteratorHelper","s","f","getAnnotations","total","toolSpecificAnnotations","groupAnnotations","toolAnnotations","findIndex","cloneDeep","count","utilities","Enums","_imageVolumeModifiedHandler","defaultFrameOfReferenceSpecificAnnotationManager","svgNodeCache","defaultState","isInteractingWithTool","isMultiPartToolActive","tools","toolGroups","synchronizers","enabledElements","handleRadius","ToolModes","MODES","_ref","toolOptions","toolGroupToolNames","includes","mode","defaultManager","getAnnotationManager","setAnnotationManager","annotationManager","resetAnnotationManager","manager","getGroupKey","addAnnotation","csUtils","HTMLDivElement","renderingEngine","viewportId","eventType","eventDetail","renderingEngineId","triggerAnnotationAddedForElement","getToolGroupsWithToolName","viewportsToRender","toolGroup","viewportsInfo","viewportInfo","getEnabledElementByIds","triggerAnnotationAddedForFOR","getNumberOfAnnotations","removeAnnotation","annotationManagerUID","removeAllAnnotations","arr","len","arr2","minLen","_slicedToArray","_i","_s","_e","_x","_r","_arr","_n","_d","SegmentationRepresentations","defaultContourConfig","renderOutline","outlineWidthActive","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","renderFill","fillAlpha","fillAlphaInactive","defaultLabelmapConfig","renderFillInactive","getDefaultLabelmapConfig","initialDefaultState","colorLUT","segmentations","globalConfig","renderInactiveSegmentations","representations","_representations","defaultSegmentationStateManager","SegmentationStateManager","lutIndex","segmentationId","find","segmentation","_initDefaultColorLUTIfNecessary","getSegmentation","concat","toolGroupId","toolGroupSegRepresentationsWithConfig","segmentationRepresentations","toolGroupSegReps","_ref2","segmentationRepresentation","config","_handleActiveSegmentation","segmentationRepresentationUID","getSegmentationRepresentations","representation","toolGroupSegmentationRepresentations","segData","console","warn","removedSegmentationRepresentation","toolGroupSegmentations","segmentationData","active","toolGroupStateWithConfig","getSegmentationRepresentationByUID","segmentationRepresentationSpecificConfig","segmentIndex","segmentSpecificConfig","_objectSpread","log","colorLUTIndex","recentlyAddedOrRemovedSegmentationRepresentation","addColorLUT","CORNERSTONE_COLOR_LUT","triggerSegmentationRemoved","triggerSegmentationRepresentationRemoved","triggerSegmentationRepresentationModified","triggerSegmentationModified","getSegmentations","triggerSegmentationDataModified","modifiedSlicesToUse","segmentationInput","cachedStats","segmentLabels","label","segmentsLocked","activeSegmentIndex","representationData","getDefaultSegmentationStateManager","getState","addSegmentation","suppressEvents","segmentationStateManager","normalizeSegmentationInput","getAllSegmentationRepresentations","getToolGroupIdsWithSegmentation","toolGroupIds","foundToolGroupIds","getToolGroupSpecificConfig","setToolGroupSpecificConfig","setSegmentationRepresentationConfig","setSegmentationRepresentationSpecificConfig","getSegmentationRepresentationSpecificConfig","getSegmentSpecificRepresentationConfig","getSegmentSpecificConfig","setSegmentSpecificRepresentationConfig","setSegmentSpecificConfig","addSegmentationRepresentation","getGlobalConfig","setGlobalConfig","removeSegmentation","removeSegmentationRepresentation","removeColorLUT","getColorLUT","getMouseEventPoints","elementToUse","currentTarget","viewport","clientPoint","clientX","clientY","_clientToPoint","pagePoint","pageX","pageY","_pageToPoint","canvasPoint","rect","getBoundingClientRect","left","pageXOffset","top","pageYOffset","_pagePointsToCanvasPoints","page","client","canvas","world","canvasToWorld","_getEnabledElement","startPoints","event","eventName","camera","lastPoints","currentPoints","deltaPoints","stopImmediatePropagation","preventDefault","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_CLICK","MOUSE_UP","MOUSE_DRAG","DOUBLE_CLICK_DRAG_TOLERANCE","mouseButton","isClickEvent","clickDelay","preventClickTimeout","doubleClickState","doubleClickTimeout","mouseDownEvent","mouseUpEvent","ignoreDoubleClick","_onMouseDrag","_updateMouseEventsLastPoints","_getDeltaPoints","_isDragPastDoubleClickTolerance","_doStateMouseDownAndUp","_copyPoints","_onMouseUp","clearTimeout","_cleanUp","addEventListener","_onMouseMove","document","removeEventListener","mouseMoveListener","delta","Math","abs","_preventClickHandler","_clearDoubleClickTimeoutAndEvents","_state$element","_state$element2","JSON","parse","stringify","points","_subtractPoints2D","point0","point1","mouseDoubleClickIgnoreListener","buttons","setTimeout","disable","mouseDoubleClickListener","mouseDownListener","capture","enable","deltaY","_normalizeWheel","spinX","spinY","pixelX","pixelY","wheelDelta","wheelDeltaY","wheelDeltaX","deltaX","deltaMode","normalizeWheel","direction","wheel","wheelListener","lastInteractionType","lastInteractionTime","passive","pointerType","mouse","touch","handleTap","now","Date","stopPropagation","handleTapMouse","bind","handleTapTouch","attachEvents","eventList","interactionType","tapHandler","removeEvents","mouseEvents","touchEvents","Swipe","getTouchEventPoints","touches","changedTouches","identifier","radiusX","radiusY","force","rotationAngle","getDeltaPoints","curr","getMeanPoints","last","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","currentDistance","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","reduce","getMeanTouchPoints","pairedDistance","j","sqrt","pow","Settings","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_PRESS","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_SWIPE","zeroIPoint","zeroIDistance","startPointsList","lastPointsList","isTouchStart","startTime","pressTimeout","pressDelay","pressMaxDistance","accumulatedDistance","swipeDistanceThreshold","swiped","swipeToleranceMs","defaultTapState","taps","tapTimeout","tapMaxDistance","tapToleranceMs","tapState","triggerEventCallback","ele","_onTouchDrag","currentPointsList","_updateTouchEventsLastPoints","deltaDistance","totalDistance","currentTime","getTime","_deltaPoints$canvas","x","y","swipe","RIGHT","LEFT","DOWN","UP","_checkTouchSwipe","_onTouchEnd","_checkTouchTap","lp","_onTouchPress","_onTouchStart","preventGhostClick","touchStartListener","keyCode","keyListener","_onKeyUp","_onVisibilityChange","visibilityState","resetModifierKey","_cloneDeep","keyDownListener","getModifierKey","_toConsumableArray","getSvgNode","canvasHash","cacheKey","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","cacheEntry","removeChild","svgDrawingHelper","viewportElement","querySelector","_getSvgLayer","svgNodeCacheForCanvas","getSvgDrawingHelper","toolGroupFilteredByIds","tg","some","vp","getToolsWithModesForElement","modesFilter","ToolGroupManager","enabledTools","toolInstance","getToolInstance","Active","Passive","Enabled","AnnotationRenderingEngine","_throwIfDestroyed","elements","_viewportElements","_needsRender","_triggerRender","_animationFrameSet","_animationFrameHandle","_reset","_setViewportsToBeRenderedNextFrame","hasBeenDestroyed","_this2","_renderFlaggedViewports","_this3","elementsEnabled","indexOf","_render","requestAnimationFrame","getRenderingEngine","drawSvg","anyRendered","tool","renderAnnotation","rendered","cancelAnimationFrame","_setAllViewportsToBeRenderedNextFrame","annotationRenderingEngine","renderViewport","onImageRendered","triggerAnnotationRender","getToolsWithModesForMouseEvent","evtButton","_evt$detail","correctBinding","bindings","binding","onCameraModified","onImageSpacingCalibrated","customCallbackHandler","handlerType","customFunction","activeTool","filterToolsWithMoveableHandles","ToolAndAnnotations","canvasCoords","proximity","toolsWithMoveableHandles","getHandleNearImagePoint","filterToolsWithAnnotationsForElement","_annotations","filterInteractableAnnotationsForElement","filterMoveableAnnotationTools","moveableAnnotationTools","isPointNearTool","MouseBindings","KeyboardBindings","shiftKey","ctrlKey","kb","altKey","metaKey","getActiveToolForMouseEvent","mouseEvent","modifierKey","getMouseModifier","keyEventListener","defaultMousePrimary","getDefaultMousePrimary","mouseDown","preMouseDownCallback","isPrimaryClick","activeToolsWithEventBinding","passiveToolsIfEventWasPrimaryMouseButton","applicableTools","annotationToolsWithAnnotations","annotationToolsWithMoveableHandles","isMultiSelect","getAnnotationForSelection","toggleAnnotationSelection","handleSelectedCallback","_getAnnotationForSele","toolSelectedCallback","postMouseDownCallback","toolsWithActions","toolModes","_mouseEvent$buttons","_tool$configuration","actions","configuration","action","getToolsWithActionsForMouseEvent","_moveableAnnotationTo","mouseDownAnnotationAction","toolsWithMovableHandles","mouseDownActivate","addNewAnnotation","mouseDrag","mouseDragCallback","mouseMove","activeAndPassiveTools","toolsWithAnnotations","toolsWithoutAnnotations","toolAndAnnotation","getToolName","annotationsNeedToBeRedrawn","_step$value","mouseMoveCallback","mouseClick","mouseDoubleClick","mouseUp","mouseWheel","getActiveToolForKeyboardEvent","keyDown","setViewportsCursorByToolName","keyUp","getActiveToolForTouchEvent","touchEvent","numTouchPoints","getToolsWithModesForTouchEvent","touchStart","preTouchStartCallback","passiveToolsIfEventWasPrimaryTouchButton","postTouchStartCallback","touchStartActivate","touchDrag","touchDragCallback","touchEnd","touchTap","touchPress","addEnabledElement","newNode","svgLayer","svgns","createElementNS","svgLayerId","classList","setAttribute","style","width","height","pointerEvents","position","defs","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","_element$dataset","dataset","viewportUid","renderingEngineUid","elementHash","_setSvgNodeCache","addViewportElement","mouseEventListeners","wheelEventListener","touchEventListeners","imageRenderedEventDispatcher","cameraModifiedEventDispatcher","imageSpacingCalibratedEventDispatcher","mouseToolEventDispatcher","keyboardToolEventDispatcher","touchToolEventDispatcher","synchronizersFilteredByIds","synchronizer","notDisabled","isDisabled","hasSourceViewport","hasTargetViewport","elementDisabledEvt","_elementDisabledEvt$d","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","removeViewportElement","getSynchronizersForViewport","sync","remove","_removeViewportFromSynchronizers","getToolGroupForViewport","removeViewports","_removeViewportFromToolGroup","foundElementIndex","el","_removeEnabledElement","viewportIdsToRender","getViewport","triggerAnnotationRenderForViewportIds","getRenderingEngines","viewportIds","getViewports","_assertThisInitialized","ReferenceError","_setPrototypeOf","p","_inherits","subClass","superClass","_possibleConstructorReturn","_getPrototypeOf","SegmentationState","segmentationConfig","getGlobalRepresentationConfig","representationType","setGlobalRepresentationConfig","segmentationRepresentationConfig","setSegmentationVisibility","visibility","segmentsHidden","indices","scalarData","getScalarData","keySet","it","parseInt","_segmentation$represe","geometryIds","CONTOUR","geometryId","getSegmentIndex","getSegmentationIndices","getSegmentationVisibility","setSegmentsVisibility","segmentIndices","segRepresentation","setSegmentVisibility","BaseTool","toolProps","defaultToolProps","initialProps","_initialProps$configu","supportedInteractionTypes","strategies","defaultStrategy","activeStrategy","strategyOptions","assign","operationData","_this$configuration","newConfiguration","strategyName","setConfiguration","_actorEntries$find","volumeId","actorEntries","getActors","actorEntry","actor","getClassName","targetId","startsWith","imageId","split","imageURI","viewports","getCurrentImageId","getImageData","StackViewport","BaseVolumeViewport","getTargetVolumeId","VideoViewport","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","actorUIDsToRemove","Boolean","removeActors","pointToString","point","decimals","parseFloat","toFixed","polyDataCache","updateSurfacePlanes","vtkPlanes","clippingFilter","mapper","getMapper","viewPlaneNormal","getCamera","imageIndex","getCurrentImageIdIndex","cacheId","actorCache","polyData","setClippingPlanes","update","getOutputData","setInputData","surface","actorUID","getPoints","polys","getPolys","color","getColor","vtkPolyData","setData","triangles","vtkCellArray","Float32Array","setPolys","vtkMapper","VolumeViewport3D","vtkClipClosedSurface","clippingPlanes","activePlaneId","passPointData","setGenerateOutline","setGenerateFaces","filteredData","vtkActor","setMapper","getProperty","setColor","addActor","_addSegmentationRepresentation","_callee","representationInput","toolGroupSpecificConfig","toolGroupSpecificRepresentation","currentToolGroupConfig","mergedConfig","_context","Representations","SegmentationConfig","_callee2","toolGroupConfig","SurfaceData","geometry","surfaceUID","_context2","_renderSurface","resetCamera","render","getActor","addSurfaceToElement","_x4","_x5","_x6","_x2","_x3","renderImmediate","getToolGroup","removeSurfaceFromElement","_removeSurfaceFromToolGroupViewports","getViewportsInfo","contourRepresentation","segmentId","_contourRepresentatio","_contourRepresentatio2","configCachePerSegmentationRepresentationUID","getConfigCache","setConfigCache","addContourSetsToElement","contourRepresentationConfig","contourActorUID","appendPolyData","vtkAppendPolyData","scalarToColorMap","segmentSpecificMap","validateGeometry","contourSet","pointArray","vtkPoints","lines","pointIndex","getContours","contour","pointList","flatPoints","getFlatPointsArray","getType","pointIndexes","_","pointListIndex","linePoints","insertNextCell","polygon","setPoints","setLines","getPolyData","getNumberOfPoints","scalars","vtkDataArray","numberOfComponents","dataType","setTuple","getPointData","setScalars","addInputData","polyDataOutput","setLineWidth","setForceOpaque","updateContourSets","newContourConfig","cachedConfig","contourSetsActor","newOutlineWithActive","lut","getLookupTable","segmentsToSetToInvisible","segmentsToSetToVisible","_step2","_iterator2","mergedInvisibleSegments","_geometryIds$reduce","acc","contourSets","segmentSpecificConfigs","affectedSegments","hasCustomSegmentSpecificConfig","polyDataModified","getInputData","appendScalarsData","getScalars","getData","_segmentSpecificConfi","getTotalNumberOfPoints","segmentConfig","modified","setLookupTable","addOrUpdateContourSets","representationConfig","contourData","removeContourFromElement","_removeContourFromToolGroupViewports","deleteConfigCache","_addLabelmapToElement","volumeInputs","blendMode","addVolumesToViewports","removeVolumeActors","MAX_NUMBER_COLORS","labelMapConfigCache","cfun","ofun","vtkColorTransferFunction","vtkPiecewiseFunction","addPoint","isSameFrameOfReference","referencedVolumeId","defaultActor","getDefaultActor","defaultActorUID","volume","referencedVolume","renderingConfig","labelmapData","labelmapUID","_segmentation","_ref3","_addLabelmapToViewport","_setLabelmapColorAndOpacity","toolGroupLabelmapConfig","isActiveLabelmap","segmentationRepresentationLabelmapConfig","numColors","min","volumeActor","_getLabelmapConfig2","_getLabelmapConfig","outlineWidth","segmentColor","_getLabelmapConfig3","_needsTransferFunctio","_needsTransferFunctionUpdate","forceOpacityUpdate","forceColorUpdate","addRGBPoint","segmentOpacity","removePoint","addPointLong","setRGBTransferFunction","setClamping","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","setLabelOutlineThickness","setVisibility","segmentsLabelmapConfig","segmentLabelmapConfig","configToUse","cacheUID","oldConfig","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","_x7","_x8","_x9","_addLabelmapToViewport2","_callee3","_context3","addLabelmapToElement","removeLabelmapFromElement","_removeLabelmapFromToolGroupViewports","SegmentationDisplayTool","_BaseTool","_super","toolGroupViewports","segmentationRenderList","_renderers","_getMergedRepresentationsConfig","viewportsRenderList","display","labelmapDisplay","contourDisplay","surfaceDisplay","renderedViewport","allSettled","SegmentationRenderingEngine","_toolGroupIds","_setToolGroupSegmentationToBeRenderedNextFrame","_renderFlaggedToolGroups","segmentationDisplayToolInstance","onSegmentationRender","renderSegmentation","csToolsEvents","segmentationRenderingEngine","triggerSegmentationRender","renderToolGroupSegmentations","_SegmentationState$ge","segmentationVolume","slicesToUpdate","imageData","vtkOpenGLTexture","numSlices","getDimensions","setUpdatedFrame","segmentationRepresentationUIDs","immediate","toolGroupSegRepresentations","toolGroupSegRepresentationUIDs","segRepresentationUIDsToRemove","invalidSegRepresentationUIDs","segRepresentationUID","segmentationDataUID","_removeSegmentation","toolGroupIndex","removeToolGroup","removeSegmentationsFromToolGroup","csToolsState","destroyToolGroup","csToolsInitialized","init","_removeCornerstoneEventListeners","elementEnabledEvent","elementDisabledEvent","removeEnabledElement","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","TOOLS_EVENTS","annotationModifiedListener","annotationSelectionListener","segmentationModifiedListener","segmentationDataModifiedEventListener","segmentationRepresentationModifiedEventListener","segmentationRepresentationRemovedEventListener","destroy","restoreAnnotations","resetState","addTool","ToolClass","toolAlreadyAdded","toolClass","removeTool","cancelActiveManipulations","cancel","Synchronizer","synchronizerId","eventHandler","options","_ignoreFiredEvents","_targetViewports","_sourceViewports","fireEvent","_enabled","_eventName","_eventHandler","_options","_hasSourceElements","_viewportOptions","addTarget","addSource","_containsViewport","_onEvent","_updateDisableHandlers","removeSource","t","removeTarget","_getViewportIndex","_getViewportElement","sourceViewport","sourceEvent","promises","targetViewport","ex","vp1","vp2","unique","vps","_loop","u","_getUniqueViewports","_remove","disableHandler","vUid","ar","synchronizerIndex","DEFINED_CURSORS","STANDARD_CURSORS","MouseCursor","fallback","getStyleProperty","addFallbackStyleProperty","definedCursors","getDefinedCursors","mouseCursor","cursor","standardCursorNames","_get","Reflect","property","receiver","base","AnnotationStyleStates","ImageMouseCursor","_MouseCursor","url","getUniqueInstanceName","Number","prefix","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Probe","RectangleROI","TextMarker","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","registerCursor","svgCursorNames","ToolStyle","_initializeConfig","colorHighlighted","colorSelected","colorLocked","lineWidth","lineDash","shadow","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","default","styles","annotationSpecificStyles","viewportSpecificStyles","toolGroupSpecificStyles","toolStyle","specifications","_getToolStyle","getAnnotationToolStyles","getViewportToolStyles","global","getToolGroupToolStyles","globalStyles","getDefaultToolStyles","toolStyles","styleSpecifier","alternatives","list","getHierarchalPropertyStyles","STATE","MODE","SVGMouseCursor","_ImageMouseCursor","pointer","urn","getCursorURN","getDefinedSVGCursorDescriptor","createSVGMouseCursor","format","template","dictionary","dict","defined","_descriptor$mousePoin","URL","createObjectURL","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","createSVGIconUrl","scale","max","svgSize","ELEMENT_CURSORS_MAP","initElementCursor","_getElementCursors","_setElementCursor","cursors","getDefinedCursor","resetElementCursor","hideElementCursor","Disabled","ToolGroup","toolInstanceName","_toolInstances","toolDefinition","hasToolName","localToolInstance","instantiatedTool","parentClassName","_state$tools$toolName","ToolClassToUse","ToolInstance","_ParentClass","renderingEngines","renderingEngineUIDToUse","getActivePrimaryMouseButtonTool","vpInfo","setActiveStrategy","setToolDisabled","setToolEnabled","setToolPassive","setToolActive","toolBindingsOptions","prevBindings","newBindings","TouchBinding","MouseBinding","binding2","binding1","useCursor","_hasMousePrimaryButtonBinding","_setCursorForViewports","onSetToolActive","_renderViewports","_triggerToolModeChangedEvent","prevToolOptions","getToolOptions","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","_getCursor","cursorName","overwrite","_configuration","Primary","configurationPath","newToolGroupId","_fnToolFilter","fnToolFilter","_sourceToolOptions$bi","sourceToolInstance","sourceToolOptions","sourceToolMode","setToolMode","_toolOptions$bindings","_ref4","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","setCamera","CAMERA_MODIFIED","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","voiSyncCallback","voiModifiedEvent","range","invertStateChanged","invert","tProperties","voiRange","syncInvertState","setProperties","createVOISynchronizer","zoomPanSyncCallback","getOptions","sViewport","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createZoomPanSynchronizer","low","high","scroll","getImageIds","viewportType","debounceLoading","loop","VolumeViewport","_csUtils$getVolumeVie","numScrollSteps","currentStepIndex","sliceRangeInfo","sliceRange","spacingInNormalDirection","focalPoint","_csUtils$snapFocalPoi","newFocalPoint","newPosition","desiredStepIndex","VolumeScrollEventDetail","currentImageId","EVENTS","scrollVolume","_jumpToSlice","_getImageSliceData2","currentImageIndex","numberOfSlices","imageIndexToJump","_args","_getImageSliceData","_getImageIndexToJump","getTargetImageIdIndex","clip","getSpatialRegistration","sourceId","stackImageSyncCallback","_stackImageSyncCallback","imageId1","imagePlaneModule1","sourceImagePositionPatient","targetImageIds","registrationMatrixMat4","frameOfReferenceUID1","frameOfReferenceUID2","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","disabled","metaData","imagePositionPatient","viewport2","viewPlaneNormal1","viewPlaneNormal2","dotProducts","vec3","getFrameOfReferenceUID","useInitialPosition","mat4","_getClosestImageIdIndex","jumpToSlice","targetPoint","imageIds","closestImageIdIndex","distance","Infinity","STACK_NEW_IMAGE","createStackImageSynchronizer","drawingElementType","nodeUID","attributes","currentValue","getAttribute","removeAttribute","circleUID","center","radius","dataId","_Object$assign","fill","strokeOpacity","fillOpacity","strokeWidth","svgNodeHash","_getHash","existingCircleElement","cx","cy","stroke","setAttributesIfNecessary","newCircleElement","setNewAttributesIfValid","ellipseUID","corner1","corner2","existingEllipse","w","h","rx","ry","svgEllipseElement","handleGroupUID","handlePoints","opacity","side","existingHandleElement","newHandleElement","drawLine","lineUID","start","end","existingLine","dropShadowStyle","x1","y1","x2","y2","newLine","drawPolyline","polylineUID","fillColor","connectLastToFirst","existingPolyLine","pointsAttribute","firstPoint","newPolyLine","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","getBBox","insertBefore","firstChild","bBox","textUID","textLines","textGroupBoundingBox","padding","fontFamily","fontSize","background","existingTextGroup","textElement","textSpans","textSpan","textAttributes","textGroupAttributes","textGroup","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","findClosestPoint","sourcePoints","minPoint","minDistance","sourcePoint","p2","_p","_p2","textBoxUID","textBoxPosition","annotationAnchorPoints","textBox","mergedOptions","centering","canvasBoundingBox","drawTextBox","linkUID","refPoint","boundingBox","halfWidth","halfHeight","_boundingBoxPoints","drawLink","drawRect","rectangleUID","_width","existingRect","tlhc","svgRectElement","drawArrow","arrowUID","angle","atan2","firstLine","cos","PI","sin","secondLine","drawRedactionRect","_setAttributesIfNecessary","_setNewAttributesIfValid","getAnnotationNearPoint","getAnnotationNearPointOnEnabledElement","found","findAnnotationNearPointByTool","_viewport$getCurrentI","currentId","_annotation$metadata","referencedImageId","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","useRAF","invokeFunc","time","thisArg","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","_len","_key","leadingEdge","cancelTimer","flush","pending","debounce","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","calibrationOrScale","getStackViewports","calibrateSpacing","pointInShapeCallback","pointInShapeFn","callback","boundsIJK","iMin","iMax","jMin","jMax","kMin","kMax","dimensions","_boundsIJK","_boundsIJK$","_boundsIJK$2","_boundsIJK$3","getDirection","rowCosines","columnCosines","scanAxisNormal","_spacing","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","yMultiple","zMultiple","pointsInShape","k","pointIJK","dI","dJ","dK","startWorld","pointLPS","xMin","xMax","yMin","yMax","zMin","zMax","floor","_dimensions","depth","transformWorldToIndex","pointInSurroundingSphereCallback","circlePoints","_getBounds2","_circlePoints","bottom","centerWorld","radiusWorld","centerIJK","spacings","minSpacing","maxRadiusIJK","ceil","_circlePoints2","viewUp","viewRight","topLeftWorld","bottomRightWorld","sphereCornersIJK","getBoundingBoxAroundShape","_computeBoundsIJKWithCamera","_getBounds","sphereObj","sphere","pointInSphere","precision","fixedPrecision","imageVolume","strategySpecificConfiguration","THRESHOLD_INSIDE_CIRCLE","voxelValue","threshold","fillSphere","scalarIndex","isWithinThreshold","minSlice","maxSlice","v","fillInsideSphere","thresholdInsideSphere","eraseInsideSphere","getCanvasEllipseCorners","ellipseCanvasPoints","_ellipseCanvasPoints","right","pointInEllipse","ellipse","circleCenterWorld","xRadius","yRadius","zRadius","_pointLPS","z","_circleCenterWorld","x0","y0","z0","inside","fillCircle","_getCanvasEllipseCorn2","worldToCanvas","topLeftCanvas","bottomRightCanvas","ellipsoidCornersIJK","ellipseObj","fillInsideCircle","thresholdInsideCircle","eraseInsideCircle","getActiveSegmentationRepresentation","setActiveSegmentationRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","getLockedSegments","setActiveSegmentIndex","getActiveSegmentIndex","unshift","setColorLUT","getColorForSegmentIndex","setColorForSegmentIndex","colorReference","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE","brushSize","disableCursor","activeSegmentationRepresentation","activeSegmentation","segmentLocking","segmentationState","firstVolumeActorUID","_editData","_activateDraw","triggerAnnotationRenderForViewportUIDs","updateCursor","_this$_editData","_this$_hoverData","_hoverData","brushCursor","_brushCursor$metadata","handles","applyActiveStrategy","_this$_editData2","_this$_hoverData2","_brushCursor$metadata2","_deactivateDraw","_endCallback","_dragCallback","eventData","centerCanvas","segmentIndexController","_calculateCursor","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","toolMetadata","brushCursorUID","canvasCoordinates","drawCircleSvg","getBrushToolInstances","toolInstances","getVoxelOverlap","voxelSpacing","voxelCenter","voxelCornersWorld","voxelCornersIJK","processVolumes","thresholdVolumeInformation","segmentationSpacing","spacing","volumeInfoList","baseVolumeIdx","_thresholdVolumeInfor","volumeSize","b","referenceValues","lower","upper","segmentationImageData","overlapType","overlaps","_processVolumes","testOverlapRange","volumeInfo","overlapBounds","overlapTest","testRange","computeOffsetIndex","insert","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","filterViewportsWithToolEnabled","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolMode","EPS","vpCamera","getViewportIdsWithToolToRender","requireParallelNormals","filterViewportsWithParallelNormals","PARALLEL_THRESHOLD","CONSTANTS","filterAnnotationsWithinSlice","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","rowCosineVec","colCosineVec","isParallel","halfSpacingInNormalDirection","annotationsWithinSlice","dir","dot","filterAnnotationsForDisplay","colonIndex","substring","toolData","highlighted","AnnotationDisplayTool","getFramesOfReference","frameOfReference","worldPos","getTargetId","AnnotationTool","_AnnotationDisplayToo","_toolProps$configurat","_toolProps$configurat2","filteredAnnotations","activateHandleIndex","activeHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","notNearToolAndMarkedActive","getTextLines","statsCalculator","_data$handles","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","annotationCanvasCoordinate","vec2","getStyle","_volume$scaling","scaling","PT","scalingModule","suvbw","CalibrationTypes","PIXEL_UNITS","getCalibratedLengthUnits","image","calibration","units","hasPixelSpacing","UNCALIBRATED","SequenceOfUltrasoundRegions","getCalibratedAreaUnits","getCalibratedScale","_image$calibration","dist2","p1","distanceToPointSquared","lineStart","lineEnd","d2","distanceToPoint","_rect","lineSegments","rectToLineSegments","segment","_lineSegments$segment","lineSegment","getTextBoxCoordsCanvas","annotationCanvasPoints","canvasPoints","handlesLeftToRight","handlesTopToBottom","corners","sort","getWorldWidthAndHeightFromCorners","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getModalityUnit","modality","isPreScaled","isSuvScaled","generalSeriesModule","petSeriesModule","_handlePTModality","isViewportPreScaled","targetIdTokens","preScale","scaled","Calculator","BasicStatsCalculator","_Calculator","currentMax","sum","sumSquares","squaredDiffSum","mean","stdDev","stdDevWithSumSquare","unit","RectangleROITool","_AnnotationTool","preventHandleOutsideImage","defaultGetTextLines","isDrawing","getReferencedImageId","hasMoved","worldPosition","editData","handleIndex","movingTextBox","newAnnotation","canvasPoint1","canvasPoint2","_getRectangleImageCoordinates","rectangle","_activateModify","_this$editData","_deactivateModify","isHandleOutsideImage","_this$editData2","worldPosDelta","bottomLeftCanvas","topRightCanvas","bottomLeftWorld","topRightWorld","_enabledElement$viewp","_this$editData3","_annotations2","renderStatus","activeHandleCanvasCoords","_viewport$getCamera","areaUnit","_throttledCalculateCachedStats","referencedImageURI","hasImageURI","currentImageURI","Modality","area","_calculateCachedStats","drawHandlesSvg","drawRectSvg","getLinkedTextBoxStyle","canvasTextBoxCoords","drawLinkedTextBoxSvg","_ret","_points2","worldPos1","worldPos2","targetIds","getTargetIdImage","worldPos1Index","worldPos2Index","_isInsideVolume","_stats$","_stats$2","_stats$3","_getWorldWidthAndHeig","modalityUnitOptions","modalityUnit","statsCallback","stats","getStatistics","statsArray","index1","index2","throttle","cachedVolumeStats","roundNumber","RectangleROIThresholdTool","_RectangleROITool","RectangleROIStartEndThresholdTool","numSlicesToPropagate","startIndex","spacingInNormal","endIndex","_getEndSliceIndex","startSlice","endSlice","projectionPoints","projectionPointsImageIds","_computeProjectionPoints","sliceIndex","firstOrLastSlice","lineDashToUse","_calculateCachedStatsTool","startIJK","endIJK","indexToWorldVec3","endWorld","newProjectionPoints","dist","newPoint","_newProjectionPoints","RectanglePoints","endPos","imageIdIndex","numSlicesToProject","sliceNormalIndex","referenceVolume","AllBoundsIJK","_data$cachedStats","_data$cachedStats2","pointsToUse","rectangleCornersIJK","extend2DBoundingBoxInViewAxis","annotationUIDs","validToolNames","_validateAnnotations","getBoundsIJKFromRectangleAnnotations","thresholdVolumeByRange","labelmaps","origin","labelmap","outputData","arrayType","volumeLoader","isValidRepresentationConfig","SegmentationRepresentation","isValidLabelmapConfig","getDefaultRepresentationConfig","createLabelmapVolumeForViewport","_createLabelmapVolumeForViewport","_viewport$getDefaultA","_options$volumeId","properties","_viewport$getDefaultA2","defaultEquals","lpad","character","join","seed","job","getArgs","prevArgs","onFlood","onBoundary","equals","diagonals","startNode","permutations","perms","permutation","c","permute","perm","countNonZeroes","flooded","visits","bounds","currentArgs","previousArgs","node","safely","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","boundaries","setBrushSizeForToolGroup","invalidateBrushCursor","viewportsInfoArray","getViewportIds","getBrushSizeForToolGroup","brushToolInstance","setBrushThresholdForToolGroup","getBrushThresholdForToolGroup","segmentationIndex","_handleSameSizeVolume","getPoint","_handleDifferentSizeVolume","EPSILON","INSIDE","OUTSIDE","clipT","num","denom","_c","tE","tL","box","da","db","_a","_b","dx","dy","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","_line1Start","_line1End","_line2Start","x3","y3","_line2End","x4","y4","a1","b1","c1","r3","r4","a2","b2","c2","r1","r2","getFirstIntersectionWithPolyline","q1","initialI","doesIntersect","getClosestIntersectionWithPolyline","intersections","q2","distances","intersection","intersectionPoints","midpoint","orient","orientation","onSegment","q","orientationValue","getIntersection","denominator","numerator1","numerator2","subPixelResolution","xDir","yDir","volumeSpacing","iVector","jVector","kVector","xSpacing","absViewRightDotI","absViewRightDotJ","absViewRightDotK","ySpacing","absViewUpDotI","absViewUpDotJ","absViewUpDotK","closeContourProximity","newCanvasPoint","commonData","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","calculateAreaOfPoints","_p$","z1","_p2$","z2","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","pickedPoint","stepSize","cameraPosition","step","getBounds","vector","vtkMath","pointT","_inBounds","pointToPick","getIntensityFromWorld","_bounds","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","toUpperCase","addToolState","getToolState","ViewportStatus","dynamicVolumesPlayingMap","playClip","playClipOptions","_playClipOptions$dyna","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","_playClipOptions$fram","_playClipOptions$fram2","_playClipOptions$reve","_playClipOptions$loop","_getVolumeFromViewport","playClipContext","_playClipOptions$wait","waitForRendered","frameTimeVectorEnabled","waitForRenderedCount","viewportStatus","RENDERED","_createStackViewportCinePlayContext","isDynamicVolume","numTimePoints","timePointIndex","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","volumeViewPlaneNormal","glMatrix","_createVolumeViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","_getPlayClipTimeouts2","sample","delay","limit","timeouts","isTimeVarying","_getPlayClipTimeouts","playClipAction","newStepIndex","CINE_EVENTS","playClipTimeoutHandler","setInterval","stopClip","stopDynamicCine","cineToolData","clearInterval","dynamicCineElement","volumes","_getVolumesFromViewport","dynamicVolume","v1","v2","v0","v3","t1","t2","t3","basis","interpolator","samples","zip","matrix","m","valueof","transpose","row","interpolateSegmentPoints","iniIndex","knotsRatioPercentage","_Math$floor","_Math$floor2","segmentSize","amountOfKnots","minKnotDistance","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","interpolatedPoints","originalPoints","knotsIndexes","xInterpolator","d3InterpolateBasis","yInterpolator","zInterpolator","d3Zip","d3Quantize","interpolatePoints","minDistributionDistance","closedInterval","_closedInterval","intervalIni","intervalEnd","intervalSize","intensity","continuosDistributionValue","round","getContinuousUniformDistributionValues","shouldInterpolate","_configuration$interp","_configuration$interp2","interpolation","interpolateOnAdd","interpolateOnEdit","followingIndex","circularFindNextIndexBy","listParams","otherListParams","criteria","_listParams","indexDelimiter","_otherListParams","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","_interpolation$interp","_interpolation$interp2","previousPoints","findMatchIndexes","firstMatchIndex","previousFirstMatchIndex","toBeNotEqualCriteria","pointA","pointB","isEqualByProximity","_circularFindNextInde2","lowDiffIndex","lowOtherDiffIndex","findChangedSegment","changedIniIndex","changedEndIndex","findOpenUShapedContourVectorToPeak","first","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","addCanvasPointsToArray","polyline","pointsAreWithinCloseContourProximity","getSubPixelSpacingAndXYDirections","activateDraw","canvasPos","_getSubPixelSpacingAn","drawData","polylineIndex","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","_this$commonData","_this$drawData","lastWorldPoint","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","allowOpenContours","lastPoint","completeDrawOpenContour","completeDrawClosedContour","removeCrossedLinesOnCompleteDraw","haltDrawing","_this$commonData2","worldPoints","isOpenContour","triggerAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","indexToRemoveUpTo","_this$commonData3","isOpenUShapeContour","openUShapeContourVectorToPeak","pointsLessLastOne","_this$commonData4","shift","activateClosedContourEdit","cancelDrawing","minPoints","shouldHaltDrawing","_this$commonData5","checkForFirstCrossing","isClosedContour","editCanvasPoints","prevCanvasPoints","crossedLineSegment","startCrossingIndex","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","twoClosestDistanceIndexPairs","lowestIndex","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","editIndex","numPointsToRemove","checkForSecondCrossing","removePointsAfterSecondCrossing","lastLine","didCrossLine","findSnapIndex","_this$editData4","lastEditCanvasPoint","editCanvasPointsLessLastOne","snapCanvasPosition","checkAndRemoveCrossesOnEditLine","editIndexCrossed","isEditingClosed","mouseUpClosedContourEditCallback","mouseDragClosedContourEditCallback","deactivateClosedContourEdit","currentEditIndex","snapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","finishEditAndStartNewEdit","triggerAnnotationModified","lowIndex","highIndex","augmentedEditCanvasPoints","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","cancelClosedContourEdit","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activateOpenContourEndEdit","lastCanvasPos","p3","aDotb","magA","magB","acos","newCanvasPoints","pointsToRender","_this$editData5","completeOpenContourEdit","_this$editData6","cancelOpenContourEdit","_getRenderingOptions","renderContour","findOpenUShapedContourVectorToPeakOnRender","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","renderClosedContour","drawPolylineSvg","_this$configuration$a","alwaysRenderOpenContourHandles","enabled","handlePoint","_annotation$data","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","pointCanProjectOnLine","PlanarFreehandROITool","calculateStats","previousPoint","pStart","pEnd","activeAnnotationUID","_renderStats","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","worldPosIndex","iDelta","jDelta","kDelta","worldPosEnd","canvasPosEnd","curRow","intersectionCounter","polylineIndexes","getAllIntersectionsWithPolyline","getIntersectionCoordinatesWithPolyline","_annotation$annotatio","drawLinkedTextBox","registerDrawLoop","registerEditLoopCommon","registerClosedContourEditLoop","registerOpenContourEditLoop","registerOpenContourEndEditLoop","registerRenderMethods","annotationsToDisplay","isEmptyArea","areaLine","interpolateAnnotation","shouldPreventInterpolation","interpolatedCanvasPoints","requestType","priority","lowEnd","highEnd","getStackData","currentImageIdIndex","getPromiseRemovedHandler","stackData","stackPrefetchData","indicesToRequest","resetPrefetchTimeout","clearFromImageIds","imageIdSet","requestDetails","additionalDetails","maxImagesToPrefetch","preserveExistingPool","prefetch","_stack$imageIds","_stackPrefetch$indice","stackPrefetch","removeFromList","imageLoadPoolManager","nextImageIdIndex","nearest","idx","lowerIndex","higherIndex","imageIdsToPrefetch","currentIndex","shouldLoadLower","shouldLoadHigher","requestFn","imageLoader","useNorm16Texture","getCoreConfiguration","rendering","targetBuffer","onImageUpdated","indexOfCurrentImage","promiseRemovedHandler","getConfiguration","minBefore","maxAfter","directionExtraImages","indicesToRequestCopy","_image$image","decodeTimeInMS","_image$image2","loadTimeInMS","sizeInBytes","usage","cacheFill","fillTime","fillSize","initialTime","initialSize","updateToolState","doneCallback","_configuration$maxAft","_configuration$minBef","_configuration2$direc","stackCount","totalBytes","positionFraction","minIndex","maxIndex","jumpToWorld","jumpWorld","normal","dotProd","projectedDelta","_applyShift","frames","frameNumbers","maskVolumeId","imageCoordinate","dataInTime","maskImageData","segScalarData","nonZeroVoxelIndices","actualLen","dynamicVolumeScalarDataArray","getScalarDataArrays","indexValues","frame","activeScalarData","segPointLPS","overlapIJKMinMax","perFrameSum","averageValues","_getTimePointDataMask","coordinate","worldToIndex","allScalarData","_getTimePointDataCoordinate","operation","numFrames","typedArrays","arrayLength","finalArray","currentArray","getPolyDataPointIndexes","linesData","getLines","contours","findStartingPoint","startPoint","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","ColorbarRangeTextPosition","isRangeValid","areColorbarRangesEqual","isColorbarSizeValid","areColorbarSizesEqual","clamp","ColorbarCanvas","validateProps","colormap","_props$size","_props$imageRange","imageRange","_props$voiRange","container","_props$showFullPixelV","showFullPixelValueRange","_colormap","_imageRange","_voiRange","_showFullImageRange","_canvas","_createRootElement","appendTo","_this$_canvas","_setCanvasSize","showFullImageRange","parentElement","createElement","boxSizing","isConnected","rgbPoints","RGBPoints","colorsCount","getColorPoint","_this$_canvas2","canvasContext","getContext","isHorizontal","maxValue","windowWidth","previousColorPoint","currentColorPoint","incRawPixelValue","rawPixelValue","tVoiRange","normColor","tColorRange","fillStyle","fillRect","DEFAULTS","FONT","COLOR","TICK_SIZE","TICK_WIDTH","TICK_LABEL_MARGIN","MAX_NUM_TICKS","TICKS_STEPS","ColorbarTicks","_ticksStyle$font","_ticksStyle$color","_ticksStyle$tickSize","_ticksStyle$tickWidth","_ticksStyle$labelMarg","_ticksStyle$maxNumTic","_props$top","_props$left","ticksProps","ticks","ticksStyle","rangeTextPosition","_font","font","_color","_tickSize","tickSize","_tickWidth","tickWidth","_labelMargin","labelMargin","_maxNumTicks","maxNumTicks","_rangeTextPosition","Right","_showFullPixelValueRange","_createCanvasElement","showFullRange","roughStep","stepPower","log10","roughtStepNormalized","scaleMax","scaleMin","ticksCount","labelMeasure","labelPoint","tickPoints","_ref5","maxCanvasPixelValue","rangeWidth","_getTicks","clearRect","textBaseline","strokeStyle","tick","measureText","_tickInfo","Top","_getTopTickInfo","_getBottomTickInfo","Left","_getLeftTickInfo","_getRightTickInfo","tickStart","tickEnd","beginPath","moveTo","lineTo","fillText","Widget","_entries$","contentRect","contentBoxSize","inlineSize","blockSize","_containerSize","onContainerResize","_id","_rootElement","createRootElement","_containerResizeObserver","ResizeObserver","_containerResizeCallback","rootElement","resizeObserver","currentContainer","unobserve","observe","disconnect","MULTIPLIER","RANGE_TEXT_POSITION","TICKS_BAR_SIZE","Colorbar","_Widget","_props$ticks$position","_props$ticks","_isMouseOver","showTicks","hideTicks","_isInteracting","_addVOIEventListeners","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startVOIRange","canvasDelta","local","wwDelta","wcDelta","voiLower","voiUpper","_csUtils$windowLevel$","windowCenter","newVoiRange","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_createCanvas","_ticksBar","_createTicksBar","_addRootElementEventListeners","colormapName","currentVoiRange","onVoiChange","updateTicksBar","containerSize","_this$containerSize","containerWidth","containerHeight","ticksBarTop","ticksBarLeft","ticksBar","colorbarWidth","colorbarHeight","Bottom","isRangeTextPositionValid","_mouseOverCallback","_mouseOutCallback","_mouseDownCallback","initialDragState","_mouseUpCallback","_mouseDragCallback","colormaps","items","Name","activeColormapName","cm","defaultImageRange","ViewportColorbar","_Colorbar","_getImageRange","_getVOIRange","_hideTicksTimeoutId","timeLeft","_hideTicksTime","autoHideTicks","_element","_volumeId","showAndAutoHideTicks","_addCornerstoneEventListener","_viewport$element","clientWidth","clientHeight","ptMultiplier","_ref$fixedPTWindowWid","fixedPTWindowWidth","xMultiplier","viewportsContainingVolumeUID","interval","IMAGE_VOLUME_MODIFIED","_imageVolumeModifiedCallback","_stackNewImageCallback","VOI_MODIFIED","_viewportVOIModifiedCallback","getRange","getRGBTransferFunction","setElementCursor","CursorNames","segmentationInputArray","validateLabelmap","validateSegmentationInput","segInput","addSegmentationToState","_addSegmentationRepresentations","representationInputArray","toolGroupSpecificRepresentationConfig","all","_addSegmentationRepresentation2","PanTool","deltaPointsWorld","updatedPosition","updatedFocalPoint","TrackballRotateTool","rotateIncrementDegrees","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPointsCanvas","lastPointsCanvas","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","upVec","atV","rightV","forwardV","rotateCamera","angleY","ProbeTool","eventDispatchDetail","textCanvasCoordinates","drawTextBoxSvg","DragProbeTool","_ProbeTool","WindowLevelTool","bytesPerVoxel","TypedArrayConstructor","middleSliceIndex","frameLength","Uint16Array","Int16Array","_this$_getMinMax","_getMinMax","newRange","_properties$voiRange","getProperties","_preScale$scalingPara","_properties$voiRange2","scalingParameters","getPTScaledNewRange","deltaPointsCanvas","getNewRange","multiplier","_getMultiplierFromDynamicRange","_utilities$windowLeve","imageDynamicRange","_imageVolume$metadata","calculatedDynamicRange","_getImageDynamicRangeFromMiddleSlice","BitsStored","metadataDynamicRange","_getImageDynamicRangeFromViewport","ratio","_this$_getMinMax2","voxel","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","pinch","parallelScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","_evt$detail2","zoomScale","directionOfProjection","tmp","_pinchCallback","_evt$detail3","parallelProjection","_dragParallelProjection","_dragPerspectiveProjection","_panCallback","_evt$detail4","StackScrollTool","debounceIfNotLoaded","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","_getNumberOfSlices","offsetHeight","angleBetweenLines","line1","line2","_line","_line2","p4","angleBetween3DLines","_line3","_line4","angleBetween2DLines","PlanarRotateTool","currentPointWorld","startPointWorld","cross","rotAngle","rotMat","rotatedViewUp","rotation","StackScrollMouseWheelTool","DIRECTIONS","X","Y","Z","CUSTOM","VolumeRotateMouseWheelTool","_focalPoint","cz","_direction","ax","ay","az","MIPJumpToClickTool","targetViewportIds","maxIntensity","brightestPoint","foundToolGroup","LengthTool","_data$handles$points","point2","line","drawLineSvg","dz","_calculateLength","RENDERING_DEFAULTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","CrosshairsTool","_toolProps$configurat3","_toolProps$configurat4","viewportIndicators","autoPan","panSize","referenceLinesCenterGapRadius","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","mobile","_getAnnotations","cameraFocalPoint","rotationPoints","slabThicknessPoints","toolCenter","activeOperation","activeViewportIds","_viewportsInfo","firstViewport","secondViewport","thirdViewport","_this$initializeViewp","initializeViewport","normal1","_this$initializeViewp2","normal2","normal3","point3","_this$initializeViewp3","firstPlane","secondPlane","thirdPlane","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","_autoPanViewportIfNecessary","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","_areViewportIdArraysEqual","_viewport$canvas","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","_otherViewport$canvas","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","liangBarksyClip","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","vtkMatrixBuilder","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","getSlabThickness","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","lineIndex","_this$configuration$m","_this$configuration$m2","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","_this$configuration$m3","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","_this$configuration$m4","_this$configuration$m5","_this$configuration$m6","_this$configuration$m7","_this$configuration$m8","_this$configuration$m9","_this$configuration$m10","_this$configuration$m11","handleUID","_this$configuration$m12","_this$configuration$m13","_this$configuration$m14","_this$configuration$m15","_this$configuration$m16","_this$configuration$m17","_this$configuration$m18","_this$configuration$m19","_getViewportsInfo","computeToolCenter","viewportIdArrayOne","viewportIdArrayTwo","itemFound","viewportsWithDifferentCameras","cameraOfTarget","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_getAnnotationsForViewportsWithDifferentCameras","actors","otherViewportActors","sameScene","viewportsAnnotationsToUpdate","_checkIfViewportsRenderingSameScene","_applyDeltaShiftToSelectedViewportCameras","_this$configuration$m20","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","translate","otherViewportsIds","renderViewports","referenceAnnotations","_filterViewportWithSameOrientation","viewportsIds","mod","currentPoint","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","setSlabThickness","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","_onNewVolume","_this4","_ref6","_viewport$canvas2","toolCenterCanvas","visiblePointCanvas","visiblePointWorld","slabThickness","actorUIDs","blendModeToUse","setBlendMode","_this5","_applyDeltaShiftToViewportCamera","_this6","_viewport$canvas3","_loop2","_i4","_i3","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","ReferenceLines","sourceViewportId","showFullDimension","_sourceViewport$getCa","sourceViewportCanvasCornersInWorld","_init","_annotation$data$hand","_targetViewport$getCa","sourceViewPlaneNormal","targetViewportPlane","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","handleFullDimension","vec1","targetImage","_map2","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","_map4","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","OverlayGridTool","sourceImageIds","imagePlaneModule","pointSets","calculateImageIdPointSets","viewportData","_metaData$get","rows","columns","rowPixelSpacing","columnPixelSpacing","imageIdNormal","getImageIdNormal","_pointSets$i","targetData","initializeViewportData","pointSetsToUse","lineStartsWorld","lineEndsWorld","SegmentationIntersectionTool","_getRenderingEngine","actorsWorldPointsMap","_getRenderingEngine2","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","getCacheId","actorWorldPointMap","polyLineIdx","_actorWorldPointMap$g","worldPointsSet","polyLineUID","actorWorldPointsMap","polyDataUtils","colorArray","colorComponentToString","component","componentString","colorToString","getWorldWidthAndHeightFromTwoPoints","EllipticalROITool","centerPointRadius","initialRotation","getRotation","_canvasCorners","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","currentCanvasPoints","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","_dragHandle","dYCanvas","canvasBottom","canvasTop","newHalfCanvasWidth","canvasLeft","canvasRight","dXCanvas","newHalfCanvasHeight","_dragModifyCallback","_dragDrawCallback","canvasCorners","drawEllipseSvg","centerPoint","_getCanvasEllipseCenter","location","normalized","getCanvasCircleRadius","circleCanvasPoints","_circleCanvasPoints","getCanvasCircleCorners","CircleROITool","radiusPoint","canvasCenter","canvasEnd","radiusUnit","perimeter","aspect","_image$calibration2","getCalibratedAspect","radiusLine","BidirectionalTool","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","shortAxis","currentShortAxisVector","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","dataId1","dataId2","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos3","worldPos4","dist1","index3","index4","vector1","vector2","_cachedStats$targetId","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","_annotations3","drawArrowSvg","updatedText","doneChangingTextCallback","prompt","AngleTool","angleStartedNotYetCompleted","canvasPoint3","_data$cachedStats$tar","fromCharCode","midPoint2","ret","CobbAngleTool","_this$distanceToLines","distanceToLines","_this$distanceToLines2","isNearFirstLine","isNearSecondLine","_data$cachedStats$tar3","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","_data$cachedStats$tar2","arc1TextLine","arch1TextPosCanvas","arc2TextLine","arch2TextPosCanvas","_points","point4","canvasPoint4","mid1","mid2","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","_this$getArcsStartEnd","getArcsStartEndPoints","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_getReferencedImageId","_createMagnificationViewport","magnifyToolElement","viewportProperties","magnifyElement","viewportInput","enableElement","magnifyViewport","setStack","_magnifyViewport$getC","_magnifyViewport$getC2","disableElement","_dragEndCallback","isSegmentation","referenceId","AdvancedMagnifyViewport","magnifyViewportId","sourceEnabledElement","_ref$radius","_ref$position","zoomFactor","_viewportId","_sourceEnabledElement","_autoPan","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_resizeViewportAsync","_resizeViewport","_initialize","_radius","_resized","_enabledElement","_position","_isViewportReady","_syncViewports","_removeEventListeners","parentNode","_this$_sourceToolGrou","magnifyToolGroup","_magnifyToolGroup","_sourceToolGroup","borderRadius","overflow","offsetWidth","sourceActors","magnifyToolGroupId","sourceToolGroup","clone","AdvancedMagnifyTool","addViewport","volumeInputArray","setVolumes","sourceViewportOptions","defaultOptions","_isStackViewport","_cloneStack","_isVolumeViewport","_cloneVolumes","_inheritBorderRadius","_cloneToolGroups","_cancelMouseEventCallback","_evt$target","_canAutoPan","closest","canvasCurrent","magnifyRadius","maxDist","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","cstEvents","_addBrowserEventListeners","_removeBrowserEventListeners","sourceCanvas","_createViewportNode","_addEventListeners","_cloneViewport","_convertZoomFactorToParalellScale","setImageIdIndex","sourceProperties","_syncViewportsCameras","_syncStackViewports","resize","AdvancedMagnifyViewportManager","sourceElement","_addSourceElementEventListener","_magnifyViewportsMap","_destroyViewport","_getMagnifyViewportsMapEntriesBySourceViewportId","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","_this$_magnifyViewpor","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","dispose","_annotationRemovedCallback","_newStackImageCallback","VOLUME_NEW_IMAGE","_newVolumeImageCallback","_AdvancedMagnifyViewp","_singleton","magnifyingGlass","zoomFactorList","Secondary","Shift","worldHandlesPoints","_getWorldHandlesPoints","magnifyViewportManager","createViewport","annotationPoints","_deltaPoints$world","newRadius","newWorldHandlesPoints","canvasCenterPos","canvasRadius","getInstance","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","focus","onChangeCallback","_evt$keyCode","_evt$key","which","toLowerCase","option","title","defaultSelected","ReferenceCursors","displayThreshold","positionSync","_currentCursorWorldPosition","_currentCanvasPosition","_elementWithCursor","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","previousCamera","oldFocalPoint","cameraNormal","dotProduct","isElementWithCursor","updateViewportImage","crosshairUIDs","_canvasCoordinates$","centerSpace","lineLength","_disableCursorEnabled","_annotation$data2","_annotation$data2$han","plane","currentMousePosition","closestIndex","normalizedViewPlane","scaledPlaneNormal","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","worldWidthViewport","worldHeightViewport","scaleSizes","scaleSize","locationTickOffset","endTick1","endTick2","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","pointSet","worldCoordinates","midpointLocation","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","computeScaleBounds","computeScaleSize","computeWorldScaleCoordinates","computeCanvasScaleCoordinates","scaleTicks","computeEndScaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textBoxLines","_getTextLines","_this$computeInnerSca","computeInnerScaleTicks","scaleSizeDisplayValue","scaleSizeUnits","fillInsideRectangle","constraintFn","coord","fillRectangle","eraseInsideRectangle","eraseRectangle","RectangleScissorsTool","FILL_INSIDE","ERASE_INSIDE","CircleScissorsTool","SphereScissorsTool","OverlayMarkerType","ANNOTATED_CUBE","AXES","OrientationMarkerTool","_createAnnotatedCubeActor","_createCustomActor","_addAxisActorInViewport","_overlayConfiguration","orientationWidget","viewportCorner","vtkOrientationMarkerWidget","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","OVERLAY_MARKER_TYPES","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","edgeThickness","edgeColor","resolution","polyDataURL","initViewports","configuration_invalidated","cleanUpData","orientationMarkers","orientationMarker","setEnabled","offscreenMultiRenderWindow","getRenderWindow","addAxisActorInViewport","_this$orientationMark","_actor","_orientationWidget","renderer","renderWindow","_this$configuration$o","getRenderer","removeActor","createAnnotationCube","vtkAxesActor","createCustomActor","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","response","vtpReader","fetch","vtkXMLPolyDataReader","parseAsArrayBuffer","shallowCopy","setActiveScalars","setColorModeToDirectScalars","rotateZ","vtkAnnotatedCubeActor","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","axes","annotatedCube","isEqual","PaintFillTool","fixedDimension","getFixedDimension","_this$generateHelpers","generateHelpers","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","clickedLabelValue","floodFillResult","floodFill","scalarDataPosition","getFramesModified","minJ","maxJ","framesModified","seedIndex3D","getScalarDataPosition","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","VideoRedactionTool","toolConfiguration","viewportUIDsToRender","toolDataCanvasCoordinate","drawRedactionRectSvg","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","vtkImageData","worldToIndexVec3","valueMinusMean","scene","volumeUID","volumeActors","getVolumeActors","coloneIndex"],"sourceRoot":""}